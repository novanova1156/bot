// src/clmm/index.ts
import {
  ComputeBudgetProgram as ComputeBudgetProgram2,
  PublicKey as PublicKey5,
  SYSVAR_RENT_PUBKEY,
  Transaction,
  SystemProgram as SystemProgram2
} from "@solana/web3.js";

// src/clmm/idl.ts
var IDL = {
  "version": "0.5.0",
  "name": "lb_clmm",
  "constants": [
    {
      "name": "BASIS_POINT_MAX",
      "type": "i32",
      "value": "10000"
    },
    {
      "name": "MAX_BIN_PER_ARRAY",
      "type": {
        "defined": "usize"
      },
      "value": "70"
    },
    {
      "name": "MAX_BIN_PER_POSITION",
      "type": {
        "defined": "usize"
      },
      "value": "70"
    },
    {
      "name": "MIN_BIN_ID",
      "type": "i32",
      "value": "- 443636"
    },
    {
      "name": "MAX_BIN_ID",
      "type": "i32",
      "value": "443636"
    },
    {
      "name": "MAX_FEE_RATE",
      "type": "u64",
      "value": "100_000_000"
    },
    {
      "name": "FEE_PRECISION",
      "type": "u64",
      "value": "1_000_000_000"
    },
    {
      "name": "MAX_PROTOCOL_SHARE",
      "type": "u16",
      "value": "2_500"
    },
    {
      "name": "HOST_FEE_BPS",
      "type": "u16",
      "value": "2_000"
    },
    {
      "name": "NUM_REWARDS",
      "type": {
        "defined": "usize"
      },
      "value": "2"
    },
    {
      "name": "MIN_REWARD_DURATION",
      "type": "u64",
      "value": "1"
    },
    {
      "name": "MAX_REWARD_DURATION",
      "type": "u64",
      "value": "31536000"
    },
    {
      "name": "EXTENSION_BINARRAY_BITMAP_SIZE",
      "type": {
        "defined": "usize"
      },
      "value": "12"
    },
    {
      "name": "BIN_ARRAY_BITMAP_SIZE",
      "type": "i32",
      "value": "512"
    },
    {
      "name": "MAX_REWARD_BIN_SPLIT",
      "type": {
        "defined": "usize"
      },
      "value": "15"
    },
    {
      "name": "BIN_ARRAY",
      "type": "bytes",
      "value": "[98, 105, 110, 95, 97, 114, 114, 97, 121]"
    },
    {
      "name": "ORACLE",
      "type": "bytes",
      "value": "[111, 114, 97, 99, 108, 101]"
    },
    {
      "name": "BIN_ARRAY_BITMAP_SEED",
      "type": "bytes",
      "value": "[98, 105, 116, 109, 97, 112]"
    },
    {
      "name": "PRESET_PARAMETER",
      "type": "bytes",
      "value": "[112, 114, 101, 115, 101, 116, 95, 112, 97, 114, 97, 109, 101, 116, 101, 114]"
    },
    {
      "name": "PERMISSION",
      "type": "bytes",
      "value": "[112, 101, 114, 109, 105, 115, 115, 105, 111, 110]"
    },
    {
      "name": "POSITION",
      "type": "bytes",
      "value": "[112, 111, 115, 105, 116, 105, 111, 110]"
    }
  ],
  "instructions": [
    {
      "name": "initializeLbPair",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "tokenMintX",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenMintY",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "oracle",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "presetParameter",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "funder",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "activeId",
          "type": "i32"
        },
        {
          "name": "binStep",
          "type": "u16"
        }
      ]
    },
    {
      "name": "initializePermissionLbPair",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "tokenMintX",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenMintY",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "oracle",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "presetParameter",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "funder",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "activeId",
          "type": "i32"
        },
        {
          "name": "binStep",
          "type": "u16"
        }
      ]
    },
    {
      "name": "initializeBinArrayBitmapExtension",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Initialize an account to store if a bin array is initialized."
          ]
        },
        {
          "name": "funder",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "initializeBinArray",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArray",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "funder",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "index",
          "type": "i64"
        }
      ]
    },
    {
      "name": "addLiquidity",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "userTokenX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenXProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "liquidityParameter",
          "type": {
            "defined": "LiquidityParameter"
          }
        }
      ]
    },
    {
      "name": "addLiquidityByWeight",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "userTokenX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenXProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "liquidityParameter",
          "type": {
            "defined": "LiquidityParameterByWeight"
          }
        }
      ]
    },
    {
      "name": "addLiquidityByStrategy",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "userTokenX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenXProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "liquidityParameter",
          "type": {
            "defined": "LiquidityParameterByStrategy"
          }
        }
      ]
    },
    {
      "name": "addLiquidityByStrategyOneSide",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "userToken",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserve",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "liquidityParameter",
          "type": {
            "defined": "LiquidityParameterByStrategyOneSide"
          }
        }
      ]
    },
    {
      "name": "addLiquidityOneSide",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "userToken",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserve",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "liquidityParameter",
          "type": {
            "defined": "LiquidityOneSideParameter"
          }
        }
      ]
    },
    {
      "name": "removeLiquidity",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "userTokenX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenXProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "binLiquidityRemoval",
          "type": {
            "vec": {
              "defined": "BinLiquidityReduction"
            }
          }
        }
      ]
    },
    {
      "name": "initializePosition",
      "accounts": [
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "position",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "lbPair",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "lowerBinId",
          "type": "i32"
        },
        {
          "name": "width",
          "type": "i32"
        }
      ]
    },
    {
      "name": "initializePositionPda",
      "accounts": [
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "base",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "owner"
          ]
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "lowerBinId",
          "type": "i32"
        },
        {
          "name": "width",
          "type": "i32"
        }
      ]
    },
    {
      "name": "initializePositionByOperator",
      "accounts": [
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "base",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "operator",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "operator"
          ]
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "lowerBinId",
          "type": "i32"
        },
        {
          "name": "width",
          "type": "i32"
        },
        {
          "name": "owner",
          "type": "publicKey"
        }
      ]
    },
    {
      "name": "updatePositionOperator",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "operator",
          "type": "publicKey"
        }
      ]
    },
    {
      "name": "swap",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": false,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenIn",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenOut",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "oracle",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "hostFeeIn",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "user",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenXProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "amountIn",
          "type": "u64"
        },
        {
          "name": "minAmountOut",
          "type": "u64"
        }
      ]
    },
    {
      "name": "withdrawProtocolFee",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "receiverTokenX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "receiverTokenY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "feeOwner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenXProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "amountX",
          "type": "u64"
        },
        {
          "name": "amountY",
          "type": "u64"
        }
      ]
    },
    {
      "name": "updateFeeOwner",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "newFeeOwner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": []
    },
    {
      "name": "initializeReward",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "rewardVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "rewardMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "rewardIndex",
          "type": "u64"
        },
        {
          "name": "rewardDuration",
          "type": "u64"
        },
        {
          "name": "funder",
          "type": "publicKey"
        }
      ]
    },
    {
      "name": "fundReward",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "rewardVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "rewardMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "funderTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "funder",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "binArray",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "rewardIndex",
          "type": "u64"
        },
        {
          "name": "amount",
          "type": "u64"
        },
        {
          "name": "carryForward",
          "type": "bool"
        }
      ]
    },
    {
      "name": "updateRewardFunder",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "rewardIndex",
          "type": "u64"
        },
        {
          "name": "newFunder",
          "type": "publicKey"
        }
      ]
    },
    {
      "name": "updateRewardDuration",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "binArray",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "rewardIndex",
          "type": "u64"
        },
        {
          "name": "newDuration",
          "type": "u64"
        }
      ]
    },
    {
      "name": "claimReward",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "rewardVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "rewardMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "userTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "rewardIndex",
          "type": "u64"
        }
      ]
    },
    {
      "name": "claimFee",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "closePosition",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "rentReceiver",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "updateFeeParameters",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "feeParameter",
          "type": {
            "defined": "FeeParameter"
          }
        }
      ]
    },
    {
      "name": "increaseOracleLength",
      "accounts": [
        {
          "name": "oracle",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "funder",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "lengthToAdd",
          "type": "u64"
        }
      ]
    },
    {
      "name": "initializePresetParameter",
      "accounts": [
        {
          "name": "presetParameter",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "ix",
          "type": {
            "defined": "InitPresetParametersIx"
          }
        }
      ]
    },
    {
      "name": "closePresetParameter",
      "accounts": [
        {
          "name": "presetParameter",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "rentReceiver",
          "isMut": true,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "removeAllLiquidity",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "userTokenX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenXProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "togglePairStatus",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": []
    },
    {
      "name": "updateWhitelistedWallet",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "idx",
          "type": "u8"
        },
        {
          "name": "wallet",
          "type": "publicKey"
        }
      ]
    },
    {
      "name": "migratePosition",
      "accounts": [
        {
          "name": "positionV2",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "positionV1",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rentReceiver",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "migrateBinArray",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "updateFeesAndRewards",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": []
    },
    {
      "name": "withdrawIneligibleReward",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "rewardVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "rewardMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "funderTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "funder",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "binArray",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "rewardIndex",
          "type": "u64"
        }
      ]
    }
  ],
  "accounts": [
    {
      "name": "binArrayBitmapExtension",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "lbPair",
            "type": "publicKey"
          },
          {
            "name": "positiveBinArrayBitmap",
            "docs": [
              "Packed initialized bin array state for start_bin_index is positive"
            ],
            "type": {
              "array": [
                {
                  "array": [
                    "u64",
                    8
                  ]
                },
                12
              ]
            }
          },
          {
            "name": "negativeBinArrayBitmap",
            "docs": [
              "Packed initialized bin array state for start_bin_index is negative"
            ],
            "type": {
              "array": [
                {
                  "array": [
                    "u64",
                    8
                  ]
                },
                12
              ]
            }
          }
        ]
      }
    },
    {
      "name": "binArray",
      "docs": [
        "An account to contain a range of bin. For example: Bin 100 <-> 200.",
        "For example:",
        "BinArray index: 0 contains bin 0 <-> 599",
        "index: 2 contains bin 600 <-> 1199, ..."
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "index",
            "type": "i64"
          },
          {
            "name": "version",
            "docs": [
              "Version of binArray"
            ],
            "type": "u8"
          },
          {
            "name": "padding",
            "type": {
              "array": [
                "u8",
                7
              ]
            }
          },
          {
            "name": "lbPair",
            "type": "publicKey"
          },
          {
            "name": "bins",
            "type": {
              "array": [
                {
                  "defined": "Bin"
                },
                70
              ]
            }
          }
        ]
      }
    },
    {
      "name": "lbPair",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "parameters",
            "type": {
              "defined": "StaticParameters"
            }
          },
          {
            "name": "vParameters",
            "type": {
              "defined": "VariableParameters"
            }
          },
          {
            "name": "bumpSeed",
            "type": {
              "array": [
                "u8",
                1
              ]
            }
          },
          {
            "name": "binStepSeed",
            "docs": [
              "Bin step signer seed"
            ],
            "type": {
              "array": [
                "u8",
                2
              ]
            }
          },
          {
            "name": "pairType",
            "docs": [
              "Type of the pair"
            ],
            "type": "u8"
          },
          {
            "name": "activeId",
            "docs": [
              "Active bin id"
            ],
            "type": "i32"
          },
          {
            "name": "binStep",
            "docs": [
              "Bin step. Represent the price increment / decrement."
            ],
            "type": "u16"
          },
          {
            "name": "status",
            "docs": [
              "Status of the pair"
            ],
            "type": "u8"
          },
          {
            "name": "padding1",
            "type": {
              "array": [
                "u8",
                5
              ]
            }
          },
          {
            "name": "tokenXMint",
            "docs": [
              "Token X mint"
            ],
            "type": "publicKey"
          },
          {
            "name": "tokenYMint",
            "docs": [
              "Token Y mint"
            ],
            "type": "publicKey"
          },
          {
            "name": "reserveX",
            "docs": [
              "LB token X vault"
            ],
            "type": "publicKey"
          },
          {
            "name": "reserveY",
            "docs": [
              "LB token Y vault"
            ],
            "type": "publicKey"
          },
          {
            "name": "protocolFee",
            "docs": [
              "Uncollected protocol fee"
            ],
            "type": {
              "defined": "ProtocolFee"
            }
          },
          {
            "name": "feeOwner",
            "docs": [
              "Protocol fee owner,"
            ],
            "type": "publicKey"
          },
          {
            "name": "rewardInfos",
            "docs": [
              "Farming reward information"
            ],
            "type": {
              "array": [
                {
                  "defined": "RewardInfo"
                },
                2
              ]
            }
          },
          {
            "name": "oracle",
            "docs": [
              "Oracle pubkey"
            ],
            "type": "publicKey"
          },
          {
            "name": "binArrayBitmap",
            "docs": [
              "Packed initialized bin array state"
            ],
            "type": {
              "array": [
                "u64",
                16
              ]
            }
          },
          {
            "name": "lastUpdatedAt",
            "docs": [
              "Last time the pool fee parameter was updated"
            ],
            "type": "i64"
          },
          {
            "name": "whitelistedWallet",
            "docs": [
              "Whitelisted wallet"
            ],
            "type": {
              "array": [
                "publicKey",
                3
              ]
            }
          },
          {
            "name": "reserved",
            "docs": [
              "Reserved space for future use"
            ],
            "type": {
              "array": [
                "u8",
                88
              ]
            }
          }
        ]
      }
    },
    {
      "name": "oracle",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "idx",
            "docs": [
              "Index of latest observation slot"
            ],
            "type": "u64"
          },
          {
            "name": "activeSize",
            "docs": [
              "Size of active sample. Active sample is initialized observation."
            ],
            "type": "u64"
          },
          {
            "name": "length",
            "docs": [
              "Number of observations"
            ],
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "position",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "lbPair",
            "docs": [
              "The LB pair of this position"
            ],
            "type": "publicKey"
          },
          {
            "name": "owner",
            "docs": [
              "Owner of the position. Client rely on this to to fetch their positions."
            ],
            "type": "publicKey"
          },
          {
            "name": "liquidityShares",
            "docs": [
              "Liquidity shares of this position in bins (lower_bin_id <-> upper_bin_id). This is the same as LP concept."
            ],
            "type": {
              "array": [
                "u64",
                70
              ]
            }
          },
          {
            "name": "rewardInfos",
            "docs": [
              "Farming reward information"
            ],
            "type": {
              "array": [
                {
                  "defined": "UserRewardInfo"
                },
                70
              ]
            }
          },
          {
            "name": "feeInfos",
            "docs": [
              "Swap fee to claim information"
            ],
            "type": {
              "array": [
                {
                  "defined": "FeeInfo"
                },
                70
              ]
            }
          },
          {
            "name": "lowerBinId",
            "docs": [
              "Lower bin ID"
            ],
            "type": "i32"
          },
          {
            "name": "upperBinId",
            "docs": [
              "Upper bin ID"
            ],
            "type": "i32"
          },
          {
            "name": "lastUpdatedAt",
            "docs": [
              "Last updated timestamp"
            ],
            "type": "i64"
          },
          {
            "name": "totalClaimedFeeXAmount",
            "docs": [
              "Total claimed token fee X"
            ],
            "type": "u64"
          },
          {
            "name": "totalClaimedFeeYAmount",
            "docs": [
              "Total claimed token fee Y"
            ],
            "type": "u64"
          },
          {
            "name": "totalClaimedRewards",
            "docs": [
              "Total claimed rewards"
            ],
            "type": {
              "array": [
                "u64",
                2
              ]
            }
          },
          {
            "name": "reserved",
            "docs": [
              "Reserved space for future use"
            ],
            "type": {
              "array": [
                "u8",
                160
              ]
            }
          }
        ]
      }
    },
    {
      "name": "positionV2",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "lbPair",
            "docs": [
              "The LB pair of this position"
            ],
            "type": "publicKey"
          },
          {
            "name": "owner",
            "docs": [
              "Owner of the position. Client rely on this to to fetch their positions."
            ],
            "type": "publicKey"
          },
          {
            "name": "liquidityShares",
            "docs": [
              "Liquidity shares of this position in bins (lower_bin_id <-> upper_bin_id). This is the same as LP concept."
            ],
            "type": {
              "array": [
                "u128",
                70
              ]
            }
          },
          {
            "name": "rewardInfos",
            "docs": [
              "Farming reward information"
            ],
            "type": {
              "array": [
                {
                  "defined": "UserRewardInfo"
                },
                70
              ]
            }
          },
          {
            "name": "feeInfos",
            "docs": [
              "Swap fee to claim information"
            ],
            "type": {
              "array": [
                {
                  "defined": "FeeInfo"
                },
                70
              ]
            }
          },
          {
            "name": "lowerBinId",
            "docs": [
              "Lower bin ID"
            ],
            "type": "i32"
          },
          {
            "name": "upperBinId",
            "docs": [
              "Upper bin ID"
            ],
            "type": "i32"
          },
          {
            "name": "lastUpdatedAt",
            "docs": [
              "Last updated timestamp"
            ],
            "type": "i64"
          },
          {
            "name": "totalClaimedFeeXAmount",
            "docs": [
              "Total claimed token fee X"
            ],
            "type": "u64"
          },
          {
            "name": "totalClaimedFeeYAmount",
            "docs": [
              "Total claimed token fee Y"
            ],
            "type": "u64"
          },
          {
            "name": "totalClaimedRewards",
            "docs": [
              "Total claimed rewards"
            ],
            "type": {
              "array": [
                "u64",
                2
              ]
            }
          },
          {
            "name": "operator",
            "docs": [
              "Operator of position"
            ],
            "type": "publicKey"
          },
          {
            "name": "reserved",
            "docs": [
              "Reserved space for future use"
            ],
            "type": {
              "array": [
                "u8",
                128
              ]
            }
          }
        ]
      }
    },
    {
      "name": "presetParameter",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "binStep",
            "docs": [
              "Bin step. Represent the price increment / decrement."
            ],
            "type": "u16"
          },
          {
            "name": "baseFactor",
            "docs": [
              "Used for base fee calculation. base_fee_rate = base_factor * bin_step"
            ],
            "type": "u16"
          },
          {
            "name": "filterPeriod",
            "docs": [
              "Filter period determine high frequency trading time window."
            ],
            "type": "u16"
          },
          {
            "name": "decayPeriod",
            "docs": [
              "Decay period determine when the volatile fee start decay / decrease."
            ],
            "type": "u16"
          },
          {
            "name": "reductionFactor",
            "docs": [
              "Reduction factor controls the volatile fee rate decrement rate."
            ],
            "type": "u16"
          },
          {
            "name": "variableFeeControl",
            "docs": [
              "Used to scale the variable fee component depending on the dynamic of the market"
            ],
            "type": "u32"
          },
          {
            "name": "maxVolatilityAccumulator",
            "docs": [
              "Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate."
            ],
            "type": "u32"
          },
          {
            "name": "minBinId",
            "docs": [
              "Min bin id supported by the pool based on the configured bin step."
            ],
            "type": "i32"
          },
          {
            "name": "maxBinId",
            "docs": [
              "Max bin id supported by the pool based on the configured bin step."
            ],
            "type": "i32"
          },
          {
            "name": "protocolShare",
            "docs": [
              "Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"
            ],
            "type": "u16"
          }
        ]
      }
    }
  ],
  "types": [
    {
      "name": "LiquidityParameterByStrategyOneSide",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "amount",
            "docs": [
              "Amount of X token or Y token to deposit"
            ],
            "type": "u64"
          },
          {
            "name": "activeId",
            "docs": [
              "Active bin that integrator observe off-chain"
            ],
            "type": "i32"
          },
          {
            "name": "maxActiveBinSlippage",
            "docs": [
              "max active bin slippage allowed"
            ],
            "type": "i32"
          },
          {
            "name": "strategyParameters",
            "docs": [
              "strategy parameters"
            ],
            "type": {
              "defined": "StrategyParameters"
            }
          }
        ]
      }
    },
    {
      "name": "LiquidityParameterByStrategy",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "amountX",
            "docs": [
              "Amount of X token to deposit"
            ],
            "type": "u64"
          },
          {
            "name": "amountY",
            "docs": [
              "Amount of Y token to deposit"
            ],
            "type": "u64"
          },
          {
            "name": "activeId",
            "docs": [
              "Active bin that integrator observe off-chain"
            ],
            "type": "i32"
          },
          {
            "name": "maxActiveBinSlippage",
            "docs": [
              "max active bin slippage allowed"
            ],
            "type": "i32"
          },
          {
            "name": "strategyParameters",
            "docs": [
              "strategy parameters"
            ],
            "type": {
              "defined": "StrategyParameters"
            }
          }
        ]
      }
    },
    {
      "name": "StrategyParameters",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "minBinId",
            "docs": [
              "min bin id"
            ],
            "type": "i32"
          },
          {
            "name": "maxBinId",
            "docs": [
              "max bin id"
            ],
            "type": "i32"
          },
          {
            "name": "strategyType",
            "docs": [
              "strategy type"
            ],
            "type": {
              "defined": "StrategyType"
            }
          },
          {
            "name": "parameteres",
            "docs": [
              "parameters"
            ],
            "type": {
              "array": [
                "u8",
                64
              ]
            }
          }
        ]
      }
    },
    {
      "name": "ParabolicParameter",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "aAsk",
            "docs": [
              "amplification in ask side"
            ],
            "type": "i16"
          },
          {
            "name": "aBid",
            "docs": [
              "amplification in bid side"
            ],
            "type": "i16"
          },
          {
            "name": "aActiveBin",
            "docs": [
              "amplification in active bin"
            ],
            "type": "i16"
          },
          {
            "name": "centerBinId",
            "docs": [
              "center bin id"
            ],
            "type": "i32"
          }
        ]
      }
    },
    {
      "name": "SpotParameter",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "weightAsk",
            "docs": [
              "weight in ask side"
            ],
            "type": "u16"
          },
          {
            "name": "weightBid",
            "docs": [
              "weight in bid side"
            ],
            "type": "u16"
          },
          {
            "name": "weightActiveBin",
            "docs": [
              "weight in active bin"
            ],
            "type": "u16"
          }
        ]
      }
    },
    {
      "name": "BinLiquidityDistributionByWeight",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "binId",
            "docs": [
              "Define the bin ID wish to deposit to."
            ],
            "type": "i32"
          },
          {
            "name": "weight",
            "docs": [
              "weight of liquidity distributed for this bin id"
            ],
            "type": "u16"
          }
        ]
      }
    },
    {
      "name": "LiquidityParameterByWeight",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "amountX",
            "docs": [
              "Amount of X token to deposit"
            ],
            "type": "u64"
          },
          {
            "name": "amountY",
            "docs": [
              "Amount of Y token to deposit"
            ],
            "type": "u64"
          },
          {
            "name": "activeId",
            "docs": [
              "Active bin that integrator observe off-chain"
            ],
            "type": "i32"
          },
          {
            "name": "maxActiveBinSlippage",
            "docs": [
              "max active bin slippage allowed"
            ],
            "type": "i32"
          },
          {
            "name": "binLiquidityDist",
            "docs": [
              "Liquidity distribution to each bins"
            ],
            "type": {
              "vec": {
                "defined": "BinLiquidityDistributionByWeight"
              }
            }
          }
        ]
      }
    },
    {
      "name": "LiquidityOneSideParameter",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "amount",
            "docs": [
              "Amount of X token or Y token to deposit"
            ],
            "type": "u64"
          },
          {
            "name": "activeId",
            "docs": [
              "Active bin that integrator observe off-chain"
            ],
            "type": "i32"
          },
          {
            "name": "maxActiveBinSlippage",
            "docs": [
              "max active bin slippage allowed"
            ],
            "type": "i32"
          },
          {
            "name": "binLiquidityDist",
            "docs": [
              "Liquidity distribution to each bins"
            ],
            "type": {
              "vec": {
                "defined": "BinLiquidityDistributionByWeight"
              }
            }
          }
        ]
      }
    },
    {
      "name": "BinLiquidityDistribution",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "binId",
            "docs": [
              "Define the bin ID wish to deposit to."
            ],
            "type": "i32"
          },
          {
            "name": "distributionX",
            "docs": [
              "DistributionX (or distributionY) is the percentages of amountX (or amountY) you want to add to each bin."
            ],
            "type": "u16"
          },
          {
            "name": "distributionY",
            "docs": [
              "DistributionX (or distributionY) is the percentages of amountX (or amountY) you want to add to each bin."
            ],
            "type": "u16"
          }
        ]
      }
    },
    {
      "name": "LiquidityParameter",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "amountX",
            "docs": [
              "Amount of X token to deposit"
            ],
            "type": "u64"
          },
          {
            "name": "amountY",
            "docs": [
              "Amount of Y token to deposit"
            ],
            "type": "u64"
          },
          {
            "name": "binLiquidityDist",
            "docs": [
              "Liquidity distribution to each bins"
            ],
            "type": {
              "vec": {
                "defined": "BinLiquidityDistribution"
              }
            }
          }
        ]
      }
    },
    {
      "name": "InitPresetParametersIx",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "binStep",
            "docs": [
              "Bin step. Represent the price increment / decrement."
            ],
            "type": "u16"
          },
          {
            "name": "baseFactor",
            "docs": [
              "Used for base fee calculation. base_fee_rate = base_factor * bin_step"
            ],
            "type": "u16"
          },
          {
            "name": "filterPeriod",
            "docs": [
              "Filter period determine high frequency trading time window."
            ],
            "type": "u16"
          },
          {
            "name": "decayPeriod",
            "docs": [
              "Decay period determine when the volatile fee start decay / decrease."
            ],
            "type": "u16"
          },
          {
            "name": "reductionFactor",
            "docs": [
              "Reduction factor controls the volatile fee rate decrement rate."
            ],
            "type": "u16"
          },
          {
            "name": "variableFeeControl",
            "docs": [
              "Used to scale the variable fee component depending on the dynamic of the market"
            ],
            "type": "u32"
          },
          {
            "name": "maxVolatilityAccumulator",
            "docs": [
              "Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate."
            ],
            "type": "u32"
          },
          {
            "name": "minBinId",
            "docs": [
              "Min bin id supported by the pool based on the configured bin step."
            ],
            "type": "i32"
          },
          {
            "name": "maxBinId",
            "docs": [
              "Max bin id supported by the pool based on the configured bin step."
            ],
            "type": "i32"
          },
          {
            "name": "protocolShare",
            "docs": [
              "Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"
            ],
            "type": "u16"
          }
        ]
      }
    },
    {
      "name": "BinLiquidityReduction",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "binId",
            "type": "i32"
          },
          {
            "name": "bpsToRemove",
            "type": "u16"
          }
        ]
      }
    },
    {
      "name": "FeeParameter",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "protocolShare",
            "docs": [
              "Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"
            ],
            "type": "u16"
          },
          {
            "name": "baseFactor",
            "docs": [
              "Base factor for base fee rate"
            ],
            "type": "u16"
          }
        ]
      }
    },
    {
      "name": "Bin",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "amountX",
            "docs": [
              "Amount of token X in the bin. This already excluded protocol fees."
            ],
            "type": "u64"
          },
          {
            "name": "amountY",
            "docs": [
              "Amount of token Y in the bin. This already excluded protocol fees."
            ],
            "type": "u64"
          },
          {
            "name": "price",
            "docs": [
              "Bin price"
            ],
            "type": "u128"
          },
          {
            "name": "liquiditySupply",
            "docs": [
              "Liquidities of the bin. This is the same as LP mint supply. q-number"
            ],
            "type": "u128"
          },
          {
            "name": "rewardPerTokenStored",
            "docs": [
              "reward_a_per_token_stored"
            ],
            "type": {
              "array": [
                "u128",
                2
              ]
            }
          },
          {
            "name": "feeAmountXPerTokenStored",
            "docs": [
              "Swap fee amount of token X per liquidity deposited."
            ],
            "type": "u128"
          },
          {
            "name": "feeAmountYPerTokenStored",
            "docs": [
              "Swap fee amount of token Y per liquidity deposited."
            ],
            "type": "u128"
          },
          {
            "name": "amountXIn",
            "docs": [
              "Total token X swap into the bin. Only used for tracking purpose."
            ],
            "type": "u128"
          },
          {
            "name": "amountYIn",
            "docs": [
              "Total token Y swap into he bin. Only used for tracking purpose."
            ],
            "type": "u128"
          }
        ]
      }
    },
    {
      "name": "ProtocolFee",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "amountX",
            "type": "u64"
          },
          {
            "name": "amountY",
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "RewardInfo",
      "docs": [
        "Stores the state relevant for tracking liquidity mining rewards"
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "mint",
            "docs": [
              "Reward token mint."
            ],
            "type": "publicKey"
          },
          {
            "name": "vault",
            "docs": [
              "Reward vault token account."
            ],
            "type": "publicKey"
          },
          {
            "name": "funder",
            "docs": [
              "Authority account that allows to fund rewards"
            ],
            "type": "publicKey"
          },
          {
            "name": "rewardDuration",
            "docs": [
              "TODO check whether we need to store it in pool"
            ],
            "type": "u64"
          },
          {
            "name": "rewardDurationEnd",
            "docs": [
              "TODO check whether we need to store it in pool"
            ],
            "type": "u64"
          },
          {
            "name": "rewardRate",
            "docs": [
              "TODO check whether we need to store it in pool"
            ],
            "type": "u128"
          },
          {
            "name": "lastUpdateTime",
            "docs": [
              "The last time reward states were updated."
            ],
            "type": "u64"
          },
          {
            "name": "cumulativeSecondsWithEmptyLiquidityReward",
            "docs": [
              "Accumulated seconds where when farm distribute rewards, but the bin is empty. The reward will be accumulated for next reward time window."
            ],
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "Observation",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "cumulativeActiveBinId",
            "docs": [
              "Cumulative active bin ID"
            ],
            "type": "i128"
          },
          {
            "name": "createdAt",
            "docs": [
              "Observation sample created timestamp"
            ],
            "type": "i64"
          },
          {
            "name": "lastUpdatedAt",
            "docs": [
              "Observation sample last updated timestamp"
            ],
            "type": "i64"
          }
        ]
      }
    },
    {
      "name": "StaticParameters",
      "docs": [
        "Parameter that set by the protocol"
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "baseFactor",
            "docs": [
              "Used for base fee calculation. base_fee_rate = base_factor * bin_step"
            ],
            "type": "u16"
          },
          {
            "name": "filterPeriod",
            "docs": [
              "Filter period determine high frequency trading time window."
            ],
            "type": "u16"
          },
          {
            "name": "decayPeriod",
            "docs": [
              "Decay period determine when the volatile fee start decay / decrease."
            ],
            "type": "u16"
          },
          {
            "name": "reductionFactor",
            "docs": [
              "Reduction factor controls the volatile fee rate decrement rate."
            ],
            "type": "u16"
          },
          {
            "name": "variableFeeControl",
            "docs": [
              "Used to scale the variable fee component depending on the dynamic of the market"
            ],
            "type": "u32"
          },
          {
            "name": "maxVolatilityAccumulator",
            "docs": [
              "Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate."
            ],
            "type": "u32"
          },
          {
            "name": "minBinId",
            "docs": [
              "Min bin id supported by the pool based on the configured bin step."
            ],
            "type": "i32"
          },
          {
            "name": "maxBinId",
            "docs": [
              "Max bin id supported by the pool based on the configured bin step."
            ],
            "type": "i32"
          },
          {
            "name": "protocolShare",
            "docs": [
              "Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"
            ],
            "type": "u16"
          },
          {
            "name": "padding",
            "docs": [
              "Padding for bytemuck safe alignment"
            ],
            "type": {
              "array": [
                "u8",
                6
              ]
            }
          }
        ]
      }
    },
    {
      "name": "VariableParameters",
      "docs": [
        "Parameters that changes based on dynamic of the market"
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "volatilityAccumulator",
            "docs": [
              "Volatility accumulator measure the number of bin crossed since reference bin ID. Normally (without filter period taken into consideration), reference bin ID is the active bin of last swap.",
              "It affects the variable fee rate"
            ],
            "type": "u32"
          },
          {
            "name": "volatilityReference",
            "docs": [
              "Volatility reference is decayed volatility accumulator. It is always <= volatility_accumulator"
            ],
            "type": "u32"
          },
          {
            "name": "indexReference",
            "docs": [
              "Active bin id of last swap."
            ],
            "type": "i32"
          },
          {
            "name": "padding",
            "docs": [
              "Padding for bytemuck safe alignment"
            ],
            "type": {
              "array": [
                "u8",
                4
              ]
            }
          },
          {
            "name": "lastUpdateTimestamp",
            "docs": [
              "Last timestamp the variable parameters was updated"
            ],
            "type": "i64"
          },
          {
            "name": "padding1",
            "docs": [
              "Padding for bytemuck safe alignment"
            ],
            "type": {
              "array": [
                "u8",
                8
              ]
            }
          }
        ]
      }
    },
    {
      "name": "FeeInfo",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "feeXPerTokenComplete",
            "type": "u128"
          },
          {
            "name": "feeYPerTokenComplete",
            "type": "u128"
          },
          {
            "name": "feeXPending",
            "type": "u64"
          },
          {
            "name": "feeYPending",
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "UserRewardInfo",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "rewardPerTokenCompletes",
            "type": {
              "array": [
                "u128",
                2
              ]
            }
          },
          {
            "name": "rewardPendings",
            "type": {
              "array": [
                "u64",
                2
              ]
            }
          }
        ]
      }
    },
    {
      "name": "StrategyType",
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Spot"
          },
          {
            "name": "Curve"
          },
          {
            "name": "BidAsk"
          }
        ]
      }
    },
    {
      "name": "Rounding",
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Up"
          },
          {
            "name": "Down"
          }
        ]
      }
    },
    {
      "name": "LayoutVersion",
      "docs": [
        "Layout version"
      ],
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "V0"
          },
          {
            "name": "V1"
          }
        ]
      }
    },
    {
      "name": "PairType",
      "docs": [
        "Type of the Pair. 0 = Permissionless, 1 = Permission. Putting 0 as permissionless for backward compatibility."
      ],
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Permissionless"
          },
          {
            "name": "Permission"
          }
        ]
      }
    },
    {
      "name": "PairStatus",
      "docs": [
        "Pair status. 0 = Enabled, 1 = Disabled. Putting 0 as enabled for backward compatibility."
      ],
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Enabled"
          },
          {
            "name": "Disabled"
          }
        ]
      }
    }
  ],
  "events": [
    {
      "name": "CompositionFee",
      "fields": [
        {
          "name": "from",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "binId",
          "type": "i16",
          "index": false
        },
        {
          "name": "tokenXFeeAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "tokenYFeeAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "protocolTokenXFeeAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "protocolTokenYFeeAmount",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "AddLiquidity",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "from",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "position",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "amounts",
          "type": {
            "array": [
              "u64",
              2
            ]
          },
          "index": false
        },
        {
          "name": "activeBinId",
          "type": "i32",
          "index": false
        }
      ]
    },
    {
      "name": "RemoveLiquidity",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "from",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "position",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "amounts",
          "type": {
            "array": [
              "u64",
              2
            ]
          },
          "index": false
        },
        {
          "name": "activeBinId",
          "type": "i32",
          "index": false
        }
      ]
    },
    {
      "name": "Swap",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "from",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "startBinId",
          "type": "i32",
          "index": false
        },
        {
          "name": "endBinId",
          "type": "i32",
          "index": false
        },
        {
          "name": "amountIn",
          "type": "u64",
          "index": false
        },
        {
          "name": "amountOut",
          "type": "u64",
          "index": false
        },
        {
          "name": "swapForY",
          "type": "bool",
          "index": false
        },
        {
          "name": "fee",
          "type": "u64",
          "index": false
        },
        {
          "name": "protocolFee",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeBps",
          "type": "u128",
          "index": false
        },
        {
          "name": "hostFee",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "ClaimReward",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "position",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "rewardIndex",
          "type": "u64",
          "index": false
        },
        {
          "name": "totalReward",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "FundReward",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "funder",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "rewardIndex",
          "type": "u64",
          "index": false
        },
        {
          "name": "amount",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "InitializeReward",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "rewardMint",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "funder",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "rewardIndex",
          "type": "u64",
          "index": false
        },
        {
          "name": "rewardDuration",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "UpdateRewardDuration",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "rewardIndex",
          "type": "u64",
          "index": false
        },
        {
          "name": "oldRewardDuration",
          "type": "u64",
          "index": false
        },
        {
          "name": "newRewardDuration",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "UpdateRewardFunder",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "rewardIndex",
          "type": "u64",
          "index": false
        },
        {
          "name": "oldFunder",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "newFunder",
          "type": "publicKey",
          "index": false
        }
      ]
    },
    {
      "name": "PositionClose",
      "fields": [
        {
          "name": "position",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        }
      ]
    },
    {
      "name": "ClaimFee",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "position",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "feeX",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeY",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "LbPairCreate",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "binStep",
          "type": "u16",
          "index": false
        },
        {
          "name": "tokenX",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "tokenY",
          "type": "publicKey",
          "index": false
        }
      ]
    },
    {
      "name": "PositionCreate",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "position",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        }
      ]
    },
    {
      "name": "FeeParameterUpdate",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "protocolShare",
          "type": "u16",
          "index": false
        },
        {
          "name": "baseFactor",
          "type": "u16",
          "index": false
        }
      ]
    },
    {
      "name": "IncreaseObservation",
      "fields": [
        {
          "name": "oracle",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "newObservationLength",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "WithdrawIneligibleReward",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "rewardMint",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "amount",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "UpdatePositionOperator",
      "fields": [
        {
          "name": "position",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "oldOperator",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "newOperator",
          "type": "publicKey",
          "index": false
        }
      ]
    }
  ],
  "errors": [
    {
      "code": 6e3,
      "name": "InvalidStartBinIndex",
      "msg": "Invalid start bin index"
    },
    {
      "code": 6001,
      "name": "InvalidBinId",
      "msg": "Invalid bin id"
    },
    {
      "code": 6002,
      "name": "InvalidInput",
      "msg": "Invalid input data"
    },
    {
      "code": 6003,
      "name": "ExceededAmountSlippageTolerance",
      "msg": "Exceeded amount slippage tolerance"
    },
    {
      "code": 6004,
      "name": "ExceededBinSlippageTolerance",
      "msg": "Exceeded bin slippage tolerance"
    },
    {
      "code": 6005,
      "name": "CompositionFactorFlawed",
      "msg": "Composition factor flawed"
    },
    {
      "code": 6006,
      "name": "NonPresetBinStep",
      "msg": "Non preset bin step"
    },
    {
      "code": 6007,
      "name": "ZeroLiquidity",
      "msg": "Zero liquidity"
    },
    {
      "code": 6008,
      "name": "InvalidPosition",
      "msg": "Invalid position"
    },
    {
      "code": 6009,
      "name": "BinArrayNotFound",
      "msg": "Bin array not found"
    },
    {
      "code": 6010,
      "name": "InvalidTokenMint",
      "msg": "Invalid token mint"
    },
    {
      "code": 6011,
      "name": "InvalidAccountForSingleDeposit",
      "msg": "Invalid account for single deposit"
    },
    {
      "code": 6012,
      "name": "PairInsufficientLiquidity",
      "msg": "Pair insufficient liquidity"
    },
    {
      "code": 6013,
      "name": "InvalidFeeOwner",
      "msg": "Invalid fee owner"
    },
    {
      "code": 6014,
      "name": "InvalidFeeWithdrawAmount",
      "msg": "Invalid fee withdraw amount"
    },
    {
      "code": 6015,
      "name": "InvalidAdmin",
      "msg": "Invalid admin"
    },
    {
      "code": 6016,
      "name": "IdenticalFeeOwner",
      "msg": "Identical fee owner"
    },
    {
      "code": 6017,
      "name": "InvalidBps",
      "msg": "Invalid basis point"
    },
    {
      "code": 6018,
      "name": "MathOverflow",
      "msg": "Math operation overflow"
    },
    {
      "code": 6019,
      "name": "TypeCastFailed",
      "msg": "Type cast error"
    },
    {
      "code": 6020,
      "name": "InvalidRewardIndex",
      "msg": "Invalid reward index"
    },
    {
      "code": 6021,
      "name": "InvalidRewardDuration",
      "msg": "Invalid reward duration"
    },
    {
      "code": 6022,
      "name": "RewardInitialized",
      "msg": "Reward already initialized"
    },
    {
      "code": 6023,
      "name": "RewardUninitialized",
      "msg": "Reward not initialized"
    },
    {
      "code": 6024,
      "name": "IdenticalFunder",
      "msg": "Identical funder"
    },
    {
      "code": 6025,
      "name": "RewardCampaignInProgress",
      "msg": "Reward campaign in progress"
    },
    {
      "code": 6026,
      "name": "IdenticalRewardDuration",
      "msg": "Reward duration is the same"
    },
    {
      "code": 6027,
      "name": "InvalidBinArray",
      "msg": "Invalid bin array"
    },
    {
      "code": 6028,
      "name": "NonContinuousBinArrays",
      "msg": "Bin arrays must be continuous"
    },
    {
      "code": 6029,
      "name": "InvalidRewardVault",
      "msg": "Invalid reward vault"
    },
    {
      "code": 6030,
      "name": "NonEmptyPosition",
      "msg": "Position is not empty"
    },
    {
      "code": 6031,
      "name": "UnauthorizedAlphaAccess",
      "msg": "Unauthorized alpha access"
    },
    {
      "code": 6032,
      "name": "InvalidFeeParameter",
      "msg": "Invalid fee parameter"
    },
    {
      "code": 6033,
      "name": "MissingOracle",
      "msg": "Missing oracle account"
    },
    {
      "code": 6034,
      "name": "InsufficientSample",
      "msg": "Insufficient observation sample"
    },
    {
      "code": 6035,
      "name": "InvalidLookupTimestamp",
      "msg": "Invalid lookup timestamp"
    },
    {
      "code": 6036,
      "name": "BitmapExtensionAccountIsNotProvided",
      "msg": "Bitmap extension account is not provided"
    },
    {
      "code": 6037,
      "name": "CannotFindNonZeroLiquidityBinArrayId",
      "msg": "Cannot find non-zero liquidity binArrayId"
    },
    {
      "code": 6038,
      "name": "BinIdOutOfBound",
      "msg": "Bin id out of bound"
    },
    {
      "code": 6039,
      "name": "InsufficientOutAmount",
      "msg": "Insufficient amount in for minimum out"
    },
    {
      "code": 6040,
      "name": "InvalidPositionWidth",
      "msg": "Invalid position width"
    },
    {
      "code": 6041,
      "name": "ExcessiveFeeUpdate",
      "msg": "Excessive fee update"
    },
    {
      "code": 6042,
      "name": "PoolDisabled",
      "msg": "Pool disabled"
    },
    {
      "code": 6043,
      "name": "InvalidPoolType",
      "msg": "Invalid pool type"
    },
    {
      "code": 6044,
      "name": "ExceedMaxWhitelist",
      "msg": "Whitelist for wallet is full"
    },
    {
      "code": 6045,
      "name": "InvalidIndex",
      "msg": "Invalid index"
    },
    {
      "code": 6046,
      "name": "RewardNotEnded",
      "msg": "Reward not ended"
    },
    {
      "code": 6047,
      "name": "MustWithdrawnIneligibleReward",
      "msg": "Must withdraw ineligible reward"
    },
    {
      "code": 6048,
      "name": "UnauthorizedAddress",
      "msg": "Unauthorized address"
    },
    {
      "code": 6049,
      "name": "OperatorsAreTheSame",
      "msg": "Cannot update because operators are the same"
    },
    {
      "code": 6050,
      "name": "WithdrawToWrongTokenAccount",
      "msg": "Withdraw to wrong token account"
    },
    {
      "code": 6051,
      "name": "WrongRentReceiver",
      "msg": "Wrong rent receiver"
    }
  ]
};

// src/clmm/constants.ts
import { PublicKey } from "@solana/web3.js";
import { BN } from "@coral-xyz/anchor";
var LBCLMM_PROGRAM_IDS = {
  devnet: "LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo",
  localhost: "LbVRzDTvBDEcrthxfZ4RL6yiq3uZw8bS6MwtdY6UhFQ",
  "mainnet-beta": "LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo"
};
var ADMIN = {
  devnet: "6WaLrrRfReGKBYUSkmx2K6AuT21ida4j8at2SUiZdXu8",
  localhost: "bossj3JvwiNK7pvjr149DqdtJxf2gdygbcmEPTkb2F1"
};
var Network = /* @__PURE__ */ ((Network2) => {
  Network2["MAINNET"] = "mainnet-beta";
  Network2["TESTNET"] = "testnet";
  Network2["DEVNET"] = "devnet";
  Network2["LOCAL"] = "localhost";
  return Network2;
})(Network || {});
var BASIS_POINT_MAX = 1e4;
var SCALE_OFFSET = 64;
var SCALE = new BN(1).shln(SCALE_OFFSET);
var FEE_PRECISION = new BN(1e9);
var MAX_FEE_RATE = new BN(1e8);
var CONSTANTS = Object.entries(IDL.constants);
var MAX_BIN_ARRAY_SIZE = new BN(CONSTANTS.find(([k, v]) => v.name == "MAX_BIN_PER_ARRAY")[1].value);
var MAX_BIN_PER_POSITION = new BN(CONSTANTS.find(([k, v]) => v.name == "MAX_BIN_PER_POSITION")[1].value);
var SIMULATION_USER = new PublicKey("HrY9qR5TiB2xPzzvbBu5KrBorMfYGQXh9osXydz4jy9s");
var PRECISION = 18446744073709552e3;
var MAX_CLAIM_ALL_ALLOWED = 3;
var MAX_BIN_LENGTH_ALLOWED_IN_ONE_TX = 26;
var MAX_ACTIVE_BIN_SLIPPAGE = 3;

// src/clmm/typings.ts
import { BN as BN2 } from "@coral-xyz/anchor";
import { struct, s16, u16, s32 } from "@solana/buffer-layout";
var CONSTANTS2 = Object.entries(IDL.constants);
var PositionVersion = /* @__PURE__ */ ((PositionVersion2) => {
  PositionVersion2[PositionVersion2["V1"] = 0] = "V1";
  PositionVersion2[PositionVersion2["V2"] = 1] = "V2";
  return PositionVersion2;
})(PositionVersion || {});
var StrategyType = /* @__PURE__ */ ((StrategyType2) => {
  StrategyType2[StrategyType2["Spot"] = 0] = "Spot";
  StrategyType2[StrategyType2["Curve"] = 1] = "Curve";
  StrategyType2[StrategyType2["BidAsk"] = 2] = "BidAsk";
  return StrategyType2;
})(StrategyType || {});
var parabolicParameter = struct([
  s16("aAsk"),
  s16("aBid"),
  s16(`aActiveBin`),
  s32(`centerBinId`)
]);
var spotParameter = struct([
  u16("weightAsk"),
  u16("weightBid"),
  u16("weightActiveBin")
]);
var BIN_ARRAY_BITMAP_SIZE = new BN2(CONSTANTS2.find(([k, v]) => v.name == "BIN_ARRAY_BITMAP_SIZE")[1].value);
var EXTENSION_BINARRAY_BITMAP_SIZE = new BN2(
  CONSTANTS2.find(([k, v]) => v.name == "EXTENSION_BINARRAY_BITMAP_SIZE")[1].value
);
var BitmapType = /* @__PURE__ */ ((BitmapType2) => {
  BitmapType2[BitmapType2["U1024"] = 0] = "U1024";
  BitmapType2[BitmapType2["U512"] = 1] = "U512";
  return BitmapType2;
})(BitmapType || {});

// src/clmm/index.ts
import { AnchorProvider, BN as BN7, Program as Program2 } from "@coral-xyz/anchor";

// src/clmm/helpers/index.ts
import {
  NATIVE_MINT,
  TOKEN_PROGRAM_ID,
  createAssociatedTokenAccountInstruction,
  createCloseAccountInstruction,
  getAccount,
  getAssociatedTokenAddress,
  getAssociatedTokenAddressSync,
  getMint
} from "@solana/spl-token";
import { ComputeBudgetProgram, SystemProgram, TransactionInstruction } from "@solana/web3.js";

// src/clmm/helpers/math.ts
import { BN as BN3 } from "@coral-xyz/anchor";
function mulShr(x, y, offset, rounding) {
  const denominator = new BN3(1).shln(offset);
  return mulDiv(x, y, denominator, rounding);
}
function shlDiv(x, y, offset, rounding) {
  const scale = new BN3(1).shln(offset);
  return mulDiv(x, scale, y, rounding);
}
function mulDiv(x, y, denominator, rounding) {
  const { div, mod } = x.mul(y).divmod(denominator);
  if (rounding == 0 /* Up */ && !mod.isZero()) {
    return div.add(new BN3(1));
  }
  return div;
}

// src/clmm/helpers/derive.ts
import { PublicKey as PublicKey2 } from "@solana/web3.js";
function sortTokenMints(tokenX, tokenY) {
  const [minKey, maxKey] = tokenX.toBuffer().compare(tokenY.toBuffer()) == 1 ? [tokenY, tokenX] : [tokenX, tokenY];
  return [minKey, maxKey];
}
function derivePresetParameter(binStep, programId) {
  return PublicKey2.findProgramAddressSync(
    [
      Buffer.from("preset_parameter"),
      new Uint8Array(binStep.toBuffer("le", 2))
    ],
    programId
  );
}
function deriveLbPair(tokenX, tokenY, binStep, programId) {
  const [minKey, maxKey] = sortTokenMints(tokenX, tokenY);
  return PublicKey2.findProgramAddressSync(
    [minKey.toBuffer(), maxKey.toBuffer(), new Uint8Array(binStep.toBuffer("le", 2))],
    programId
  );
}
function deriveOracle(lbPair, programId) {
  return PublicKey2.findProgramAddressSync([Buffer.from("oracle"), lbPair.toBytes()], programId);
}
function derivePosition(mint, programId) {
  return PublicKey2.findProgramAddressSync([Buffer.from("position"), mint.toBuffer()], programId);
}
function deriveBinArray(lbPair, index, programId) {
  let binArrayBytes;
  if (index.isNeg()) {
    binArrayBytes = new Uint8Array(index.toTwos(64).toBuffer("le", 8));
  } else {
    binArrayBytes = new Uint8Array(index.toBuffer("le", 8));
  }
  return PublicKey2.findProgramAddressSync([Buffer.from("bin_array"), lbPair.toBytes(), binArrayBytes], programId);
}
function deriveReserve(token, lbPair, programId) {
  return PublicKey2.findProgramAddressSync([lbPair.toBuffer(), token.toBuffer()], programId);
}

// src/clmm/helpers/binArray.ts
import { BN as BN4 } from "@coral-xyz/anchor";
import { PublicKey as PublicKey3 } from "@solana/web3.js";
function internalBitmapRange() {
  const lowerBinArrayIndex = BIN_ARRAY_BITMAP_SIZE.neg();
  const upperBinArrayIndex = BIN_ARRAY_BITMAP_SIZE.sub(new BN4(1));
  return [lowerBinArrayIndex, upperBinArrayIndex];
}
function buildBitmapFromU64Arrays(u64Arrays, type) {
  const buffer = Buffer.concat(
    u64Arrays.map((b) => {
      return b.toBuffer("le", 8);
    })
  );
  return new BN4(buffer, "le");
}
function bitmapTypeDetail(type) {
  if (type == 0 /* U1024 */) {
    return {
      bits: 1024,
      bytes: 1024 / 8
    };
  } else {
    return {
      bits: 512,
      bytes: 512 / 8
    };
  }
}
function mostSignificantBit(number, bitLength) {
  const highestIndex = bitLength - 1;
  if (number.isZero()) {
    return null;
  }
  for (let i = highestIndex; i >= 0; i--) {
    if (number.testn(i)) {
      return highestIndex - i;
    }
  }
  return null;
}
function leastSignificantBit(number, bitLength) {
  if (number.isZero()) {
    return null;
  }
  for (let i = 0; i < bitLength; i++) {
    if (number.testn(i)) {
      return i;
    }
  }
  return null;
}
function extensionBitmapRange() {
  return [
    BIN_ARRAY_BITMAP_SIZE.neg().mul(EXTENSION_BINARRAY_BITMAP_SIZE.add(new BN4(1))),
    BIN_ARRAY_BITMAP_SIZE.mul(EXTENSION_BINARRAY_BITMAP_SIZE.add(new BN4(1))).sub(new BN4(1))
  ];
}
function findSetBit(startIndex, endIndex, binArrayBitmapExtension) {
  const getBinArrayOffset = (binArrayIndex) => {
    return binArrayIndex > 0 ? binArrayIndex % BIN_ARRAY_BITMAP_SIZE.toNumber() - 1 : Math.abs(binArrayIndex - 1) % BIN_ARRAY_BITMAP_SIZE.toNumber();
  };
  const getBitmapOffset = (binArrayIndex) => {
    return binArrayIndex > 0 ? binArrayIndex / BIN_ARRAY_BITMAP_SIZE.toNumber() - 1 : -(binArrayIndex + 1) / BIN_ARRAY_BITMAP_SIZE.toNumber() - 1;
  };
  if (startIndex <= endIndex) {
    for (let i = startIndex; i <= endIndex; i++) {
      const binArrayOffset = getBinArrayOffset(i);
      const bitmapOffset = getBitmapOffset(i);
      const bitmapChunks = i > 0 ? binArrayBitmapExtension.positiveBinArrayBitmap[bitmapOffset] : binArrayBitmapExtension.negativeBinArrayBitmap[bitmapOffset];
      const bitmap = buildBitmapFromU64Arrays(bitmapChunks, 1 /* U512 */);
      if (bitmap.testn(binArrayOffset)) {
        return i;
      }
    }
  } else {
    for (let i = startIndex; i >= endIndex; i--) {
      const binArrayOffset = getBinArrayOffset(i);
      const bitmapOffset = getBitmapOffset(i);
      const bitmapChunks = i > 0 ? binArrayBitmapExtension.positiveBinArrayBitmap[bitmapOffset] : binArrayBitmapExtension.negativeBinArrayBitmap[bitmapOffset];
      const bitmap = buildBitmapFromU64Arrays(bitmapChunks, 1 /* U512 */);
      if (bitmap.testn(binArrayOffset)) {
        return i;
      }
    }
  }
  return null;
}
function isOverflowDefaultBinArrayBitmap(binArrayIndex) {
  const [minBinArrayIndex, maxBinArrayIndex] = internalBitmapRange();
  return binArrayIndex.gt(maxBinArrayIndex) || binArrayIndex.lt(minBinArrayIndex);
}
function deriveBinArrayBitmapExtension(lbPair, programId) {
  return PublicKey3.findProgramAddressSync([Buffer.from("bitmap"), lbPair.toBytes()], programId);
}
function binIdToBinArrayIndex(binId) {
  const { div: idx, mod } = binId.divmod(MAX_BIN_ARRAY_SIZE);
  return binId.isNeg() && !mod.isZero() ? idx.sub(new BN4(1)) : idx;
}
function getBinArrayLowerUpperBinId(binArrayIndex) {
  const lowerBinId = binArrayIndex.mul(MAX_BIN_ARRAY_SIZE);
  const upperBinId = lowerBinId.add(MAX_BIN_ARRAY_SIZE).sub(new BN4(1));
  return [lowerBinId, upperBinId];
}
function isBinIdWithinBinArray(activeId, binArrayIndex) {
  const [lowerBinId, upperBinId] = getBinArrayLowerUpperBinId(binArrayIndex);
  return activeId.gte(lowerBinId) && activeId.lte(upperBinId);
}
function getBinFromBinArray(binId, binArray) {
  const [lowerBinId, upperBinId] = getBinArrayLowerUpperBinId(binArray.index);
  let index = 0;
  if (binId > 0) {
    index = binId - lowerBinId.toNumber();
  } else {
    const delta = upperBinId.toNumber() - binId;
    index = MAX_BIN_ARRAY_SIZE.toNumber() - delta - 1;
  }
  return binArray.bins[index];
}
function findNextBinArrayIndexWithLiquidity(swapForY, activeId, lbPairState, binArrayBitmapExtension) {
  const [lowerBinArrayIndex, upperBinArrayIndex] = internalBitmapRange();
  let startBinArrayIndex = binIdToBinArrayIndex(activeId);
  while (true) {
    if (isOverflowDefaultBinArrayBitmap(startBinArrayIndex)) {
      if (binArrayBitmapExtension == null) {
        return null;
      }
      const [minBinArrayIndex, maxBinArrayIndex] = extensionBitmapRange();
      if (startBinArrayIndex.isNeg()) {
        if (swapForY) {
          const binArrayIndex = findSetBit(
            startBinArrayIndex.toNumber(),
            minBinArrayIndex.toNumber(),
            binArrayBitmapExtension
          );
          if (binArrayIndex != null) {
            return new BN4(binArrayIndex);
          } else {
            return null;
          }
        } else {
          const binArrayIndex = findSetBit(
            startBinArrayIndex.toNumber(),
            BIN_ARRAY_BITMAP_SIZE.neg().sub(new BN4(1)).toNumber(),
            binArrayBitmapExtension
          );
          if (binArrayIndex != null) {
            return new BN4(binArrayIndex);
          } else {
            startBinArrayIndex = BIN_ARRAY_BITMAP_SIZE.neg();
          }
        }
      } else {
        if (swapForY) {
          const binArrayIndex = findSetBit(
            startBinArrayIndex.toNumber(),
            BIN_ARRAY_BITMAP_SIZE.toNumber(),
            binArrayBitmapExtension
          );
          if (binArrayIndex != null) {
            return new BN4(binArrayIndex);
          } else {
            startBinArrayIndex = BIN_ARRAY_BITMAP_SIZE;
          }
        } else {
          const binArrayIndex = findSetBit(
            startBinArrayIndex.toNumber(),
            maxBinArrayIndex.toNumber(),
            binArrayBitmapExtension
          );
          if (binArrayIndex != null) {
            return new BN4(binArrayIndex);
          } else {
            return null;
          }
        }
      }
    } else {
      const bitmapType = 0 /* U1024 */;
      const bitmapDetail = bitmapTypeDetail(bitmapType);
      const offset = startBinArrayIndex.add(BIN_ARRAY_BITMAP_SIZE);
      const bitmap = buildBitmapFromU64Arrays(lbPairState.binArrayBitmap, bitmapType);
      if (swapForY) {
        const upperBitRange = new BN4(bitmapDetail.bits - 1).sub(offset);
        const croppedBitmap = bitmap.shln(upperBitRange.toNumber());
        const msb = mostSignificantBit(croppedBitmap, bitmapDetail.bits);
        if (msb != null) {
          return startBinArrayIndex.sub(new BN4(msb));
        } else {
          startBinArrayIndex = lowerBinArrayIndex.sub(new BN4(1));
        }
      } else {
        const lowerBitRange = offset;
        const croppedBitmap = bitmap.shrn(lowerBitRange.toNumber());
        const lsb = leastSignificantBit(croppedBitmap, bitmapDetail.bits);
        if (lsb != null) {
          return startBinArrayIndex.add(new BN4(lsb));
        } else {
          startBinArrayIndex = upperBinArrayIndex.add(new BN4(1));
        }
      }
    }
  }
}
function findNextBinArrayWithLiquidity(swapForY, activeBinId, lbPairState, binArrayBitmapExtension, binArrays) {
  const nearestBinArrayIndexWithLiquidity = findNextBinArrayIndexWithLiquidity(
    swapForY,
    activeBinId,
    lbPairState,
    binArrayBitmapExtension
  );
  if (nearestBinArrayIndexWithLiquidity == null) {
    return null;
  }
  const binArrayAccount = binArrays.find((ba) => ba.account.index.eq(nearestBinArrayIndexWithLiquidity));
  if (!binArrayAccount) {
    throw new Error("Bin array not found based on indexing");
  }
  return binArrayAccount;
}

// src/clmm/helpers/strategy.ts
import { BN as BN5 } from "@coral-xyz/anchor";
import gaussian from "gaussian";
import Decimal from "decimal.js";
function getPriceOfBinByBinId(binId, binStep) {
  const binStepNum = new Decimal(binStep).div(new Decimal(BASIS_POINT_MAX));
  return new Decimal(1).add(new Decimal(binStepNum)).pow(new Decimal(binId));
}
function buildGaussianFromBins(activeBin, binIds) {
  const smallestBin = Math.min(...binIds);
  const largestBin = Math.max(...binIds);
  let mean = 0;
  const isAroundActiveBin = binIds.find((bid) => bid == activeBin);
  if (isAroundActiveBin) {
    mean = activeBin;
  } else if (activeBin < smallestBin) {
    mean = smallestBin;
  } else {
    mean = largestBin;
  }
  const TWO_STANDARD_DEVIATION = 4;
  const stdDev = (largestBin - smallestBin) / TWO_STANDARD_DEVIATION;
  const variance = Math.max(stdDev ** 2, 1);
  return gaussian(mean, variance);
}
function generateBinLiquidityAllocation(gaussian2, binIds, invert) {
  const allocations = binIds.map((bid) => invert ? 1 / gaussian2.pdf(bid) : gaussian2.pdf(bid));
  const totalAllocations = allocations.reduce((acc, v) => acc + v, 0);
  return allocations.map((a) => a / totalAllocations);
}
function computeAllocationBps(allocations) {
  let totalAllocation = new BN5(0);
  const bpsAllocations = [];
  for (const allocation of allocations) {
    const allocBps = new BN5(allocation * 1e4);
    bpsAllocations.push(allocBps);
    totalAllocation = totalAllocation.add(allocBps);
  }
  const pLoss = new BN5(1e4).sub(totalAllocation);
  return {
    bpsAllocations,
    pLoss
  };
}
function toWeightDistribution(amountX, amountY, distributions, binStep) {
  let totalQuote = new BN5(0);
  const precision = 1e12;
  const quoteDistributions = distributions.map((bin) => {
    const price = new BN5(getPriceOfBinByBinId(bin.binId, binStep).mul(precision).floor().toString());
    const quoteValue = amountX.mul(new BN5(bin.xAmountBpsOfTotal)).mul(new BN5(price)).div(new BN5(BASIS_POINT_MAX)).div(new BN5(precision));
    const quoteAmount = quoteValue.add(amountY.mul(new BN5(bin.yAmountBpsOfTotal)).div(new BN5(BASIS_POINT_MAX)));
    totalQuote = totalQuote.add(quoteAmount);
    return {
      binId: bin.binId,
      quoteAmount
    };
  });
  if (totalQuote.eq(new BN5(0))) {
    return [];
  }
  const distributionWeights = quoteDistributions.map((bin) => {
    const weight = Math.floor(bin.quoteAmount.mul(new BN5(65535)).div(totalQuote).toNumber());
    return {
      binId: bin.binId,
      weight
    };
  }).filter((item) => item.weight > 0);
  return distributionWeights;
}
function fromWeightDistributionToAmount(amountX, amountY, distributions, binStep, activeId, amountXInActiveBin, amountYInActiveBin) {
  var distributions = distributions.sort((n1, n2) => {
    return n1.binId - n2.binId;
  }).filter((item) => item.weight > 0);
  if (distributions.length == 0) {
    return [];
  }
  if (activeId > distributions[distributions.length - 1].binId) {
    let totalWeight = distributions.reduce(function(sum, el) {
      return sum + el.weight;
    }, 0);
    return distributions.map((bin) => {
      const amount = amountX.mul(new BN5(bin.weight)).div(new BN5(totalWeight));
      return {
        binId: bin.binId,
        amountX: new BN5(0),
        amountY: amount
      };
    });
  }
  if (activeId < distributions[0].binId) {
    let totalWeight = distributions.reduce(function(sum, el) {
      let price = getPriceOfBinByBinId(el.binId, binStep);
      let weighPerPrice = new Decimal(el.weight).div(price);
      return sum.add(weighPerPrice);
    }, new Decimal(0));
    return distributions.map((bin) => {
      const amount = new Decimal(amountX.toNumber()).mul(new Decimal(bin.weight)).div(totalWeight);
      return {
        binId: bin.binId,
        amountX: new BN5(Math.floor(amount.toNumber())),
        amountY: new BN5(0)
      };
    });
  }
  const activeBins = distributions.filter((element) => {
    return element.binId === activeId;
  });
  if (activeBins.length == 1) {
    let p0 = getPriceOfBinByBinId(activeId, binStep);
    let wx0 = new Decimal(0);
    let wy0 = new Decimal(0);
    let activeBin = activeBins[0];
    if (amountXInActiveBin.isZero() && amountYInActiveBin.isZero()) {
      wx0 = new Decimal(activeBin.weight).div(p0.mul(new Decimal(2)));
      wy0 = new Decimal(activeBin.weight).div(new Decimal(2));
    } else {
      let amountXInActiveBinDec = new Decimal(amountYInActiveBin.toNumber());
      let amountYInActiveBinDec = new Decimal(amountYInActiveBin.toNumber());
      if (!amountXInActiveBin.isZero()) {
        wx0 = new Decimal(activeBin.weight).div(p0.add(amountXInActiveBinDec.div(amountYInActiveBinDec)));
      }
      if (!amountYInActiveBin.isZero()) {
        wy0 = new Decimal(activeBin.weight).div(new Decimal(1).add(p0.mul(amountXInActiveBinDec).div(amountYInActiveBinDec)));
      }
    }
    let totalWeightX = wx0;
    let totalWeightY = wy0;
    distributions.forEach((element) => {
      if (element.binId < activeId) {
        totalWeightY = totalWeightY.add(new Decimal(element.weight));
      }
      if (element.binId > activeId) {
        let price = getPriceOfBinByBinId(element.binId, binStep);
        let weighPerPrice = new Decimal(element.weight).div(price);
        totalWeightX = totalWeightX.add(weighPerPrice);
      }
    });
    let kx = new Decimal(amountX.toNumber()).div(totalWeightX);
    let ky = new Decimal(amountY.toNumber()).div(totalWeightY);
    let k = kx.lessThan(ky) ? kx : ky;
    return distributions.map((bin) => {
      if (bin.binId < activeId) {
        const amount = k.mul(new Decimal(bin.weight));
        return {
          binId: bin.binId,
          amountX: new BN5(0),
          amountY: new BN5(Math.floor(amount.toNumber()))
        };
      }
      if (bin.binId > activeId) {
        let price = getPriceOfBinByBinId(bin.binId, binStep);
        let weighPerPrice = new Decimal(bin.weight).div(price);
        const amount = k.mul(weighPerPrice);
        return {
          binId: bin.binId,
          amountX: new BN5(Math.floor(amount.toNumber())),
          amountY: new BN5(0)
        };
      }
      let amounXActiveBin = k.mul(wx0);
      let amounYActiveBin = k.mul(wy0);
      return {
        binId: bin.binId,
        amountX: new BN5(Math.floor(amounXActiveBin.toNumber())),
        amountY: new BN5(Math.floor(amounYActiveBin.toNumber()))
      };
    });
  } else {
    let totalWeightX = new Decimal(0);
    let totalWeightY = new Decimal(0);
    distributions.forEach((element) => {
      if (element.binId < activeId) {
        totalWeightY = totalWeightY.add(new Decimal(element.weight));
      } else {
        let price = getPriceOfBinByBinId(element.binId, binStep);
        let weighPerPrice = new Decimal(element.weight).div(price);
        totalWeightX = totalWeightX.add(weighPerPrice);
      }
    });
    let kx = new Decimal(amountX.toNumber()).div(totalWeightX);
    let ky = new Decimal(amountY.toNumber()).div(totalWeightY);
    let k = kx.lessThan(ky) ? kx : ky;
    return distributions.map((bin) => {
      if (bin.binId < activeId) {
        const amount = k.mul(new Decimal(bin.weight));
        return {
          binId: bin.binId,
          amountX: new BN5(0),
          amountY: new BN5(Math.floor(amount.toNumber()))
        };
      } else {
        let price = getPriceOfBinByBinId(bin.binId, binStep);
        let weighPerPrice = new Decimal(bin.weight).div(price);
        const amount = k.mul(weighPerPrice);
        return {
          binId: bin.binId,
          amountX: new BN5(Math.floor(amount.toNumber())),
          amountY: new BN5(0)
        };
      }
    });
  }
  return [];
}
function calculateSpotDistribution(activeBin, binIds) {
  if (!binIds.includes(activeBin)) {
    const { div: dist, mod: rem } = new BN5(1e4).divmod(new BN5(binIds.length));
    const loss = rem.isZero() ? new BN5(0) : new BN5(1);
    const distributions = binIds[0] < activeBin ? binIds.map((binId) => ({
      binId,
      xAmountBpsOfTotal: new BN5(0),
      yAmountBpsOfTotal: dist
    })) : binIds.map((binId) => ({
      binId,
      xAmountBpsOfTotal: dist,
      yAmountBpsOfTotal: new BN5(0)
    }));
    if (binIds[0] < activeBin) {
      distributions[0].yAmountBpsOfTotal.add(loss);
    } else {
      distributions[binIds.length - 1].xAmountBpsOfTotal.add(loss);
    }
    return distributions;
  }
  const binYCount = binIds.filter((binId) => binId < activeBin).length;
  const binXCount = binIds.filter((binId) => binId > activeBin).length;
  const totalYBinCapacity = binYCount + 0.5;
  const totalXBinCapacity = binXCount + 0.5;
  const yBinBps = new BN5(1e4 / totalYBinCapacity);
  const yActiveBinBps = new BN5(1e4).sub(yBinBps.mul(new BN5(binYCount)));
  const xBinBps = new BN5(1e4 / totalXBinCapacity);
  const xActiveBinBps = new BN5(1e4).sub(xBinBps.mul(new BN5(binXCount)));
  return binIds.map((binId) => {
    const isYBin = binId < activeBin;
    const isXBin = binId > activeBin;
    const isActiveBin = binId === activeBin;
    if (isYBin) {
      return {
        binId,
        xAmountBpsOfTotal: new BN5(0),
        yAmountBpsOfTotal: yBinBps
      };
    }
    if (isXBin) {
      return {
        binId,
        xAmountBpsOfTotal: xBinBps,
        yAmountBpsOfTotal: new BN5(0)
      };
    }
    if (isActiveBin) {
      return {
        binId,
        xAmountBpsOfTotal: xActiveBinBps,
        yAmountBpsOfTotal: yActiveBinBps
      };
    }
  });
}
function calculateBidAskDistribution(activeBin, binIds) {
  const smallestBin = Math.min(...binIds);
  const largestBin = Math.max(...binIds);
  const rightOnly = activeBin < smallestBin;
  const leftOnly = activeBin > largestBin;
  const gaussian2 = buildGaussianFromBins(activeBin, binIds);
  const allocations = generateBinLiquidityAllocation(gaussian2, binIds, true);
  if (rightOnly) {
    const { bpsAllocations, pLoss } = computeAllocationBps(allocations);
    const binDistributions = binIds.map((bid, idx2) => ({
      binId: bid,
      xAmountBpsOfTotal: bpsAllocations[idx2],
      yAmountBpsOfTotal: new BN5(0)
    }));
    const idx = binDistributions.length - 1;
    binDistributions[idx].xAmountBpsOfTotal = binDistributions[idx].xAmountBpsOfTotal.add(pLoss);
    return binDistributions;
  }
  if (leftOnly) {
    const { bpsAllocations, pLoss } = computeAllocationBps(allocations);
    const binDistributions = binIds.map((bid, idx) => ({
      binId: bid,
      xAmountBpsOfTotal: new BN5(0),
      yAmountBpsOfTotal: bpsAllocations[idx]
    }));
    binDistributions[0].yAmountBpsOfTotal = binDistributions[0].yAmountBpsOfTotal.add(pLoss);
    return binDistributions;
  }
  const [totalXAllocation, totalYAllocation] = allocations.reduce(
    ([xAcc, yAcc], allocation, idx) => {
      const binId = binIds[idx];
      if (binId > activeBin) {
        return [xAcc + allocation, yAcc];
      } else if (binId < activeBin) {
        return [xAcc, yAcc + allocation];
      } else {
        const half = allocation / 2;
        return [xAcc + half, yAcc + half];
      }
    },
    [0, 0]
  );
  const [normXAllocations, normYAllocations] = allocations.reduce(
    ([xAllocations, yAllocations], allocation, idx) => {
      const binId = binIds[idx];
      if (binId > activeBin) {
        const distX = new BN5(allocation * 1e4 / totalXAllocation);
        xAllocations.push(distX);
      }
      if (binId < activeBin) {
        const distY = new BN5(allocation * 1e4 / totalYAllocation);
        yAllocations.push(distY);
      }
      if (binId == activeBin) {
        const half = allocation / 2;
        const distX = new BN5(half * 1e4 / totalXAllocation);
        const distY = new BN5(half * 1e4 / totalYAllocation);
        xAllocations.push(distX);
        yAllocations.push(distY);
      }
      return [xAllocations, yAllocations];
    },
    [[], []]
  );
  const totalXNormAllocations = normXAllocations.reduce((acc, v) => acc.add(v), new BN5(0));
  const totalYNormAllocations = normYAllocations.reduce((acc, v) => acc.add(v), new BN5(0));
  const xPLoss = new BN5(1e4).sub(totalXNormAllocations);
  const yPLoss = new BN5(1e4).sub(totalYNormAllocations);
  const distributions = binIds.map((binId) => {
    if (binId === activeBin) {
      return {
        binId,
        xAmountBpsOfTotal: normXAllocations.shift(),
        yAmountBpsOfTotal: normYAllocations.shift()
      };
    }
    if (binId > activeBin) {
      return {
        binId,
        xAmountBpsOfTotal: normXAllocations.shift(),
        yAmountBpsOfTotal: new BN5(0)
      };
    }
    if (binId < activeBin) {
      return {
        binId,
        xAmountBpsOfTotal: new BN5(0),
        yAmountBpsOfTotal: normYAllocations.shift()
      };
    }
  });
  if (!yPLoss.isZero()) {
    distributions[0].yAmountBpsOfTotal = distributions[0].yAmountBpsOfTotal.add(yPLoss);
  }
  if (!xPLoss.isZero()) {
    const last = distributions.length - 1;
    distributions[last].xAmountBpsOfTotal = distributions[last].xAmountBpsOfTotal.add(xPLoss);
  }
  return distributions;
}
function calculateNormalDistribution(activeBin, binIds) {
  const smallestBin = Math.min(...binIds);
  const largestBin = Math.max(...binIds);
  const rightOnly = activeBin < smallestBin;
  const leftOnly = activeBin > largestBin;
  const gaussian2 = buildGaussianFromBins(activeBin, binIds);
  const allocations = generateBinLiquidityAllocation(gaussian2, binIds, false);
  if (rightOnly) {
    const { bpsAllocations, pLoss } = computeAllocationBps(allocations);
    const binDistributions = binIds.map((bid, idx) => ({
      binId: bid,
      xAmountBpsOfTotal: bpsAllocations[idx],
      yAmountBpsOfTotal: new BN5(0)
    }));
    binDistributions[0].xAmountBpsOfTotal = binDistributions[0].xAmountBpsOfTotal.add(pLoss);
    return binDistributions;
  }
  if (leftOnly) {
    const { bpsAllocations, pLoss } = computeAllocationBps(allocations);
    const binDistributions = binIds.map((bid, idx2) => ({
      binId: bid,
      xAmountBpsOfTotal: new BN5(0),
      yAmountBpsOfTotal: bpsAllocations[idx2]
    }));
    const idx = binDistributions.length - 1;
    binDistributions[idx].yAmountBpsOfTotal = binDistributions[idx].yAmountBpsOfTotal.add(pLoss);
    return binDistributions;
  }
  const [totalXAllocation, totalYAllocation] = allocations.reduce(
    ([xAcc, yAcc], allocation, idx) => {
      const binId = binIds[idx];
      if (binId > activeBin) {
        return [xAcc + allocation, yAcc];
      } else if (binId < activeBin) {
        return [xAcc, yAcc + allocation];
      } else {
        const half = allocation / 2;
        return [xAcc + half, yAcc + half];
      }
    },
    [0, 0]
  );
  const [normXAllocations, normYAllocations] = allocations.reduce(
    ([xAllocations, yAllocations], allocation, idx) => {
      const binId = binIds[idx];
      if (binId > activeBin) {
        const distX = new BN5(allocation * 1e4 / totalXAllocation);
        xAllocations.push(distX);
      }
      if (binId < activeBin) {
        const distY = new BN5(allocation * 1e4 / totalYAllocation);
        yAllocations.push(distY);
      }
      return [xAllocations, yAllocations];
    },
    [[], []]
  );
  const normXActiveBinAllocation = normXAllocations.reduce((maxBps, bps) => maxBps.sub(bps), new BN5(1e4));
  const normYActiveBinAllocation = normYAllocations.reduce((maxBps, bps) => maxBps.sub(bps), new BN5(1e4));
  return binIds.map((binId) => {
    if (binId === activeBin) {
      return {
        binId,
        xAmountBpsOfTotal: normXActiveBinAllocation,
        yAmountBpsOfTotal: normYActiveBinAllocation
      };
    }
    if (binId > activeBin) {
      return {
        binId,
        xAmountBpsOfTotal: normXAllocations.shift(),
        yAmountBpsOfTotal: new BN5(0)
      };
    }
    if (binId < activeBin) {
      return {
        binId,
        xAmountBpsOfTotal: new BN5(0),
        yAmountBpsOfTotal: normYAllocations.shift()
      };
    }
  });
}
function fromStrategyParamstoWeightDistribution(activeId, strategyParameters) {
  const { maxBinId, minBinId, strategyType, aAsk, aBid, aActiveBin, centerBinId, weightAsk, weightBid, weightActiveBin } = strategyParameters;
  if (maxBinId < minBinId) {
    throw new Error("maxBinId cannot be smaller than minBinId");
  }
  let distributionWeights = [];
  switch (strategyType) {
    case 0 /* Spot */: {
      for (let i = minBinId; i <= maxBinId; i++) {
        if (i < activeId) {
          distributionWeights.push({
            binId: i,
            weight: weightBid
          });
        }
        if (i > activeId) {
          distributionWeights.push({
            binId: i,
            weight: weightAsk
          });
        }
        if (i == activeId) {
          distributionWeights.push({
            binId: i,
            weight: weightActiveBin
          });
        }
      }
      break;
    }
    case 1 /* Curve */: {
      if (aAsk > 0 || aAsk < -32768) {
        throw new Error("aAsk is out of range");
      }
      if (aBid > 0 || aBid < -32768) {
        throw new Error("aBid is out of range");
      }
      const midBinId = centerBinId;
      const binWidth = maxBinId - minBinId;
      const b = binWidth * binWidth;
      for (let i = minBinId; i <= maxBinId; i++) {
        let binDelta = i - midBinId;
        let a = aActiveBin;
        if (i < activeId) {
          a = aBid;
        } else if (i > activeId) {
          a = aAsk;
        }
        distributionWeights.push({
          binId: i,
          weight: Math.max(Math.floor(a * binDelta * binDelta - a * b) / 15e3, 0)
        });
      }
      break;
    }
    case 2 /* BidAsk */: {
      if (aAsk < 0 || aAsk > 32768) {
        throw new Error("aAsk is out of range");
      }
      if (aBid < 0 || aBid > 32768) {
        throw new Error("aBid is out of range");
      }
      const midBinId = centerBinId;
      for (let i = minBinId; i <= maxBinId; i++) {
        let binDelta = i - midBinId;
        let a = aActiveBin;
        if (i < activeId) {
          a = aBid;
        } else if (i > activeId) {
          a = aAsk;
        }
        distributionWeights.push({
          binId: i,
          weight: Math.max(Math.floor(a * binDelta * binDelta) / 15e3, 0)
        });
      }
      break;
    }
  }
  return distributionWeights;
}
function toStrategyParameters(strategyParameters) {
  const { maxBinId, minBinId, strategyType, aAsk, aBid, aActiveBin, centerBinId, weightAsk, weightBid, weightActiveBin } = strategyParameters;
  switch (strategyType) {
    case 0 /* Spot */: {
      const data2 = Buffer.alloc(spotParameter.span);
      spotParameter.encode(
        {
          weightAsk,
          weightBid,
          weightActiveBin
        },
        data2
      );
      let parameters2 = Buffer.concat([data2, Buffer.from(new Array(58).fill(0))]);
      return {
        minBinId,
        maxBinId,
        strategyType: { spot: {} },
        parameteres: parameters2.toJSON().data
      };
    }
    case 1 /* Curve */: {
      const data2 = Buffer.alloc(parabolicParameter.span);
      parabolicParameter.encode(
        {
          aAsk,
          aBid,
          aActiveBin,
          centerBinId
        },
        data2
      );
      let parameters2 = Buffer.concat([data2, Buffer.from(new Array(54).fill(0))]);
      return {
        minBinId,
        maxBinId,
        strategyType: { curve: {} },
        parameteres: parameters2.toJSON().data
      };
    }
    case 2 /* BidAsk */:
      const data = Buffer.alloc(parabolicParameter.span);
      parabolicParameter.encode(
        {
          aAsk,
          aBid,
          aActiveBin,
          centerBinId
        },
        data
      );
      let parameters = Buffer.concat([data, Buffer.from(new Array(54).fill(0))]);
      return {
        minBinId,
        maxBinId,
        strategyType: { bidAsk: {} },
        parameteres: parameters.toJSON().data
      };
  }
}

// src/clmm/helpers/fee.ts
import { BN as BN6 } from "@coral-xyz/anchor";
function getBaseFee(binStep, sParameter) {
  return new BN6(sParameter.baseFactor).mul(new BN6(binStep)).mul(new BN6(10));
}
function getVariableFee(binStep, sParameter, vParameter) {
  if (sParameter.variableFeeControl > 0) {
    const square_vfa_bin = new BN6(vParameter.volatilityAccumulator).mul(new BN6(binStep)).pow(new BN6(2));
    const v_fee = new BN6(sParameter.variableFeeControl).mul(square_vfa_bin);
    return v_fee.add(new BN6(99999999999)).div(new BN6(1e11));
  }
  return new BN6(0);
}
function getTotalFee(binStep, sParameter, vParameter) {
  const totalFee = getBaseFee(binStep, sParameter).add(getVariableFee(binStep, sParameter, vParameter));
  return totalFee.gt(MAX_FEE_RATE) ? MAX_FEE_RATE : totalFee;
}
function computeFee(binStep, sParameter, vParameter, inAmount) {
  const totalFee = getTotalFee(binStep, sParameter, vParameter);
  const denominator = FEE_PRECISION.sub(totalFee);
  return inAmount.mul(totalFee).add(denominator).sub(new BN6(1)).div(denominator);
}
function computeFeeFromAmount(binStep, sParameter, vParameter, inAmountWithFees) {
  const totalFee = getTotalFee(binStep, sParameter, vParameter);
  return inAmountWithFees.mul(totalFee).add(FEE_PRECISION.sub(new BN6(1))).div(FEE_PRECISION);
}
function computeProtocolFee(feeAmount, sParameter) {
  return feeAmount.mul(new BN6(sParameter.protocolShare)).div(new BN6(BASIS_POINT_MAX));
}
function swapQuoteAtBin(bin, binStep, sParameter, vParameter, inAmount, swapForY) {
  if (swapForY && bin.amountY.isZero()) {
    return {
      amountIn: new BN6(0),
      amountOut: new BN6(0),
      fee: new BN6(0),
      protocolFee: new BN6(0)
    };
  }
  if (!swapForY && bin.amountX.isZero()) {
    return {
      amountIn: new BN6(0),
      amountOut: new BN6(0),
      fee: new BN6(0),
      protocolFee: new BN6(0)
    };
  }
  let maxAmountOut;
  let maxAmountIn;
  if (swapForY) {
    maxAmountOut = bin.amountY;
    maxAmountIn = shlDiv(bin.amountY, bin.price, SCALE_OFFSET, 0 /* Up */);
  } else {
    maxAmountOut = bin.amountX;
    maxAmountIn = mulShr(bin.amountX, bin.price, SCALE_OFFSET, 0 /* Up */);
  }
  const maxFee = computeFee(binStep, sParameter, vParameter, maxAmountIn);
  maxAmountIn = maxAmountIn.add(maxFee);
  let amountInWithFees;
  let amountOut;
  let fee;
  let protocolFee;
  if (inAmount.gt(maxAmountIn)) {
    amountInWithFees = maxAmountIn;
    amountOut = maxAmountOut;
    fee = maxFee;
    protocolFee = computeProtocolFee(maxFee, sParameter);
  } else {
    fee = computeFeeFromAmount(binStep, sParameter, vParameter, inAmount);
    const amountInAfterFee = inAmount.sub(fee);
    const computedOutAmount = getOutAmount(bin, amountInAfterFee, swapForY);
    amountOut = computedOutAmount.gt(maxAmountOut) ? maxAmountOut : computedOutAmount;
    protocolFee = computeProtocolFee(fee, sParameter);
    amountInWithFees = inAmount;
  }
  return {
    amountIn: amountInWithFees,
    amountOut,
    fee,
    protocolFee
  };
}

// src/clmm/helpers/index.ts
function chunks(array, size) {
  return Array.apply(0, new Array(Math.ceil(array.length / size))).map(
    (_, index) => array.slice(index * size, (index + 1) * size)
  );
}
async function chunkedFetchMultiplePoolAccount(program, pks, chunkSize = 100) {
  const accounts = (await Promise.all(chunks(pks, chunkSize).map((chunk) => program.account.lbPair.fetchMultiple(chunk)))).flat();
  return accounts.filter(Boolean);
}
async function chunkedFetchMultipleBinArrayBitmapExtensionAccount(program, pks, chunkSize = 100) {
  const accounts = (await Promise.all(
    chunks(pks, chunkSize).map((chunk) => program.account.binArrayBitmapExtension.fetchMultiple(chunk))
  )).flat();
  return accounts;
}
function getOutAmount(bin, inAmount, swapForY) {
  return swapForY ? mulShr(inAmount, bin.price, SCALE_OFFSET, 1 /* Down */) : shlDiv(inAmount, bin.price, SCALE_OFFSET, 1 /* Down */);
}
async function getTokenDecimals(conn, mint) {
  const token = await getMint(conn, mint);
  return await token.decimals;
}
var getOrCreateATAInstruction = async (connection, tokenMint, owner, payer = owner, allowOwnerOffCurve = true) => {
  try {
    const toAccount = await getAssociatedTokenAddress(tokenMint, owner, allowOwnerOffCurve);
    const account = await connection.getAccountInfo(toAccount);
    if (account)
      return { ataPubKey: toAccount, ix: void 0 };
    const ix = createAssociatedTokenAccountInstruction(payer, toAccount, owner, tokenMint);
    return { ataPubKey: toAccount, ix };
  } catch (e) {
    console.error("Error::getOrCreateATAInstruction", e);
    throw e;
  }
};
async function getTokenBalance(conn, tokenAccount) {
  const acc = await getAccount(conn, tokenAccount);
  return acc.amount;
}
var parseLogs = (eventParser, logs) => {
  if (!logs.length)
    throw new Error("No logs found");
  for (const event of eventParser?.parseLogs(logs)) {
    return event.data;
  }
  throw new Error("No events found");
};
var wrapSOLInstruction = (from, to, amount) => {
  return [
    SystemProgram.transfer({
      fromPubkey: from,
      toPubkey: to,
      lamports: amount
    }),
    new TransactionInstruction({
      keys: [
        {
          pubkey: to,
          isSigner: false,
          isWritable: true
        }
      ],
      data: Buffer.from(new Uint8Array([17])),
      programId: TOKEN_PROGRAM_ID
    })
  ];
};
var unwrapSOLInstruction = async (owner) => {
  const wSolATAAccount = getAssociatedTokenAddressSync(NATIVE_MINT, owner);
  if (wSolATAAccount) {
    const closedWrappedSolInstruction = createCloseAccountInstruction(
      wSolATAAccount,
      owner,
      owner,
      [],
      TOKEN_PROGRAM_ID
    );
    return closedWrappedSolInstruction;
  }
  return null;
};
async function chunkedGetMultipleAccountInfos(connection, pks, chunkSize = 100) {
  const accountInfos = (await Promise.all(chunks(pks, chunkSize).map((chunk) => connection.getMultipleAccountsInfo(chunk)))).flat();
  return accountInfos;
}
var computeBudgetIx = () => {
  return ComputeBudgetProgram.setComputeUnitLimit({
    units: 14e5
  });
};

// src/clmm/index.ts
import { bs58 } from "@coral-xyz/anchor/dist/cjs/utils/bytes";
import Decimal2 from "decimal.js";
import { AccountLayout, NATIVE_MINT as NATIVE_MINT2, TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID2 } from "@solana/spl-token";

// src/clmm/error.ts
import { AnchorError } from "@coral-xyz/anchor";
var DLMMError = class extends Error {
  errorCode;
  errorName;
  errorMessage;
  constructor(error) {
    let _errorCode = 0;
    let _errorName = "Something went wrong";
    let _errorMessage = "Something went wrong";
    if (error instanceof Error) {
      const anchorError = AnchorError.parse(JSON.parse(JSON.stringify(error)).logs);
      if (anchorError?.program.toBase58() === LBCLMM_PROGRAM_IDS["mainnet-beta"]) {
        _errorCode = anchorError.error.errorCode.number;
        _errorName = anchorError.error.errorCode.code;
        _errorMessage = anchorError.error.errorMessage;
      }
    } else {
      const idlError = IDL.errors.find((err) => err.code === error);
      if (idlError) {
        _errorCode = idlError.code;
        _errorName = idlError.name;
        _errorMessage = idlError.msg;
      }
    }
    super(_errorMessage);
    this.errorCode = _errorCode;
    this.errorName = _errorName;
    this.errorMessage = _errorMessage;
  }
};
var error_default = DLMMError;

// src/clmm/index.ts
var LBCLMM = class {
  constructor(pubkey, program, lbPair, binArrayBitmapExtension, tokenX, tokenY, opt) {
    this.pubkey = pubkey;
    this.program = program;
    this.lbPair = lbPair;
    this.binArrayBitmapExtension = binArrayBitmapExtension;
    this.tokenX = tokenX;
    this.tokenY = tokenY;
    this.opt = opt;
  }
  static async getLbPairs(connection, opt) {
    const provider = new AnchorProvider(connection, {}, AnchorProvider.defaultOptions());
    const program = new Program2(IDL, LBCLMM_PROGRAM_IDS[opt.cluster], provider);
    return program.account.lbPair.all();
  }
  static async createLbPair(connection, funder, tokenX, tokenY, activeId, binStep, opt) {
    const provider = new AnchorProvider(connection, {}, AnchorProvider.defaultOptions());
    const program = new Program2(IDL, LBCLMM_PROGRAM_IDS[opt.cluster], provider);
    const [lbPair] = deriveLbPair(tokenX, tokenY, binStep, program.programId);
    const [reserveX] = deriveReserve(tokenX, lbPair, program.programId);
    const [reserveY] = deriveReserve(tokenY, lbPair, program.programId);
    const [oracle] = deriveOracle(lbPair, program.programId);
    const [presetParameter] = derivePresetParameter(binStep, program.programId);
    const activeBinArrayIndex = binIdToBinArrayIndex(activeId);
    const binArrayBitmapExtension = isOverflowDefaultBinArrayBitmap(activeBinArrayIndex) ? deriveBinArrayBitmapExtension(lbPair, program.programId)[0] : null;
    return program.methods.initializeLbPair(activeId.toNumber(), binStep.toNumber()).accounts({
      funder,
      lbPair,
      rent: SYSVAR_RENT_PUBKEY,
      reserveX,
      reserveY,
      binArrayBitmapExtension,
      tokenMintX: tokenX,
      tokenMintY: tokenY,
      tokenProgram: TOKEN_PROGRAM_ID2,
      oracle,
      presetParameter,
      systemProgram: SystemProgram2.programId
    }).transaction();
  }
  static async createMultiple(connection, clmmList, opt) {
    const cluster = opt?.cluster || "mainnet-beta";
    const provider = new AnchorProvider(connection, {}, AnchorProvider.defaultOptions());
    const program = new Program2(IDL, LBCLMM_PROGRAM_IDS[cluster], provider);
    const binArrayBitMapExtensions = clmmList.map(
      (lbPair) => deriveBinArrayBitmapExtension(lbPair, program.programId)[0]
    );
    const accountsToFetch = [...clmmList, ...binArrayBitMapExtensions];
    const accountsInfo = await chunkedGetMultipleAccountInfos(connection, accountsToFetch);
    const lbPairArraysMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < clmmList.length; i++) {
      const lbPairPubKey = clmmList[i];
      const lbPairAccountInfoBuffer = accountsInfo[i]?.data;
      if (!lbPairAccountInfoBuffer)
        throw new Error(`LB Pair account ${lbPairPubKey.toBase58()} not found`);
      const binArrayAccInfo = program.coder.accounts.decode("lbPair", lbPairAccountInfoBuffer);
      lbPairArraysMap.set(lbPairPubKey.toBase58(), binArrayAccInfo);
    }
    const binArrayBitMapExtensionsMap = /* @__PURE__ */ new Map();
    for (let i = clmmList.length; i < accountsInfo.length; i++) {
      const index = i - clmmList.length;
      const lbPairPubkey = clmmList[index];
      const binArrayBitMapAccountInfoBuffer = accountsInfo[i]?.data;
      if (binArrayBitMapAccountInfoBuffer) {
        const binArrayBitMapExtensionAccInfo = program.coder.accounts.decode(
          "binArrayBitmapExtension",
          binArrayBitMapAccountInfoBuffer
        );
        binArrayBitMapExtensionsMap.set(lbPairPubkey.toBase58(), binArrayBitMapExtensionAccInfo);
      }
    }
    const reservePublicKeys = Array.from(lbPairArraysMap.values()).map(({ reserveX, reserveY }) => [reserveX, reserveY]).flat();
    const reserveAccountsInfo = await chunkedGetMultipleAccountInfos(program.provider.connection, reservePublicKeys);
    const lbClmmImpl = await Promise.all(
      clmmList.map(async (lbPair, index) => {
        const lbPairState = lbPairArraysMap.get(lbPair.toBase58());
        const binArrayBitmapExtensionState = binArrayBitMapExtensionsMap.get(lbPair.toBase58());
        const binArrayBitmapExtensionPubkey = binArrayBitMapExtensions[index];
        let binArrayBitmapExtension;
        if (binArrayBitmapExtensionState) {
          binArrayBitmapExtension = {
            account: binArrayBitmapExtensionState,
            publicKey: binArrayBitmapExtensionPubkey
          };
        }
        const reserveXBalance = AccountLayout.decode(reserveAccountsInfo[index * 2].data);
        const reserveYBalance = AccountLayout.decode(reserveAccountsInfo[index * 2 + 1].data);
        const [tokenXDecimal, tokenYDecimal] = await Promise.all([
          getTokenDecimals(program.provider.connection, lbPairState.tokenXMint),
          getTokenDecimals(program.provider.connection, lbPairState.tokenYMint)
        ]);
        const tokenX = {
          publicKey: lbPairState.tokenXMint,
          reserve: lbPairState.reserveX,
          amount: reserveXBalance.amount,
          decimal: tokenXDecimal
        };
        const tokenY = {
          publicKey: lbPairState.tokenYMint,
          reserve: lbPairState.reserveY,
          amount: reserveYBalance.amount,
          decimal: tokenYDecimal
        };
        return new LBCLMM(lbPair, program, lbPairState, binArrayBitmapExtension, tokenX, tokenY, opt);
      })
    );
    return lbClmmImpl;
  }
  static async getAllLbPairPositionsByUser(connection, userPubKey, opt) {
    const cluster = opt?.cluster || "mainnet-beta";
    const provider = new AnchorProvider(connection, {}, AnchorProvider.defaultOptions());
    const program = new Program2(IDL, LBCLMM_PROGRAM_IDS[cluster], provider);
    const positions = await program.account.position.all([
      {
        memcmp: {
          bytes: bs58.encode(userPubKey.toBuffer()),
          offset: 8 + 32
        }
      }
    ]);
    const positionsV2 = await program.account.positionV2.all([
      {
        memcmp: {
          bytes: bs58.encode(userPubKey.toBuffer()),
          offset: 8 + 32
        }
      }
    ]);
    const binArrayPubkeySet = /* @__PURE__ */ new Set();
    const lbPairSet = /* @__PURE__ */ new Set();
    positions.forEach(({ account: { upperBinId, lowerBinId, lbPair } }) => {
      const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(lowerBinId));
      const upperBinArrayIndex = binIdToBinArrayIndex(new BN7(upperBinId));
      const [lowerBinArrayPubKey] = deriveBinArray(lbPair, lowerBinArrayIndex, program.programId);
      const [upperBinArrayPubKey] = deriveBinArray(lbPair, upperBinArrayIndex, program.programId);
      binArrayPubkeySet.add(lowerBinArrayPubKey.toBase58());
      binArrayPubkeySet.add(upperBinArrayPubKey.toBase58());
      lbPairSet.add(lbPair.toBase58());
    });
    const binArrayPubkeyArray = Array.from(binArrayPubkeySet).map((pubkey) => new PublicKey5(pubkey));
    const lbPairArray = Array.from(lbPairSet).map((pubkey) => new PublicKey5(pubkey));
    const binArrayPubkeySetV2 = /* @__PURE__ */ new Set();
    const lbPairSetV2 = /* @__PURE__ */ new Set();
    positionsV2.forEach(({ account: { upperBinId, lowerBinId, lbPair } }) => {
      const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(lowerBinId));
      const upperBinArrayIndex = binIdToBinArrayIndex(new BN7(upperBinId));
      const [lowerBinArrayPubKey] = deriveBinArray(lbPair, lowerBinArrayIndex, program.programId);
      const [upperBinArrayPubKey] = deriveBinArray(lbPair, upperBinArrayIndex, program.programId);
      binArrayPubkeySetV2.add(lowerBinArrayPubKey.toBase58());
      binArrayPubkeySetV2.add(upperBinArrayPubKey.toBase58());
      lbPairSetV2.add(lbPair.toBase58());
    });
    const binArrayPubkeyArrayV2 = Array.from(binArrayPubkeySetV2).map((pubkey) => new PublicKey5(pubkey));
    const lbPairArrayV2 = Array.from(lbPairSetV2).map((pubkey) => new PublicKey5(pubkey));
    const binArraysAccInfo = await chunkedGetMultipleAccountInfos(connection, [
      ...binArrayPubkeyArray,
      ...lbPairArray,
      ...binArrayPubkeyArrayV2,
      ...lbPairArrayV2
    ]);
    const positionBinArraysMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < binArrayPubkeyArray.length; i++) {
      const binArrayPubkey = binArrayPubkeyArray[i];
      const binArrayAccInfo = program.coder.accounts.decode("binArray", binArraysAccInfo[i].data);
      positionBinArraysMap.set(binArrayPubkey.toBase58(), binArrayAccInfo);
    }
    const lbPairArraysMap = /* @__PURE__ */ new Map();
    for (let i = binArrayPubkeyArray.length; i < binArrayPubkeyArray.length + lbPairArray.length; i++) {
      const lbPairPubkey = lbPairArray[i - binArrayPubkeyArray.length];
      const lbPairAccInfo = program.coder.accounts.decode("lbPair", binArraysAccInfo[i].data);
      lbPairArraysMap.set(lbPairPubkey.toBase58(), lbPairAccInfo);
    }
    const reservePublicKeys = Array.from(lbPairArraysMap.values()).map(({ reserveX, reserveY }) => [reserveX, reserveY]).flat();
    const positionBinArraysMapV2 = /* @__PURE__ */ new Map();
    for (let i = binArrayPubkeyArray.length + lbPairArray.length; i < binArrayPubkeyArray.length + lbPairArray.length + binArrayPubkeyArrayV2.length; i++) {
      const binArrayPubkey = binArrayPubkeyArrayV2[i - (binArrayPubkeyArray.length + lbPairArray.length)];
      const binArrayAccInfo = program.coder.accounts.decode("binArray", binArraysAccInfo[i].data);
      positionBinArraysMapV2.set(binArrayPubkey.toBase58(), binArrayAccInfo);
    }
    const lbPairArraysMapV2 = /* @__PURE__ */ new Map();
    for (let i = binArrayPubkeyArray.length + lbPairArray.length + binArrayPubkeyArrayV2.length; i < binArraysAccInfo.length; i++) {
      const lbPairPubkey = lbPairArrayV2[i - (binArrayPubkeyArray.length + lbPairArray.length + binArrayPubkeyArrayV2.length)];
      const lbPairAccInfo = program.coder.accounts.decode("lbPair", binArraysAccInfo[i].data);
      lbPairArraysMapV2.set(lbPairPubkey.toBase58(), lbPairAccInfo);
    }
    const reservePublicKeysV2 = Array.from(lbPairArraysMapV2.values()).map(({ reserveX, reserveY }) => [reserveX, reserveY]).flat();
    const reserveAccountsInfo = await chunkedGetMultipleAccountInfos(program.provider.connection, [
      ...reservePublicKeys,
      ...reservePublicKeysV2
    ]);
    const lbPairReserveMap = /* @__PURE__ */ new Map();
    lbPairArray.forEach((lbPair, idx) => {
      const index = idx * 2;
      const reserveAccX = AccountLayout.decode(reserveAccountsInfo[index].data);
      const reserveAccY = AccountLayout.decode(reserveAccountsInfo[index + 1].data);
      lbPairReserveMap.set(lbPair.toBase58(), {
        reserveX: reserveAccX.amount,
        reserveY: reserveAccY.amount
      });
    });
    const lbPairReserveMapV2 = /* @__PURE__ */ new Map();
    lbPairArrayV2.forEach((lbPair, idx) => {
      const index = idx * 2;
      const reserveAccX = AccountLayout.decode(reserveAccountsInfo[reservePublicKeys.length + index].data);
      const reserveAccY = AccountLayout.decode(reserveAccountsInfo[reservePublicKeys.length + index + 1].data);
      lbPairReserveMapV2.set(lbPair.toBase58(), {
        reserveX: reserveAccX.amount,
        reserveY: reserveAccY.amount
      });
    });
    const positionsMap = /* @__PURE__ */ new Map();
    for (let position of positions) {
      const { account, publicKey: positionPubKey } = position;
      const { upperBinId, lowerBinId, lbPair } = account;
      const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(lowerBinId));
      const upperBinArrayIndex = binIdToBinArrayIndex(new BN7(upperBinId));
      const [lowerBinArrayPubKey] = deriveBinArray(lbPair, lowerBinArrayIndex, program.programId);
      const [upperBinArrayPubKey] = deriveBinArray(lbPair, upperBinArrayIndex, program.programId);
      const lowerBinArray = positionBinArraysMap.get(lowerBinArrayPubKey.toBase58());
      const upperBinArray = positionBinArraysMap.get(upperBinArrayPubKey.toBase58());
      const lbPairAcc = lbPairArraysMap.get(lbPair.toBase58());
      const [baseTokenDecimal, quoteTokenDecimal] = await Promise.all([
        getTokenDecimals(program.provider.connection, lbPairAcc.tokenXMint),
        getTokenDecimals(program.provider.connection, lbPairAcc.tokenYMint)
      ]);
      const reserveXBalance = lbPairReserveMap.get(lbPair.toBase58()).reserveX;
      const reserveYBalance = lbPairReserveMap.get(lbPair.toBase58()).reserveY;
      const tokenX = {
        publicKey: lbPairAcc.tokenXMint,
        reserve: lbPairAcc.reserveX,
        amount: reserveXBalance,
        decimal: baseTokenDecimal
      };
      const tokenY = {
        publicKey: lbPairAcc.tokenYMint,
        reserve: lbPairAcc.reserveY,
        amount: reserveYBalance,
        decimal: quoteTokenDecimal
      };
      const positionData = await LBCLMM.processPosition(
        program,
        0 /* V1 */,
        lbPairAcc,
        account,
        baseTokenDecimal,
        quoteTokenDecimal,
        lowerBinArray,
        upperBinArray
      );
      positionsMap.set(lbPair.toBase58(), {
        publicKey: lbPair,
        lbPair: lbPairAcc,
        tokenX,
        tokenY,
        lbPairPositionsData: [
          ...positionsMap.get(lbPair.toBase58())?.lbPairPositionsData ?? [],
          {
            publicKey: positionPubKey,
            positionData,
            version: 0 /* V1 */
          }
        ]
      });
    }
    for (let position of positionsV2) {
      const { account, publicKey: positionPubKey } = position;
      const { upperBinId, lowerBinId, lbPair } = account;
      const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(lowerBinId));
      const upperBinArrayIndex = binIdToBinArrayIndex(new BN7(upperBinId));
      const [lowerBinArrayPubKey] = deriveBinArray(lbPair, lowerBinArrayIndex, program.programId);
      const [upperBinArrayPubKey] = deriveBinArray(lbPair, upperBinArrayIndex, program.programId);
      const lowerBinArray = positionBinArraysMapV2.get(lowerBinArrayPubKey.toBase58());
      const upperBinArray = positionBinArraysMapV2.get(upperBinArrayPubKey.toBase58());
      const lbPairAcc = lbPairArraysMapV2.get(lbPair.toBase58());
      const [baseTokenDecimal, quoteTokenDecimal] = await Promise.all([
        getTokenDecimals(program.provider.connection, lbPairAcc.tokenXMint),
        getTokenDecimals(program.provider.connection, lbPairAcc.tokenYMint)
      ]);
      const reserveXBalance = lbPairReserveMapV2.get(lbPair.toBase58()).reserveX;
      const reserveYBalance = lbPairReserveMapV2.get(lbPair.toBase58()).reserveY;
      const tokenX = {
        publicKey: lbPairAcc.tokenXMint,
        reserve: lbPairAcc.reserveX,
        amount: reserveXBalance,
        decimal: baseTokenDecimal
      };
      const tokenY = {
        publicKey: lbPairAcc.tokenYMint,
        reserve: lbPairAcc.reserveY,
        amount: reserveYBalance,
        decimal: quoteTokenDecimal
      };
      const positionData = await LBCLMM.processPosition(
        program,
        1 /* V2 */,
        lbPairAcc,
        account,
        baseTokenDecimal,
        quoteTokenDecimal,
        lowerBinArray,
        upperBinArray
      );
      positionsMap.set(lbPair.toBase58(), {
        publicKey: lbPair,
        lbPair: lbPairAcc,
        tokenX,
        tokenY,
        lbPairPositionsData: [
          ...positionsMap.get(lbPair.toBase58())?.lbPairPositionsData ?? [],
          {
            publicKey: positionPubKey,
            positionData,
            version: 1 /* V2 */
          }
        ]
      });
    }
    return positionsMap;
  }
  static async processPosition(program, version, lbPair, positionAccount, baseTokenDecimal, quoteTokenDecimal, lowerBinArray, upperBinArray) {
    const { lowerBinId, upperBinId, liquidityShares: posShares, lastUpdatedAt } = positionAccount;
    const bins = LBCLMM.getBinsBetweenLowerAndUpperBound(
      lbPair,
      lowerBinId,
      upperBinId,
      baseTokenDecimal,
      quoteTokenDecimal,
      lowerBinArray,
      upperBinArray
    );
    if (!bins.length)
      return null;
    if (bins[0].binId !== lowerBinId || bins[bins.length - 1].binId !== upperBinId)
      throw new Error("Bin ID mismatch");
    const positionData = [];
    let totalXAmount = new Decimal2(0);
    let totalYAmount = new Decimal2(0);
    bins.forEach((bin, idx) => {
      const binSupply = new Decimal2(bin.supply.toString());
      let posShare;
      if (bin.version === 1 && version === 0 /* V1 */) {
        posShare = new Decimal2(posShares[idx].shln(64).toString());
      } else {
        posShare = new Decimal2(posShares[idx].toString());
      }
      const positionXAmount = binSupply.eq(new Decimal2("0")) ? new Decimal2("0") : posShare.mul(bin.xAmount.toString()).div(binSupply).floor();
      const positionYAmount = binSupply.eq(new Decimal2("0")) ? new Decimal2("0") : posShare.mul(bin.yAmount.toString()).div(binSupply).floor();
      totalXAmount = totalXAmount.add(positionXAmount);
      totalYAmount = totalYAmount.add(positionYAmount);
      positionData.push({
        binId: bin.binId,
        price: bin.price,
        pricePerToken: bin.pricePerToken,
        binXAmount: bin.xAmount.toString(),
        binYAmount: bin.yAmount.toString(),
        binLiquidity: binSupply.toString(),
        positionLiquidity: posShare.toString(),
        positionXAmount: positionXAmount.toString(),
        positionYAmount: positionYAmount.toString()
      });
    });
    const { feeX, feeY } = await LBCLMM.getClaimableSwapFee(
      program,
      version,
      positionAccount,
      lowerBinArray,
      upperBinArray
    );
    const { rewardOne, rewardTwo } = await LBCLMM.getClaimableLMReward(
      program,
      version,
      lbPair,
      positionAccount,
      lowerBinArray,
      upperBinArray
    );
    return {
      totalXAmount: totalXAmount.toString(),
      totalYAmount: totalYAmount.toString(),
      positionBinData: positionData,
      lastUpdatedAt,
      lowerBinId,
      upperBinId,
      feeX,
      feeY,
      rewardOne,
      rewardTwo
    };
  }
  static getBinsBetweenLowerAndUpperBound(lbPair, lowerBinId, upperBinId, baseTokenDecimal, quoteTokenDecimal, lowerBinArrays, upperBinArrays) {
    const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(lowerBinId));
    const upperBinArrayIndex = binIdToBinArrayIndex(new BN7(upperBinId));
    let bins = [];
    if (lowerBinArrayIndex.eq(upperBinArrayIndex)) {
      const binArray = lowerBinArrays;
      const [lowerBinIdForBinArray] = getBinArrayLowerUpperBinId(binArray.index);
      binArray.bins.forEach((bin, idx) => {
        const binId = lowerBinIdForBinArray.toNumber() + idx;
        if (binId >= lowerBinId && binId <= upperBinId) {
          const pricePerLamport = LBCLMM.getPriceOfBinByBinId(lbPair.binStep, binId);
          bins.push({
            binId,
            xAmount: bin.amountX,
            yAmount: bin.amountY,
            supply: bin.liquiditySupply,
            price: pricePerLamport,
            version: binArray.version,
            pricePerToken: new Decimal2(pricePerLamport).mul(new Decimal2(10 ** (baseTokenDecimal - quoteTokenDecimal))).toString()
          });
        }
      });
    } else {
      const binArrays = [lowerBinArrays, upperBinArrays];
      binArrays.forEach((binArray) => {
        const [lowerBinIdForBinArray] = getBinArrayLowerUpperBinId(binArray.index);
        binArray.bins.forEach((bin, idx) => {
          const binId = lowerBinIdForBinArray.toNumber() + idx;
          if (binId >= lowerBinId && binId <= upperBinId) {
            const pricePerLamport = LBCLMM.getPriceOfBinByBinId(lbPair.binStep, binId);
            bins.push({
              binId,
              xAmount: bin.amountX,
              yAmount: bin.amountY,
              supply: bin.liquiditySupply,
              price: pricePerLamport,
              version: binArray.version,
              pricePerToken: new Decimal2(pricePerLamport).mul(new Decimal2(10 ** (baseTokenDecimal - quoteTokenDecimal))).toString()
            });
          }
        });
      });
    }
    return bins;
  }
  static getPriceOfBinByBinId(binStep, binId) {
    const binStepNum = new Decimal2(binStep).div(new Decimal2(BASIS_POINT_MAX));
    return new Decimal2(1).add(new Decimal2(binStepNum)).pow(new Decimal2(binId)).toString();
  }
  static async migratePosition(connection, positions, newPositions, walletPubkey, opt) {
    const cluster = opt?.cluster || "mainnet-beta";
    const provider = new AnchorProvider(connection, {}, AnchorProvider.defaultOptions());
    const program = new Program2(IDL, LBCLMM_PROGRAM_IDS[cluster], provider);
    const positionsState = await program.account.position.fetchMultiple(positions);
    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash("confirmed");
    return Promise.all(
      positionsState.map(async ({ lbPair, lowerBinId }, idx) => {
        const position = positions[idx];
        const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(lowerBinId));
        const upperBinArrayIndex = lowerBinArrayIndex.add(new BN7(1));
        const [lowerBinArrayPubKey] = deriveBinArray(lbPair, lowerBinArrayIndex, program.programId);
        const [upperBinArrayPubKey] = deriveBinArray(lbPair, upperBinArrayIndex, program.programId);
        const migrateTx = await program.methods.migratePosition().accounts({
          binArrayLower: lowerBinArrayPubKey,
          binArrayUpper: upperBinArrayPubKey,
          lbPair,
          owner: walletPubkey,
          positionV1: position,
          positionV2: newPositions[idx],
          program: program.programId,
          rentReceiver: walletPubkey,
          systemProgram: SystemProgram2.programId
        }).transaction();
        return new Transaction({
          blockhash,
          lastValidBlockHeight,
          feePayer: walletPubkey
        }).add(migrateTx);
      })
    );
  }
  async refetchStates() {
    const binArrayBitmapExtensionPubkey = deriveBinArrayBitmapExtension(this.pubkey, this.program.programId)[0];
    const binArrayBitmapExtensionState = await this.program.account.binArrayBitmapExtension.fetchNullable(
      binArrayBitmapExtensionPubkey
    );
    if (binArrayBitmapExtensionState) {
      this.binArrayBitmapExtension = {
        account: binArrayBitmapExtensionState,
        publicKey: binArrayBitmapExtensionPubkey
      };
    }
    const newLbPair = await this.program.account.lbPair.fetch(this.pubkey);
    this.lbPair = newLbPair;
  }
  static async getBinArrays(program, lbPairPubkey) {
    return program.account.binArray.all([
      {
        memcmp: {
          bytes: bs58.encode(lbPairPubkey.toBuffer()),
          offset: 8 + 16
        }
      }
    ]);
  }
  async getBinArrays() {
    return this.program.account.binArray.all([
      {
        memcmp: {
          bytes: bs58.encode(this.pubkey.toBuffer()),
          offset: 8 + 16
        }
      }
    ]);
  }
  getFeeInfo() {
    const { baseFactor, protocolShare } = this.lbPair.parameters;
    const baseFeeRate = new BN7(baseFactor).mul(new BN7(this.lbPair.binStep)).mul(new BN7(10));
    const baseFeeRatePercentage = new Decimal2(baseFeeRate.toString()).mul(new Decimal2(100)).div(new Decimal2(FEE_PRECISION.toString()));
    const maxFeeRatePercentage = new Decimal2(MAX_FEE_RATE.toString()).mul(new Decimal2(100)).div(new Decimal2(FEE_PRECISION.toString()));
    const protocolFeePercentage = new Decimal2(protocolShare.toString()).mul(new Decimal2(100)).div(new Decimal2(BASIS_POINT_MAX));
    return {
      baseFeeRatePercentage,
      maxFeeRatePercentage,
      protocolFeePercentage
    };
  }
  getDynamicFee() {
    let vParameterClone = Object.assign({}, this.lbPair.vParameters);
    let activeId = new BN7(this.lbPair.activeId);
    const sParameters2 = this.lbPair.parameters;
    const currentTimestamp = Date.now() / 1e3;
    this.updateReference(activeId.toNumber(), vParameterClone, sParameters2, currentTimestamp);
    this.updateVolatilityAccumulator(vParameterClone, sParameters2, activeId.toNumber());
    const totalFee = getTotalFee(this.lbPair.binStep, sParameters2, vParameterClone);
    return new Decimal2(totalFee.toString()).div(new Decimal2(FEE_PRECISION.toString())).mul(100);
  }
  getEmissionRate() {
    const [rewardOneEmissionRate, rewardTwoEmissionRate] = this.lbPair.rewardInfos.map(({ rewardRate }) => rewardRate);
    return {
      rewardOne: new Decimal2(rewardOneEmissionRate.toString()).div(PRECISION),
      rewardTwo: new Decimal2(rewardTwoEmissionRate.toString()).div(PRECISION)
    };
  }
  async getBinsAroundActiveBin(numberOfBinsToTheLeft, numberOfBinsToTheRight) {
    const lowerBinId = this.lbPair.activeId - numberOfBinsToTheLeft - 1;
    const upperBinId = this.lbPair.activeId + numberOfBinsToTheRight + 1;
    const bins = await this.getBins(this.pubkey, lowerBinId, upperBinId, this.tokenX.decimal, this.tokenY.decimal);
    return { activeBin: this.lbPair.activeId, bins };
  }
  async getBinsBetweenMinAndMaxPrice(minPrice, maxPrice) {
    const lowerBinId = this.getBinIdFromPrice(minPrice, true) - 1;
    const upperBinId = this.getBinIdFromPrice(maxPrice, false) + 1;
    const bins = await this.getBins(this.pubkey, lowerBinId, upperBinId, this.tokenX.decimal, this.tokenX.decimal);
    return { activeBin: this.lbPair.activeId, bins };
  }
  async getBinsBetweenLowerAndUpperBound(lowerBinId, upperBinId, lowerBinArrays, upperBinArrays) {
    const bins = await this.getBins(
      this.pubkey,
      lowerBinId,
      upperBinId,
      this.tokenX.decimal,
      this.tokenY.decimal,
      lowerBinArrays,
      upperBinArrays
    );
    return { activeBin: this.lbPair.activeId, bins };
  }
  async getBins(lbPairPubKey, lowerBinId, upperBinId, baseTokenDecimal, quoteTokenDecimal, lowerBinArrays, upperBinArrays) {
    const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(lowerBinId));
    const upperBinArrayIndex = binIdToBinArrayIndex(new BN7(upperBinId));
    let bins = [];
    if (lowerBinArrayIndex.eq(upperBinArrayIndex)) {
      const [binArrayPubKey] = deriveBinArray(lbPairPubKey, lowerBinArrayIndex, this.program.programId);
      const binArray = lowerBinArrays ?? await this.program.account.binArray.fetch(binArrayPubKey);
      const [lowerBinIdForBinArray] = getBinArrayLowerUpperBinId(binArray.index);
      binArray.bins.forEach((bin, idx) => {
        const binId = lowerBinIdForBinArray.toNumber() + idx;
        if (binId >= lowerBinId && binId <= upperBinId) {
          const pricePerLamport = this.getPriceOfBinByBinId(binId);
          bins.push({
            binId,
            xAmount: bin.amountX,
            yAmount: bin.amountY,
            supply: bin.liquiditySupply,
            price: pricePerLamport,
            version: binArray.version,
            pricePerToken: new Decimal2(pricePerLamport).mul(new Decimal2(10 ** (baseTokenDecimal - quoteTokenDecimal))).toString()
          });
        }
      });
    } else {
      const [lowerBinArrayPubKey] = deriveBinArray(lbPairPubKey, lowerBinArrayIndex, this.program.programId);
      const [upperBinArrayPubKey] = deriveBinArray(lbPairPubKey, upperBinArrayIndex, this.program.programId);
      const binArrays = await (async () => {
        if (!lowerBinArrays || !upperBinArrays) {
          return (await this.program.account.binArray.fetchMultiple([lowerBinArrayPubKey, upperBinArrayPubKey])).filter(
            (binArray) => binArray !== null
          );
        }
        return [lowerBinArrays, upperBinArrays];
      })();
      binArrays.forEach((binArray) => {
        const [lowerBinIdForBinArray] = getBinArrayLowerUpperBinId(binArray.index);
        binArray.bins.forEach((bin, idx) => {
          const binId = lowerBinIdForBinArray.toNumber() + idx;
          if (binId >= lowerBinId && binId <= upperBinId) {
            const pricePerLamport = this.getPriceOfBinByBinId(binId);
            bins.push({
              binId,
              xAmount: bin.amountX,
              yAmount: bin.amountY,
              supply: bin.liquiditySupply,
              price: pricePerLamport,
              version: binArray.version,
              pricePerToken: new Decimal2(pricePerLamport).mul(new Decimal2(10 ** (baseTokenDecimal - quoteTokenDecimal))).toString()
            });
          }
        });
      });
    }
    return bins;
  }
  toPricePerLamport(price) {
    return new Decimal2(price).mul(new Decimal2(10 ** (this.tokenY.decimal - this.tokenX.decimal))).toString();
  }
  fromPricePerLamport(pricePerLamport) {
    return new Decimal2(pricePerLamport).div(new Decimal2(10 ** (this.tokenY.decimal - this.tokenX.decimal))).toString();
  }
  async getActiveBin() {
    const { activeId } = await this.program.account.lbPair.fetch(this.pubkey);
    return {
      binId: activeId,
      price: this.getPriceOfBinByBinId(activeId)
    };
  }
  getPriceOfBinByBinId(binId) {
    const binStepNum = new Decimal2(this.lbPair.binStep).div(new Decimal2(BASIS_POINT_MAX));
    return new Decimal2(1).add(new Decimal2(binStepNum)).pow(new Decimal2(binId)).toString();
  }
  getBinIdFromPrice(price, min) {
    const binStepNum = new Decimal2(this.lbPair.binStep).div(new Decimal2(BASIS_POINT_MAX));
    const binId = new Decimal2(price).log().dividedBy(new Decimal2(1).add(binStepNum).log());
    return (min ? binId.floor() : binId.ceil()).toNumber();
  }
  async getPositionsByUserAndLbPair(userPubKey) {
    if (!userPubKey) {
      return {
        activeBin: await this.getActiveBin(),
        userPositions: []
      };
    }
    const positions = await this.program.account.position.all([
      {
        memcmp: {
          bytes: bs58.encode(userPubKey.toBuffer()),
          offset: 8 + 32
        }
      },
      {
        memcmp: {
          bytes: bs58.encode(this.pubkey.toBuffer()),
          offset: 8
        }
      }
    ]);
    const positionsV2 = await this.program.account.positionV2.all([
      {
        memcmp: {
          bytes: bs58.encode(userPubKey.toBuffer()),
          offset: 8 + 32
        }
      },
      {
        memcmp: {
          bytes: bs58.encode(this.pubkey.toBuffer()),
          offset: 8
        }
      }
    ]);
    const binArrayPubkeySet = /* @__PURE__ */ new Set();
    positions.forEach(({ account: { upperBinId, lowerBinId } }) => {
      const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(lowerBinId));
      const upperBinArrayIndex = binIdToBinArrayIndex(new BN7(upperBinId));
      const [lowerBinArrayPubKey] = deriveBinArray(this.pubkey, lowerBinArrayIndex, this.program.programId);
      const [upperBinArrayPubKey] = deriveBinArray(this.pubkey, upperBinArrayIndex, this.program.programId);
      binArrayPubkeySet.add(lowerBinArrayPubKey.toBase58());
      binArrayPubkeySet.add(upperBinArrayPubKey.toBase58());
    });
    const binArrayPubkeyArray = Array.from(binArrayPubkeySet).map((pubkey) => new PublicKey5(pubkey));
    const binArrayPubkeySetV2 = /* @__PURE__ */ new Set();
    positionsV2.forEach(({ account: { upperBinId, lowerBinId } }) => {
      const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(lowerBinId));
      const upperBinArrayIndex = binIdToBinArrayIndex(new BN7(upperBinId));
      const [lowerBinArrayPubKey] = deriveBinArray(this.pubkey, lowerBinArrayIndex, this.program.programId);
      const [upperBinArrayPubKey] = deriveBinArray(this.pubkey, upperBinArrayIndex, this.program.programId);
      binArrayPubkeySetV2.add(lowerBinArrayPubKey.toBase58());
      binArrayPubkeySetV2.add(upperBinArrayPubKey.toBase58());
    });
    const binArrayPubkeyArrayV2 = Array.from(binArrayPubkeySetV2).map((pubkey) => new PublicKey5(pubkey));
    const lbPairAndBinArrays = await chunkedGetMultipleAccountInfos(this.program.provider.connection, [
      this.pubkey,
      ...binArrayPubkeyArray,
      ...binArrayPubkeyArrayV2
    ]);
    const [lbPairAccInfo, ...binArraysAccInfo] = lbPairAndBinArrays;
    const positionBinArraysMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < binArrayPubkeyArray.length; i++) {
      const binArrayPubkey = binArrayPubkeyArray[i];
      const binArrayAccInfo = this.program.coder.accounts.decode("binArray", binArraysAccInfo[i].data);
      positionBinArraysMap.set(binArrayPubkey.toBase58(), binArrayAccInfo);
    }
    const positionBinArraysMapV2 = /* @__PURE__ */ new Map();
    for (let i = binArrayPubkeyArray.length; i < binArraysAccInfo.length; i++) {
      const binArrayPubkey = binArrayPubkeyArrayV2[i - binArrayPubkeyArray.length];
      const binArrayAccInfo = this.program.coder.accounts.decode("binArray", binArraysAccInfo[i].data);
      positionBinArraysMapV2.set(binArrayPubkey.toBase58(), binArrayAccInfo);
    }
    const { activeId } = this.program.coder.accounts.decode("lbPair", lbPairAccInfo.data);
    const userPositions = await Promise.all(
      positions.map(async ({ publicKey, account }) => {
        const { lowerBinId, upperBinId } = account;
        const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(lowerBinId));
        const upperBinArrayIndex = binIdToBinArrayIndex(new BN7(upperBinId));
        const [lowerBinArrayPubKey] = deriveBinArray(this.pubkey, lowerBinArrayIndex, this.program.programId);
        const [upperBinArrayPubKey] = deriveBinArray(this.pubkey, upperBinArrayIndex, this.program.programId);
        const lowerBinArray = positionBinArraysMap.get(lowerBinArrayPubKey.toBase58());
        const upperBinArray = positionBinArraysMap.get(upperBinArrayPubKey.toBase58());
        return {
          publicKey,
          positionData: await LBCLMM.processPosition(
            this.program,
            0 /* V1 */,
            this.lbPair,
            account,
            this.tokenX.decimal,
            this.tokenY.decimal,
            lowerBinArray,
            upperBinArray
          ),
          version: 0 /* V1 */
        };
      })
    );
    const userPositionsV2 = await Promise.all(
      positionsV2.map(async ({ publicKey, account }) => {
        const { lowerBinId, upperBinId } = account;
        const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(lowerBinId));
        const upperBinArrayIndex = binIdToBinArrayIndex(new BN7(upperBinId));
        const [lowerBinArrayPubKey] = deriveBinArray(this.pubkey, lowerBinArrayIndex, this.program.programId);
        const [upperBinArrayPubKey] = deriveBinArray(this.pubkey, upperBinArrayIndex, this.program.programId);
        const lowerBinArray = positionBinArraysMapV2.get(lowerBinArrayPubKey.toBase58());
        const upperBinArray = positionBinArraysMapV2.get(upperBinArrayPubKey.toBase58());
        return {
          publicKey,
          positionData: await LBCLMM.processPosition(
            this.program,
            1 /* V2 */,
            this.lbPair,
            account,
            this.tokenX.decimal,
            this.tokenY.decimal,
            lowerBinArray,
            upperBinArray
          ),
          version: 1 /* V2 */
        };
      })
    );
    return {
      activeBin: {
        binId: activeId,
        price: this.getPriceOfBinByBinId(activeId)
      },
      userPositions: [...userPositions, ...userPositionsV2]
    };
  }
  async initializePositionAndAddLiquidityByWeight({
    positionPubKey,
    totalXAmount,
    totalYAmount,
    xYAmountDistribution,
    user
  }) {
    const { lowerBinId, upperBinId, binIds } = this.processXYAmountDistribution(xYAmountDistribution);
    if (upperBinId >= lowerBinId + MAX_BIN_PER_POSITION.toNumber()) {
      throw new Error(`Position must be within a range of 1 to ${MAX_BIN_PER_POSITION.toNumber()} bins.`);
    }
    const preInstructions = [];
    const initializePositionIx = await this.program.methods.initializePosition(lowerBinId, upperBinId - lowerBinId + 1).accounts({
      payer: user,
      position: positionPubKey,
      lbPair: this.pubkey,
      owner: user
    }).instruction();
    preInstructions.push(initializePositionIx);
    const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(lowerBinId));
    const [binArrayLower] = deriveBinArray(this.pubkey, lowerBinArrayIndex, this.program.programId);
    const upperBinArrayIndex = lowerBinArrayIndex.add(new BN7(1));
    const [binArrayUpper] = deriveBinArray(this.pubkey, upperBinArrayIndex, this.program.programId);
    const binArraysNeeded = Array.from(
      { length: upperBinArrayIndex.sub(lowerBinArrayIndex).toNumber() + 4 },
      (_, index) => index - 2 + lowerBinArrayIndex.toNumber()
    ).map((idx) => new BN7(idx));
    const createBinArrayIxs = await this.createBinArraysIfNeeded(this.pubkey, binArraysNeeded, user);
    preInstructions.push(...createBinArrayIxs);
    const [{ ataPubKey: userTokenX, ix: createPayerTokenXIx }, { ataPubKey: userTokenY, ix: createPayerTokenYIx }] = await Promise.all([
      getOrCreateATAInstruction(this.program.provider.connection, this.tokenX.publicKey, user),
      getOrCreateATAInstruction(this.program.provider.connection, this.tokenY.publicKey, user)
    ]);
    createPayerTokenXIx && preInstructions.push(createPayerTokenXIx);
    createPayerTokenYIx && preInstructions.push(createPayerTokenYIx);
    if (this.tokenX.publicKey.equals(NATIVE_MINT2)) {
      const wrapSOLIx = wrapSOLInstruction(user, userTokenX, BigInt(totalXAmount.toString()));
      preInstructions.push(...wrapSOLIx);
    }
    if (this.tokenY.publicKey.equals(NATIVE_MINT2)) {
      const wrapSOLIx = wrapSOLInstruction(user, userTokenY, BigInt(totalYAmount.toString()));
      preInstructions.push(...wrapSOLIx);
    }
    const postInstructions = [];
    if ([this.tokenX.publicKey.toBase58(), this.tokenY.publicKey.toBase58()].includes(NATIVE_MINT2.toBase58())) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    const setComputeUnitLimitIx = ComputeBudgetProgram2.setComputeUnitLimit({
      units: 14e5
    });
    const minBinId = Math.min(...binIds);
    const maxBinId = Math.max(...binIds);
    const minBinArrayIndex = binIdToBinArrayIndex(new BN7(minBinId));
    const maxBinArrayIndex = binIdToBinArrayIndex(new BN7(maxBinId));
    const useExtension = isOverflowDefaultBinArrayBitmap(minBinArrayIndex) || isOverflowDefaultBinArrayBitmap(maxBinArrayIndex);
    const binArrayBitmapExtension = useExtension ? deriveBinArrayBitmapExtension(this.pubkey, this.program.programId)[0] : null;
    const activeId = (await this.getActiveBin()).binId;
    const binLiquidityDist = toWeightDistribution(
      totalXAmount,
      totalYAmount,
      xYAmountDistribution.map((item) => ({
        binId: item.binId,
        xAmountBpsOfTotal: item.xAmountBpsOfTotal,
        yAmountBpsOfTotal: item.yAmountBpsOfTotal
      })),
      this.lbPair.binStep
    );
    if (binLiquidityDist.length === 0) {
      throw new Error("No liquidity to add");
    }
    const liquidityParams = {
      amountX: totalXAmount,
      amountY: totalYAmount,
      binLiquidityDist,
      activeId,
      maxActiveBinSlippage: MAX_ACTIVE_BIN_SLIPPAGE
    };
    const addLiquidityAccounts = {
      position: positionPubKey,
      lbPair: this.pubkey,
      userTokenX,
      userTokenY,
      reserveX: this.lbPair.reserveX,
      reserveY: this.lbPair.reserveY,
      tokenXMint: this.lbPair.tokenXMint,
      tokenYMint: this.lbPair.tokenYMint,
      binArrayLower,
      binArrayUpper,
      binArrayBitmapExtension,
      sender: user,
      tokenXProgram: TOKEN_PROGRAM_ID2,
      tokenYProgram: TOKEN_PROGRAM_ID2
    };
    const oneSideLiquidityParams = {
      amount: totalXAmount.isZero() ? totalYAmount : totalXAmount,
      activeId,
      maxActiveBinSlippage: MAX_ACTIVE_BIN_SLIPPAGE,
      binLiquidityDist
    };
    const oneSideAddLiquidityAccounts = {
      binArrayLower,
      binArrayUpper,
      lbPair: this.pubkey,
      binArrayBitmapExtension: null,
      sender: user,
      position: positionPubKey,
      reserve: totalXAmount.isZero() ? this.lbPair.reserveY : this.lbPair.reserveX,
      tokenMint: totalXAmount.isZero() ? this.lbPair.tokenYMint : this.lbPair.tokenXMint,
      tokenProgram: TOKEN_PROGRAM_ID2,
      userToken: totalXAmount.isZero() ? userTokenY : userTokenX
    };
    const isOneSideDeposit = totalXAmount.isZero() || totalYAmount.isZero();
    const programMethod = isOneSideDeposit ? this.program.methods.addLiquidityOneSide(oneSideLiquidityParams) : this.program.methods.addLiquidityByWeight(liquidityParams);
    if (xYAmountDistribution.length < MAX_BIN_LENGTH_ALLOWED_IN_ONE_TX) {
      const addLiqTx2 = await programMethod.accounts(isOneSideDeposit ? oneSideAddLiquidityAccounts : addLiquidityAccounts).preInstructions([setComputeUnitLimitIx, ...preInstructions]).postInstructions(postInstructions).transaction();
      const { blockhash: blockhash2, lastValidBlockHeight: lastValidBlockHeight2 } = await this.program.provider.connection.getLatestBlockhash(
        "confirmed"
      );
      return new Transaction({
        blockhash: blockhash2,
        lastValidBlockHeight: lastValidBlockHeight2,
        feePayer: user
      }).add(addLiqTx2);
    }
    const addLiqTx = await programMethod.accounts(isOneSideDeposit ? oneSideAddLiquidityAccounts : addLiquidityAccounts).preInstructions([setComputeUnitLimitIx]).transaction();
    const transactions = [];
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    if (preInstructions.length) {
      const preInstructionsTx = new Transaction({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(...preInstructions);
      transactions.push(preInstructionsTx);
    }
    const mainTx = new Transaction({
      blockhash,
      lastValidBlockHeight,
      feePayer: user
    }).add(addLiqTx);
    transactions.push(mainTx);
    if (postInstructions.length) {
      const postInstructionsTx = new Transaction({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(...postInstructions);
      transactions.push(postInstructionsTx);
    }
    return transactions;
  }
  async addLiquidityByWeight({
    lbPairPubKey,
    positionPubKey,
    totalXAmount,
    totalYAmount,
    xYAmountDistribution,
    user
  }) {
    const positionAccount = await this.program.account.positionV2.fetch(positionPubKey);
    const { lowerBinId, upperBinId, binIds } = this.processXYAmountDistribution(xYAmountDistribution);
    if (lowerBinId < positionAccount.lowerBinId)
      throw new Error(`Lower Bin ID (${lowerBinId}) lower than Position Lower Bin Id (${positionAccount.lowerBinId})`);
    if (upperBinId > positionAccount.upperBinId)
      throw new Error(`Upper Bin ID (${upperBinId}) higher than Position Upper Bin Id (${positionAccount.upperBinId})`);
    const minBinId = Math.min(...binIds);
    const maxBinId = Math.max(...binIds);
    const minBinArrayIndex = binIdToBinArrayIndex(new BN7(minBinId));
    const maxBinArrayIndex = binIdToBinArrayIndex(new BN7(maxBinId));
    const useExtension = isOverflowDefaultBinArrayBitmap(minBinArrayIndex) || isOverflowDefaultBinArrayBitmap(maxBinArrayIndex);
    const binArrayBitmapExtension = useExtension ? deriveBinArrayBitmapExtension(this.pubkey, this.program.programId)[0] : null;
    const activeId = (await this.getActiveBin()).binId;
    const binLiquidityDist = toWeightDistribution(
      totalXAmount,
      totalYAmount,
      xYAmountDistribution.map((item) => ({
        binId: item.binId,
        xAmountBpsOfTotal: item.xAmountBpsOfTotal,
        yAmountBpsOfTotal: item.yAmountBpsOfTotal
      })),
      this.lbPair.binStep
    );
    if (binLiquidityDist.length === 0) {
      throw new Error("No liquidity to add");
    }
    const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(positionAccount.lowerBinId));
    const [binArrayLower] = deriveBinArray(lbPairPubKey, lowerBinArrayIndex, this.program.programId);
    const upperBinArrayIndex = lowerBinArrayIndex.add(new BN7(1));
    const [binArrayUpper] = deriveBinArray(lbPairPubKey, upperBinArrayIndex, this.program.programId);
    const binArraysNeeded = Array.from(
      { length: upperBinArrayIndex.sub(lowerBinArrayIndex).toNumber() + 4 },
      (_, index) => index - 2 + lowerBinArrayIndex.toNumber()
    ).map((idx) => new BN7(idx));
    const preInstructions = [];
    const createBinArrayIxs = await this.createBinArraysIfNeeded(lbPairPubKey, binArraysNeeded, user);
    preInstructions.push(...createBinArrayIxs);
    const [{ ataPubKey: userTokenX, ix: createPayerTokenXIx }, { ataPubKey: userTokenY, ix: createPayerTokenYIx }] = await Promise.all([
      getOrCreateATAInstruction(this.program.provider.connection, this.tokenX.publicKey, user),
      getOrCreateATAInstruction(this.program.provider.connection, this.tokenY.publicKey, user)
    ]);
    createPayerTokenXIx && preInstructions.push(createPayerTokenXIx);
    createPayerTokenYIx && preInstructions.push(createPayerTokenYIx);
    if (this.tokenX.publicKey.equals(NATIVE_MINT2)) {
      const wrapSOLIx = wrapSOLInstruction(user, userTokenX, BigInt(totalXAmount.toString()));
      preInstructions.push(...wrapSOLIx);
    }
    if (this.tokenY.publicKey.equals(NATIVE_MINT2)) {
      const wrapSOLIx = wrapSOLInstruction(user, userTokenY, BigInt(totalYAmount.toString()));
      preInstructions.push(...wrapSOLIx);
    }
    const postInstructions = [];
    if ([this.tokenX.publicKey.toBase58(), this.tokenY.publicKey.toBase58()].includes(NATIVE_MINT2.toBase58())) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    const setComputeUnitLimitIx = ComputeBudgetProgram2.setComputeUnitLimit({
      units: 14e5
    });
    const liquidityParams = {
      amountX: totalXAmount,
      amountY: totalYAmount,
      binLiquidityDist,
      activeId,
      maxActiveBinSlippage: MAX_ACTIVE_BIN_SLIPPAGE
    };
    const addLiquidityAccounts = {
      position: positionPubKey,
      lbPair: this.pubkey,
      userTokenX,
      userTokenY,
      reserveX: this.lbPair.reserveX,
      reserveY: this.lbPair.reserveY,
      tokenXMint: this.lbPair.tokenXMint,
      tokenYMint: this.lbPair.tokenYMint,
      binArrayLower,
      binArrayUpper,
      binArrayBitmapExtension,
      sender: user,
      tokenXProgram: TOKEN_PROGRAM_ID2,
      tokenYProgram: TOKEN_PROGRAM_ID2
    };
    const oneSideLiquidityParams = {
      amount: totalXAmount.isZero() ? totalYAmount : totalXAmount,
      activeId,
      maxActiveBinSlippage: MAX_ACTIVE_BIN_SLIPPAGE,
      binLiquidityDist
    };
    const oneSideAddLiquidityAccounts = {
      binArrayLower,
      binArrayUpper,
      lbPair: this.pubkey,
      binArrayBitmapExtension: null,
      sender: user,
      position: positionPubKey,
      reserve: totalXAmount.isZero() ? this.lbPair.reserveY : this.lbPair.reserveX,
      tokenMint: totalXAmount.isZero() ? this.lbPair.tokenYMint : this.lbPair.tokenXMint,
      tokenProgram: TOKEN_PROGRAM_ID2,
      userToken: totalXAmount.isZero() ? userTokenY : userTokenX
    };
    const isOneSideDeposit = totalXAmount.isZero() || totalYAmount.isZero();
    const programMethod = isOneSideDeposit ? this.program.methods.addLiquidityOneSide(oneSideLiquidityParams) : this.program.methods.addLiquidityByWeight(liquidityParams);
    if (xYAmountDistribution.length < MAX_BIN_LENGTH_ALLOWED_IN_ONE_TX) {
      const addLiqTx2 = await programMethod.accounts(isOneSideDeposit ? oneSideAddLiquidityAccounts : addLiquidityAccounts).preInstructions([setComputeUnitLimitIx, ...preInstructions]).postInstructions(postInstructions).transaction();
      const { blockhash: blockhash2, lastValidBlockHeight: lastValidBlockHeight2 } = await this.program.provider.connection.getLatestBlockhash(
        "confirmed"
      );
      return new Transaction({
        blockhash: blockhash2,
        lastValidBlockHeight: lastValidBlockHeight2,
        feePayer: user
      }).add(addLiqTx2);
    }
    const addLiqTx = await programMethod.accounts(isOneSideDeposit ? oneSideAddLiquidityAccounts : addLiquidityAccounts).preInstructions([setComputeUnitLimitIx]).transaction();
    const transactions = [];
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    if (preInstructions.length) {
      const preInstructionsTx = new Transaction({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(...preInstructions);
      transactions.push(preInstructionsTx);
    }
    const mainTx = new Transaction({
      blockhash,
      lastValidBlockHeight,
      feePayer: user
    }).add(addLiqTx);
    transactions.push(mainTx);
    if (postInstructions.length) {
      const postInstructionsTx = new Transaction({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(...postInstructions);
      transactions.push(postInstructionsTx);
    }
    return transactions;
  }
  processXYAmountDistribution(xYAmountDistribution) {
    let currentBinId = null;
    const xAmountDistribution = [];
    const yAmountDistribution = [];
    const binIds = [];
    xYAmountDistribution.forEach((binAndAmount) => {
      xAmountDistribution.push(binAndAmount.xAmountBpsOfTotal);
      yAmountDistribution.push(binAndAmount.yAmountBpsOfTotal);
      binIds.push(binAndAmount.binId);
      if (currentBinId && binAndAmount.binId !== currentBinId + 1) {
        throw new Error("Discontinuous Bin ID");
      } else {
        currentBinId = binAndAmount.binId;
      }
    });
    return {
      lowerBinId: xYAmountDistribution[0].binId,
      upperBinId: xYAmountDistribution[xYAmountDistribution.length - 1].binId,
      xAmountDistribution,
      yAmountDistribution,
      binIds
    };
  }
  async createBinArraysIfNeeded(lbPair, binArrayIndexes, funder) {
    const ixs = [];
    for (const idx of binArrayIndexes) {
      const [binArray] = deriveBinArray(lbPair, idx, this.program.programId);
      const binArrayAccount = await this.program.provider.connection.getAccountInfo(binArray);
      if (binArrayAccount == null) {
        ixs.push(
          await this.program.methods.initializeBinArray(idx).accounts({
            binArray,
            funder,
            lbPair
          }).instruction()
        );
      }
    }
    return ixs;
  }
  async removeLiquidity({
    user,
    position,
    binIds,
    liquiditiesBpsToRemove,
    shouldClaimAndClose = false
  }) {
    const { lbPair, lowerBinId } = await this.program.account.positionV2.fetch(position);
    if (binIds.length !== liquiditiesBpsToRemove.length)
      throw new Error("binIds and liquiditiesBpsToRemove should be of equal length");
    const { reserveX, reserveY, tokenXMint, tokenYMint } = await this.program.account.lbPair.fetch(lbPair);
    const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(lowerBinId));
    const upperBinArrayIndex = lowerBinArrayIndex.add(new BN7(1));
    const [binArrayLower] = deriveBinArray(lbPair, lowerBinArrayIndex, this.program.programId);
    const [binArrayUpper] = deriveBinArray(lbPair, upperBinArrayIndex, this.program.programId);
    const preInstructions = [];
    const setComputeUnitLimitIx = ComputeBudgetProgram2.setComputeUnitLimit({
      units: 14e5
    });
    preInstructions.push(setComputeUnitLimitIx);
    const [{ ataPubKey: userTokenX, ix: createPayerTokenXIx }, { ataPubKey: userTokenY, ix: createPayerTokenYIx }] = await Promise.all([
      getOrCreateATAInstruction(this.program.provider.connection, this.tokenX.publicKey, user),
      getOrCreateATAInstruction(this.program.provider.connection, this.tokenY.publicKey, user)
    ]);
    createPayerTokenXIx && preInstructions.push(createPayerTokenXIx);
    createPayerTokenYIx && preInstructions.push(createPayerTokenYIx);
    const secondTransactionsIx = [];
    const postInstructions = [];
    if (shouldClaimAndClose) {
      const claimSwapFeeIx = await this.program.methods.claimFee().accounts({
        binArrayLower,
        binArrayUpper,
        lbPair: this.pubkey,
        sender: user,
        position,
        reserveX,
        reserveY,
        tokenProgram: TOKEN_PROGRAM_ID2,
        tokenXMint: this.tokenX.publicKey,
        tokenYMint: this.tokenY.publicKey,
        userTokenX,
        userTokenY
      }).instruction();
      postInstructions.push(claimSwapFeeIx);
      for (let i = 0; i < 2; i++) {
        const rewardInfo = this.lbPair.rewardInfos[i];
        if (!rewardInfo || rewardInfo.mint.equals(PublicKey5.default))
          continue;
        const { ataPubKey, ix: rewardAtaIx } = await getOrCreateATAInstruction(
          this.program.provider.connection,
          rewardInfo.mint,
          user
        );
        rewardAtaIx && preInstructions.push(rewardAtaIx);
        const claimRewardIx = await this.program.methods.claimReward(new BN7(i)).accounts({
          lbPair: this.pubkey,
          sender: user,
          position,
          binArrayLower,
          binArrayUpper,
          rewardVault: rewardInfo.vault,
          rewardMint: rewardInfo.mint,
          tokenProgram: TOKEN_PROGRAM_ID2,
          userTokenAccount: ataPubKey
        }).instruction();
        secondTransactionsIx.push(claimRewardIx);
      }
      const closePositionIx = await this.program.methods.closePosition().accounts({
        binArrayLower,
        binArrayUpper,
        rentReceiver: user,
        position,
        lbPair: this.pubkey,
        sender: user
      }).instruction();
      if (secondTransactionsIx.length) {
        secondTransactionsIx.push(closePositionIx);
      } else {
        postInstructions.push(closePositionIx);
      }
    }
    if ([this.tokenX.publicKey.toBase58(), this.tokenY.publicKey.toBase58()].includes(NATIVE_MINT2.toBase58())) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    const binLiquidityReduction = binIds.map((binId, idx) => {
      return {
        binId,
        bpsToRemove: liquiditiesBpsToRemove[idx].toNumber()
      };
    });
    const minBinId = Math.min(...binIds);
    const maxBinId = Math.max(...binIds);
    const minBinArrayIndex = binIdToBinArrayIndex(new BN7(minBinId));
    const maxBinArrayIndex = binIdToBinArrayIndex(new BN7(maxBinId));
    const useExtension = isOverflowDefaultBinArrayBitmap(minBinArrayIndex) || isOverflowDefaultBinArrayBitmap(maxBinArrayIndex);
    const binArrayBitmapExtension = useExtension ? deriveBinArrayBitmapExtension(this.pubkey, this.program.programId)[0] : null;
    const removeLiquidityTx = await this.program.methods.removeLiquidity(binLiquidityReduction).accounts({
      position,
      lbPair,
      userTokenX,
      userTokenY,
      reserveX,
      reserveY,
      tokenXMint,
      tokenYMint,
      binArrayLower,
      binArrayUpper,
      binArrayBitmapExtension,
      tokenXProgram: TOKEN_PROGRAM_ID2,
      tokenYProgram: TOKEN_PROGRAM_ID2,
      sender: user
    }).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    if (secondTransactionsIx.length) {
      const claimRewardsTx = new Transaction({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(...secondTransactionsIx);
      const mainTx = new Transaction({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(removeLiquidityTx);
      return [mainTx, claimRewardsTx];
    } else {
      return new Transaction({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(removeLiquidityTx);
    }
  }
  async closePosition({
    owner,
    position
  }) {
    const { lowerBinId } = await this.program.account.positionV2.fetch(position.publicKey);
    const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(lowerBinId));
    const [binArrayLower] = deriveBinArray(this.pubkey, lowerBinArrayIndex, this.program.programId);
    const upperBinArrayIndex = lowerBinArrayIndex.add(new BN7(1));
    const [binArrayUpper] = deriveBinArray(this.pubkey, upperBinArrayIndex, this.program.programId);
    const closePositionTx = await this.program.methods.closePosition().accounts({
      binArrayLower,
      binArrayUpper,
      rentReceiver: owner,
      position: position.publicKey,
      lbPair: this.pubkey,
      sender: owner
    }).transaction();
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new Transaction({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(closePositionTx);
  }
  /**
   * Returns an equal weightage amount of the opposing token based on ratio.
   * @param {number} lbPair - The pubkey of the LB Pair
   * @param {"X" | "Y"} token - X or Y as string. If X, returns equal weightage of Y or if Y, returns equal weightage of X.
   * @param {BN} tokenAmount - The amount of token X or token Y. If token is "X", pass in the amount of token X. If token is "Y", pass in the amount of token Y.
   * @returns {BN} The equal weightage of the opposing token. If tokenXAmount was passed in, token Y amount is returned else if tokenYAmount was passed in, token X amount is returned
   */
  async getEqualWeightageAmount(lbPairPubKey, token, tokenAmount) {
    const {
      bins: [activeBin]
    } = await this.getBinsAroundActiveBin(0, 0);
    if (new Decimal2(activeBin.yAmount.toString()).gt(new Decimal2("0"))) {
      const xYRatio = new Decimal2(activeBin.xAmount.toString()).div(new Decimal2(activeBin.yAmount.toString()));
      if (token === "X")
        return new BN7(new Decimal2(tokenAmount.toString()).mul(new Decimal2(1).div(xYRatio)).floor().toString());
      if (token === "Y")
        return new BN7(new Decimal2(tokenAmount.toString()).mul(xYRatio).floor().toString());
    }
    if (token === "X")
      return new BN7(new Decimal2(tokenAmount.toString()).mul(new Decimal2(activeBin.price)).toString());
    if (token === "Y")
      return new BN7(new Decimal2(tokenAmount.toString()).div(new Decimal2(activeBin.price)).toString());
  }
  updateVolatilityAccumulator(vParameter, sParameter, activeId) {
    const deltaId = Math.abs(vParameter.indexReference - activeId);
    const newVolatilityAccumulator = vParameter.volatilityReference + deltaId * BASIS_POINT_MAX;
    vParameter.volatilityAccumulator = Math.min(newVolatilityAccumulator, sParameter.maxVolatilityAccumulator);
  }
  updateReference(activeId, vParameter, sParameter, currentTimestamp) {
    const elapsed = currentTimestamp - vParameter.lastUpdateTimestamp.toNumber();
    if (elapsed >= sParameter.filterPeriod) {
      vParameter.indexReference = activeId;
      if (elapsed < sParameter.decayPeriod) {
        const decayedVolatilityReference = Math.floor(
          vParameter.volatilityAccumulator * sParameter.reductionFactor / BASIS_POINT_MAX
        );
        vParameter.volatilityReference = decayedVolatilityReference;
      } else {
        vParameter.volatilityReference = 0;
      }
    }
  }
  /**
   * inAmount: Amount of lamport to swap in
   * swapForY: Swap token X to Y when it is true, else reversed.
   * allowedSlipage: Allowed slippage for the swap. Expressed in BPS. To convert from slippage percentage to BPS unit: SLIPPAGE_PERCENTAGE * 100
   * binArrays: Array of bin arrays to swap from (Can fetch from `getBinArrays`)
   */
  swapQuote(inAmount, swapForY, allowedSlippage, binArrays) {
    const currentTimestamp = Date.now() / 1e3;
    let inAmountLeft = inAmount;
    let vParameterClone = Object.assign({}, this.lbPair.vParameters);
    let activeId = new BN7(this.lbPair.activeId);
    const binStep = this.lbPair.binStep;
    const sParameters2 = this.lbPair.parameters;
    this.updateReference(activeId.toNumber(), vParameterClone, sParameters2, currentTimestamp);
    let startBin = null;
    let binArraysForSwap = /* @__PURE__ */ new Map();
    let actualOutAmount = new BN7(0);
    let feeAmount = new BN7(0);
    let protocolFeeAmount = new BN7(0);
    while (!inAmountLeft.isZero()) {
      let binArrayAccountToSwap = findNextBinArrayWithLiquidity(
        swapForY,
        activeId,
        this.lbPair,
        this.binArrayBitmapExtension?.account,
        binArrays
      );
      if (binArrayAccountToSwap == null) {
        throw new Error("Insufficient liquidity");
      }
      binArraysForSwap.set(binArrayAccountToSwap.publicKey, true);
      this.updateVolatilityAccumulator(vParameterClone, sParameters2, activeId.toNumber());
      if (isBinIdWithinBinArray(activeId, binArrayAccountToSwap.account.index)) {
        const bin = getBinFromBinArray(activeId.toNumber(), binArrayAccountToSwap.account);
        const { amountIn, amountOut, fee, protocolFee } = swapQuoteAtBin(
          bin,
          binStep,
          sParameters2,
          vParameterClone,
          inAmountLeft,
          swapForY
        );
        if (!amountIn.isZero()) {
          inAmountLeft = inAmountLeft.sub(amountIn);
          actualOutAmount = actualOutAmount.add(amountOut);
          feeAmount = feeAmount.add(fee);
          protocolFeeAmount = protocolFee.add(protocolFee);
          if (!startBin) {
            startBin = bin;
          }
        }
      }
      if (!inAmountLeft.isZero()) {
        if (swapForY) {
          activeId = activeId.sub(new BN7(1));
        } else {
          activeId = activeId.add(new BN7(1));
        }
      }
    }
    const outAmountWithoutSlippage = getOutAmount(
      startBin,
      inAmount.sub(computeFeeFromAmount(binStep, sParameters2, vParameterClone, inAmount)),
      swapForY
    );
    const priceImpact = new Decimal2(actualOutAmount.toString()).sub(new Decimal2(outAmountWithoutSlippage.toString())).div(new Decimal2(outAmountWithoutSlippage.toString())).mul(new Decimal2(100));
    const minOutAmount = actualOutAmount.mul(new BN7(BASIS_POINT_MAX).sub(allowedSlippage)).div(new BN7(BASIS_POINT_MAX));
    return {
      outAmount: actualOutAmount,
      fee: feeAmount,
      protocolFee: protocolFeeAmount,
      minOutAmount,
      priceImpact,
      binArraysPubkey: [...binArraysForSwap.keys()]
    };
  }
  /**
   * Returns a transaction to be signed and sent by user performing swap.
   * @param {SwapParams} {inToken, outToken, inAmount, minOutAmount, lbPair, user, outTokenAccount, inTokenAccount}
   * @returns {Transaction}
   */
  async swap({ inToken, outToken, inAmount, minOutAmount, lbPair, user, binArraysPubkey }) {
    const { tokenXMint, tokenYMint, reserveX, reserveY, activeId, oracle } = await this.program.account.lbPair.fetch(
      lbPair
    );
    const preInstructions = [
      ComputeBudgetProgram2.setComputeUnitLimit({
        units: 14e5
      })
    ];
    const [
      { ataPubKey: userTokenIn, ix: createInTokenAccountIx },
      { ataPubKey: userTokenOut, ix: createOutTokenAccountIx }
    ] = await Promise.all([
      getOrCreateATAInstruction(this.program.provider.connection, inToken, user),
      getOrCreateATAInstruction(this.program.provider.connection, outToken, user)
    ]);
    createInTokenAccountIx && preInstructions.push(createInTokenAccountIx);
    createOutTokenAccountIx && preInstructions.push(createOutTokenAccountIx);
    if (inToken.equals(NATIVE_MINT2)) {
      const wrapSOLIx = wrapSOLInstruction(user, userTokenIn, BigInt(inAmount.toString()));
      preInstructions.push(...wrapSOLIx);
    }
    const postInstructions = [];
    if (outToken.equals(NATIVE_MINT2)) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    let swapForY = true;
    if (outToken.equals(tokenXMint))
      swapForY = false;
    const binArrays = binArraysPubkey.map((pubkey) => {
      return {
        isSigner: false,
        isWritable: true,
        pubkey
      };
    });
    return await this.program.methods.swap(inAmount, minOutAmount).accounts({
      lbPair,
      reserveX,
      reserveY,
      tokenXMint,
      tokenYMint,
      tokenXProgram: TOKEN_PROGRAM_ID2,
      // dont use 2022 first; lack familiarity
      tokenYProgram: TOKEN_PROGRAM_ID2,
      // dont use 2022 first; lack familiarity
      user,
      userTokenIn,
      userTokenOut,
      binArrayBitmapExtension: this.binArrayBitmapExtension ? this.binArrayBitmapExtension.publicKey : null,
      oracle,
      hostFeeIn: null
    }).remainingAccounts(binArrays).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
  }
  async createClaimBuildMethod({
    owner,
    position,
    shouldIncludePreIx = true
  }) {
    const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(position.positionData.lowerBinId));
    const [binArrayLower] = deriveBinArray(this.pubkey, lowerBinArrayIndex, this.program.programId);
    const upperBinArrayIndex = lowerBinArrayIndex.add(new BN7(1));
    const [binArrayUpper] = deriveBinArray(this.pubkey, upperBinArrayIndex, this.program.programId);
    const claimTransactions = [];
    for (let i = 0; i < 2; i++) {
      const rewardInfo = this.lbPair.rewardInfos[i];
      if (!rewardInfo || rewardInfo.mint.equals(PublicKey5.default))
        continue;
      const preInstructions = [];
      const { ataPubKey, ix } = await getOrCreateATAInstruction(
        this.program.provider.connection,
        rewardInfo.mint,
        owner
      );
      ix && preInstructions.push(ix);
      const claimTransaction = await this.program.methods.claimReward(new BN7(i)).accounts({
        lbPair: this.pubkey,
        sender: owner,
        position: position.publicKey,
        binArrayLower,
        binArrayUpper,
        rewardVault: rewardInfo.vault,
        rewardMint: rewardInfo.mint,
        tokenProgram: TOKEN_PROGRAM_ID2,
        userTokenAccount: ataPubKey
      }).preInstructions(shouldIncludePreIx ? preInstructions : []).transaction();
      claimTransactions.push(claimTransaction);
    }
    return claimTransactions;
  }
  async createClaimSwapFeeMethod({
    owner,
    position,
    shouldIncludePretIx = true,
    shouldIncludePostIx = true
  }) {
    const { lowerBinId } = position.positionData;
    const lowerBinArrayIndex = binIdToBinArrayIndex(new BN7(lowerBinId));
    const [binArrayLower] = deriveBinArray(this.pubkey, lowerBinArrayIndex, this.program.programId);
    const upperBinArrayIndex = lowerBinArrayIndex.add(new BN7(1));
    const [binArrayUpper] = deriveBinArray(this.pubkey, upperBinArrayIndex, this.program.programId);
    const [reserveX] = deriveReserve(this.tokenX.publicKey, this.pubkey, this.program.programId);
    const [reserveY] = deriveReserve(this.tokenY.publicKey, this.pubkey, this.program.programId);
    const preInstructions = [];
    const [
      { ataPubKey: userTokenX, ix: createInTokenAccountIx },
      { ataPubKey: userTokenY, ix: createOutTokenAccountIx }
    ] = await Promise.all([
      getOrCreateATAInstruction(this.program.provider.connection, this.tokenX.publicKey, owner),
      getOrCreateATAInstruction(this.program.provider.connection, this.tokenY.publicKey, owner)
    ]);
    createInTokenAccountIx && preInstructions.push(createInTokenAccountIx);
    createOutTokenAccountIx && preInstructions.push(createOutTokenAccountIx);
    const postInstructions = [];
    if ([this.tokenX.publicKey.toBase58(), this.tokenY.publicKey.toBase58()].includes(NATIVE_MINT2.toBase58())) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(owner);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    const claimFeeTx = await this.program.methods.claimFee().accounts({
      binArrayLower,
      binArrayUpper,
      lbPair: this.pubkey,
      sender: owner,
      position: position.publicKey,
      reserveX,
      reserveY,
      tokenProgram: TOKEN_PROGRAM_ID2,
      tokenXMint: this.tokenX.publicKey,
      tokenYMint: this.tokenY.publicKey,
      userTokenX,
      userTokenY
    }).preInstructions(shouldIncludePretIx ? preInstructions : []).postInstructions(shouldIncludePostIx ? postInstructions : []).transaction();
    return claimFeeTx;
  }
  static async getClaimableLMReward(program, positionVersion, lbPair, position, lowerBinArray, upperBinArray) {
    const lowerBinArrayIdx = binIdToBinArrayIndex(new BN7(position.lowerBinId));
    const currentTimestamp = Date.now() / 1e3;
    let rewards = [new BN7(0), new BN7(0)];
    let _lowerBinArray = lowerBinArray;
    let _upperBinArray = upperBinArray;
    if (!lowerBinArray || !upperBinArray) {
      const lowerBinArrayIdx2 = binIdToBinArrayIndex(new BN7(position.lowerBinId));
      const [lowerBinArray2] = deriveBinArray(position.lbPair, lowerBinArrayIdx2, program.programId);
      const upperBinArrayIdx = lowerBinArrayIdx2.add(new BN7(1));
      const [upperBinArray2] = deriveBinArray(position.lbPair, upperBinArrayIdx, program.programId);
      [_lowerBinArray, _upperBinArray] = await program.account.binArray.fetchMultiple([lowerBinArray2, upperBinArray2]);
    }
    for (let i = position.lowerBinId; i <= position.upperBinId; i++) {
      const binArrayIdx = binIdToBinArrayIndex(new BN7(i));
      const binArray = binArrayIdx.eq(lowerBinArrayIdx) ? _lowerBinArray : _upperBinArray;
      const binState = getBinFromBinArray(i, binArray);
      const binIdxInPosition = i - position.lowerBinId;
      const positionRewardInfo = position.rewardInfos[binIdxInPosition];
      const liquidityShare = positionVersion === 0 /* V1 */ ? position.liquidityShares[binIdxInPosition] : position.liquidityShares[binIdxInPosition].shrn(64);
      for (let j = 0; j < 2; j++) {
        const pairRewardInfo = lbPair.rewardInfos[j];
        if (!pairRewardInfo.mint.equals(PublicKey5.default)) {
          let rewardPerTokenStored = binState.rewardPerTokenStored[j];
          if (i == lbPair.activeId && !binState.liquiditySupply.isZero()) {
            const currentTime = new BN7(Math.min(currentTimestamp, pairRewardInfo.rewardDurationEnd.toNumber()));
            const delta2 = currentTime.sub(pairRewardInfo.lastUpdateTime);
            const liquiditySupply = binArray.version == 0 ? binState.liquiditySupply : binState.liquiditySupply.shrn(64);
            const rewardPerTokenStoredDelta = pairRewardInfo.rewardRate.mul(delta2).div(liquiditySupply);
            rewardPerTokenStored = rewardPerTokenStored.add(rewardPerTokenStoredDelta);
          }
          const delta = rewardPerTokenStored.sub(positionRewardInfo.rewardPerTokenCompletes[j]);
          const newReward = mulShr(delta, liquidityShare, SCALE_OFFSET, 1 /* Down */);
          rewards[j] = rewards[j].add(newReward).add(positionRewardInfo.rewardPendings[j]);
        }
      }
    }
    return {
      rewardOne: rewards[0],
      rewardTwo: rewards[1]
    };
  }
  async claimLMReward({
    owner,
    position
  }) {
    const claimTransactions = await this.createClaimBuildMethod({ owner, position });
    if (!claimTransactions.length)
      return;
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new Transaction({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(...claimTransactions);
  }
  async claimAllLMRewards({
    owner,
    positions
  }) {
    const claimAllTxs = (await Promise.all(
      positions.map(async (position, idx) => {
        return await this.createClaimBuildMethod({ owner, position, shouldIncludePreIx: idx === 0 });
      })
    )).flat();
    const chunkedClaimAllTx = chunks(claimAllTxs, MAX_CLAIM_ALL_ALLOWED);
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return Promise.all(
      chunkedClaimAllTx.map(async (claimAllTx) => {
        return new Transaction({
          feePayer: owner,
          blockhash,
          lastValidBlockHeight
        }).add(computeBudgetIx()).add(...claimAllTx);
      })
    );
  }
  static async getClaimableSwapFee(program, positionVersion, position, lowerBinArray, upperBinArray) {
    const lowerBinArrayIdx = binIdToBinArrayIndex(new BN7(position.lowerBinId));
    let feeX = new BN7(0);
    let feeY = new BN7(0);
    let _lowerBinArray = lowerBinArray;
    let _upperBinArray = upperBinArray;
    if (!lowerBinArray || !upperBinArray) {
      const lowerBinArrayIdx2 = binIdToBinArrayIndex(new BN7(position.lowerBinId));
      const [lowerBinArray2] = deriveBinArray(position.lbPair, lowerBinArrayIdx2, program.programId);
      const upperBinArrayIdx = lowerBinArrayIdx2.add(new BN7(1));
      const [upperBinArray2] = deriveBinArray(position.lbPair, upperBinArrayIdx, program.programId);
      [_lowerBinArray, _upperBinArray] = await program.account.binArray.fetchMultiple([lowerBinArray2, upperBinArray2]);
    }
    for (let i = position.lowerBinId; i <= position.upperBinId; i++) {
      const binArrayIdx = binIdToBinArrayIndex(new BN7(i));
      const binArray = binArrayIdx.eq(lowerBinArrayIdx) ? _lowerBinArray : _upperBinArray;
      const binState = getBinFromBinArray(i, binArray);
      const binIdxInPosition = i - position.lowerBinId;
      const feeInfos = position.feeInfos[binIdxInPosition];
      const liquidityShare = positionVersion === 0 /* V1 */ ? position.liquidityShares[binIdxInPosition] : position.liquidityShares[binIdxInPosition].shrn(64);
      const newFeeX = mulShr(
        liquidityShare,
        binState.feeAmountXPerTokenStored.sub(feeInfos.feeXPerTokenComplete),
        SCALE_OFFSET,
        1 /* Down */
      );
      const newFeeY = mulShr(
        liquidityShare,
        binState.feeAmountYPerTokenStored.sub(feeInfos.feeYPerTokenComplete),
        SCALE_OFFSET,
        1 /* Down */
      );
      feeX = feeX.add(newFeeX).add(feeInfos.feeXPending);
      feeY = feeY.add(newFeeY).add(feeInfos.feeYPending);
    }
    return { feeX, feeY };
  }
  async claimSwapFee({
    owner,
    position
  }) {
    const claimFeeTx = await this.createClaimSwapFeeMethod({ owner, position });
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new Transaction({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(claimFeeTx);
  }
  async claimAllSwapFee({
    owner,
    positions
  }) {
    const claimAllTxs = (await Promise.all(
      positions.map(async (position, idx) => {
        return await this.createClaimSwapFeeMethod({
          owner,
          position,
          shouldIncludePretIx: idx === 0,
          shouldIncludePostIx: idx === positions.length - 1
        });
      })
    )).flat();
    const chunkedClaimAllTx = chunks(claimAllTxs, MAX_CLAIM_ALL_ALLOWED);
    return Promise.all(
      chunkedClaimAllTx.map(async (claimAllTx) => {
        const { recentBlockhash, lastValidBlockHeight } = claimAllTx[0];
        return new Transaction({
          feePayer: owner,
          blockhash: recentBlockhash,
          lastValidBlockHeight
        }).add(computeBudgetIx()).add(...claimAllTx);
      })
    );
  }
  async claimAllRewardsByPosition({
    owner,
    position
  }) {
    const claimAllSwapFeeTxs = await this.createClaimSwapFeeMethod({ owner, position });
    const claimAllLMTxs = await this.createClaimBuildMethod({ owner, position });
    const claimAllTxs = chunks([claimAllSwapFeeTxs, ...claimAllLMTxs], MAX_CLAIM_ALL_ALLOWED);
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return Promise.all(
      claimAllTxs.map(async (claimAllTx) => {
        return new Transaction({
          feePayer: owner,
          blockhash,
          lastValidBlockHeight
        }).add(computeBudgetIx()).add(...claimAllTx);
      })
    );
  }
  async claimAllRewards({
    owner,
    positions
  }) {
    const claimAllSwapFeeTxs = (await Promise.all(
      positions.map(async (position, idx) => {
        return await this.createClaimSwapFeeMethod({
          owner,
          position,
          shouldIncludePretIx: idx === 0,
          shouldIncludePostIx: idx === positions.length - 1
        });
      })
    )).flat();
    const claimAllLMTxs = (await Promise.all(
      positions.map(async (position, idx) => {
        return await this.createClaimBuildMethod({ owner, position, shouldIncludePreIx: idx === 0 });
      })
    )).flat();
    const chunkedClaimAllTx = chunks([...claimAllSwapFeeTxs, ...claimAllLMTxs], MAX_CLAIM_ALL_ALLOWED);
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return Promise.all(
      chunkedClaimAllTx.map(async (claimAllTx) => {
        return new Transaction({
          feePayer: owner,
          blockhash,
          lastValidBlockHeight
        }).add(computeBudgetIx()).add(...claimAllTx);
      })
    );
  }
};
export {
  ADMIN,
  BASIS_POINT_MAX,
  BIN_ARRAY_BITMAP_SIZE,
  BitmapType,
  error_default as DLMMError,
  EXTENSION_BINARRAY_BITMAP_SIZE,
  FEE_PRECISION,
  LBCLMM,
  LBCLMM_PROGRAM_IDS,
  MAX_ACTIVE_BIN_SLIPPAGE,
  MAX_BIN_ARRAY_SIZE,
  MAX_BIN_LENGTH_ALLOWED_IN_ONE_TX,
  MAX_BIN_PER_POSITION,
  MAX_CLAIM_ALL_ALLOWED,
  MAX_FEE_RATE,
  Network,
  PRECISION,
  PositionVersion,
  SCALE,
  SCALE_OFFSET,
  SIMULATION_USER,
  StrategyType,
  binIdToBinArrayIndex,
  calculateBidAskDistribution,
  calculateNormalDistribution,
  calculateSpotDistribution,
  chunkedFetchMultipleBinArrayBitmapExtensionAccount,
  chunkedFetchMultiplePoolAccount,
  chunkedGetMultipleAccountInfos,
  chunks,
  computeBudgetIx,
  computeFee,
  computeFeeFromAmount,
  computeProtocolFee,
  deriveBinArray,
  deriveBinArrayBitmapExtension,
  deriveLbPair,
  deriveOracle,
  derivePosition,
  derivePresetParameter,
  deriveReserve,
  findNextBinArrayIndexWithLiquidity,
  findNextBinArrayWithLiquidity,
  fromStrategyParamstoWeightDistribution,
  fromWeightDistributionToAmount,
  getBaseFee,
  getBinArrayLowerUpperBinId,
  getBinFromBinArray,
  getOrCreateATAInstruction,
  getOutAmount,
  getTokenBalance,
  getTokenDecimals,
  getTotalFee,
  getVariableFee,
  isBinIdWithinBinArray,
  isOverflowDefaultBinArrayBitmap,
  parabolicParameter,
  parseLogs,
  spotParameter,
  swapQuoteAtBin,
  toStrategyParameters,
  toWeightDistribution,
  unwrapSOLInstruction,
  wrapSOLInstruction
};
//# sourceMappingURL=index.mjs.map