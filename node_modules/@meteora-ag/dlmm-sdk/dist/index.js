"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } async function _asyncNullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return await rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/clmm/index.ts






var _web3js = require('@solana/web3.js');

// src/clmm/idl.ts
var IDL = {
  "version": "0.5.0",
  "name": "lb_clmm",
  "constants": [
    {
      "name": "BASIS_POINT_MAX",
      "type": "i32",
      "value": "10000"
    },
    {
      "name": "MAX_BIN_PER_ARRAY",
      "type": {
        "defined": "usize"
      },
      "value": "70"
    },
    {
      "name": "MAX_BIN_PER_POSITION",
      "type": {
        "defined": "usize"
      },
      "value": "70"
    },
    {
      "name": "MIN_BIN_ID",
      "type": "i32",
      "value": "- 443636"
    },
    {
      "name": "MAX_BIN_ID",
      "type": "i32",
      "value": "443636"
    },
    {
      "name": "MAX_FEE_RATE",
      "type": "u64",
      "value": "100_000_000"
    },
    {
      "name": "FEE_PRECISION",
      "type": "u64",
      "value": "1_000_000_000"
    },
    {
      "name": "MAX_PROTOCOL_SHARE",
      "type": "u16",
      "value": "2_500"
    },
    {
      "name": "HOST_FEE_BPS",
      "type": "u16",
      "value": "2_000"
    },
    {
      "name": "NUM_REWARDS",
      "type": {
        "defined": "usize"
      },
      "value": "2"
    },
    {
      "name": "MIN_REWARD_DURATION",
      "type": "u64",
      "value": "1"
    },
    {
      "name": "MAX_REWARD_DURATION",
      "type": "u64",
      "value": "31536000"
    },
    {
      "name": "EXTENSION_BINARRAY_BITMAP_SIZE",
      "type": {
        "defined": "usize"
      },
      "value": "12"
    },
    {
      "name": "BIN_ARRAY_BITMAP_SIZE",
      "type": "i32",
      "value": "512"
    },
    {
      "name": "MAX_REWARD_BIN_SPLIT",
      "type": {
        "defined": "usize"
      },
      "value": "15"
    },
    {
      "name": "BIN_ARRAY",
      "type": "bytes",
      "value": "[98, 105, 110, 95, 97, 114, 114, 97, 121]"
    },
    {
      "name": "ORACLE",
      "type": "bytes",
      "value": "[111, 114, 97, 99, 108, 101]"
    },
    {
      "name": "BIN_ARRAY_BITMAP_SEED",
      "type": "bytes",
      "value": "[98, 105, 116, 109, 97, 112]"
    },
    {
      "name": "PRESET_PARAMETER",
      "type": "bytes",
      "value": "[112, 114, 101, 115, 101, 116, 95, 112, 97, 114, 97, 109, 101, 116, 101, 114]"
    },
    {
      "name": "PERMISSION",
      "type": "bytes",
      "value": "[112, 101, 114, 109, 105, 115, 115, 105, 111, 110]"
    },
    {
      "name": "POSITION",
      "type": "bytes",
      "value": "[112, 111, 115, 105, 116, 105, 111, 110]"
    }
  ],
  "instructions": [
    {
      "name": "initializeLbPair",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "tokenMintX",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenMintY",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "oracle",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "presetParameter",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "funder",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "activeId",
          "type": "i32"
        },
        {
          "name": "binStep",
          "type": "u16"
        }
      ]
    },
    {
      "name": "initializePermissionLbPair",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "tokenMintX",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenMintY",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "oracle",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "presetParameter",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "funder",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "activeId",
          "type": "i32"
        },
        {
          "name": "binStep",
          "type": "u16"
        }
      ]
    },
    {
      "name": "initializeBinArrayBitmapExtension",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Initialize an account to store if a bin array is initialized."
          ]
        },
        {
          "name": "funder",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "initializeBinArray",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArray",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "funder",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "index",
          "type": "i64"
        }
      ]
    },
    {
      "name": "addLiquidity",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "userTokenX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenXProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "liquidityParameter",
          "type": {
            "defined": "LiquidityParameter"
          }
        }
      ]
    },
    {
      "name": "addLiquidityByWeight",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "userTokenX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenXProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "liquidityParameter",
          "type": {
            "defined": "LiquidityParameterByWeight"
          }
        }
      ]
    },
    {
      "name": "addLiquidityByStrategy",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "userTokenX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenXProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "liquidityParameter",
          "type": {
            "defined": "LiquidityParameterByStrategy"
          }
        }
      ]
    },
    {
      "name": "addLiquidityByStrategyOneSide",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "userToken",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserve",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "liquidityParameter",
          "type": {
            "defined": "LiquidityParameterByStrategyOneSide"
          }
        }
      ]
    },
    {
      "name": "addLiquidityOneSide",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "userToken",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserve",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "liquidityParameter",
          "type": {
            "defined": "LiquidityOneSideParameter"
          }
        }
      ]
    },
    {
      "name": "removeLiquidity",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "userTokenX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenXProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "binLiquidityRemoval",
          "type": {
            "vec": {
              "defined": "BinLiquidityReduction"
            }
          }
        }
      ]
    },
    {
      "name": "initializePosition",
      "accounts": [
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "position",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "lbPair",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "lowerBinId",
          "type": "i32"
        },
        {
          "name": "width",
          "type": "i32"
        }
      ]
    },
    {
      "name": "initializePositionPda",
      "accounts": [
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "base",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "owner"
          ]
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "lowerBinId",
          "type": "i32"
        },
        {
          "name": "width",
          "type": "i32"
        }
      ]
    },
    {
      "name": "initializePositionByOperator",
      "accounts": [
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "base",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "operator",
          "isMut": false,
          "isSigner": true,
          "docs": [
            "operator"
          ]
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "lowerBinId",
          "type": "i32"
        },
        {
          "name": "width",
          "type": "i32"
        },
        {
          "name": "owner",
          "type": "publicKey"
        }
      ]
    },
    {
      "name": "updatePositionOperator",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "operator",
          "type": "publicKey"
        }
      ]
    },
    {
      "name": "swap",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": false,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenIn",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenOut",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "oracle",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "hostFeeIn",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "user",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenXProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "amountIn",
          "type": "u64"
        },
        {
          "name": "minAmountOut",
          "type": "u64"
        }
      ]
    },
    {
      "name": "withdrawProtocolFee",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "receiverTokenX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "receiverTokenY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "feeOwner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenXProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "amountX",
          "type": "u64"
        },
        {
          "name": "amountY",
          "type": "u64"
        }
      ]
    },
    {
      "name": "updateFeeOwner",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "newFeeOwner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": []
    },
    {
      "name": "initializeReward",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "rewardVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "rewardMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "rewardIndex",
          "type": "u64"
        },
        {
          "name": "rewardDuration",
          "type": "u64"
        },
        {
          "name": "funder",
          "type": "publicKey"
        }
      ]
    },
    {
      "name": "fundReward",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "rewardVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "rewardMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "funderTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "funder",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "binArray",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "rewardIndex",
          "type": "u64"
        },
        {
          "name": "amount",
          "type": "u64"
        },
        {
          "name": "carryForward",
          "type": "bool"
        }
      ]
    },
    {
      "name": "updateRewardFunder",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "rewardIndex",
          "type": "u64"
        },
        {
          "name": "newFunder",
          "type": "publicKey"
        }
      ]
    },
    {
      "name": "updateRewardDuration",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "binArray",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "rewardIndex",
          "type": "u64"
        },
        {
          "name": "newDuration",
          "type": "u64"
        }
      ]
    },
    {
      "name": "claimReward",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "rewardVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "rewardMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "userTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "rewardIndex",
          "type": "u64"
        }
      ]
    },
    {
      "name": "claimFee",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "closePosition",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "rentReceiver",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "updateFeeParameters",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "feeParameter",
          "type": {
            "defined": "FeeParameter"
          }
        }
      ]
    },
    {
      "name": "increaseOracleLength",
      "accounts": [
        {
          "name": "oracle",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "funder",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "lengthToAdd",
          "type": "u64"
        }
      ]
    },
    {
      "name": "initializePresetParameter",
      "accounts": [
        {
          "name": "presetParameter",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "ix",
          "type": {
            "defined": "InitPresetParametersIx"
          }
        }
      ]
    },
    {
      "name": "closePresetParameter",
      "accounts": [
        {
          "name": "presetParameter",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "rentReceiver",
          "isMut": true,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "removeAllLiquidity",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayBitmapExtension",
          "isMut": true,
          "isSigner": false,
          "isOptional": true
        },
        {
          "name": "userTokenX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "userTokenY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveX",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "reserveY",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenXMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "sender",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "tokenXProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenYProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "togglePairStatus",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": []
    },
    {
      "name": "updateWhitelistedWallet",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "admin",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "idx",
          "type": "u8"
        },
        {
          "name": "wallet",
          "type": "publicKey"
        }
      ]
    },
    {
      "name": "migratePosition",
      "accounts": [
        {
          "name": "positionV2",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "positionV1",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rentReceiver",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "migrateBinArray",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "updateFeesAndRewards",
      "accounts": [
        {
          "name": "position",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayLower",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "binArrayUpper",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "owner",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": []
    },
    {
      "name": "withdrawIneligibleReward",
      "accounts": [
        {
          "name": "lbPair",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "rewardVault",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "rewardMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "funderTokenAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "funder",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "binArray",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "eventAuthority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "rewardIndex",
          "type": "u64"
        }
      ]
    }
  ],
  "accounts": [
    {
      "name": "binArrayBitmapExtension",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "lbPair",
            "type": "publicKey"
          },
          {
            "name": "positiveBinArrayBitmap",
            "docs": [
              "Packed initialized bin array state for start_bin_index is positive"
            ],
            "type": {
              "array": [
                {
                  "array": [
                    "u64",
                    8
                  ]
                },
                12
              ]
            }
          },
          {
            "name": "negativeBinArrayBitmap",
            "docs": [
              "Packed initialized bin array state for start_bin_index is negative"
            ],
            "type": {
              "array": [
                {
                  "array": [
                    "u64",
                    8
                  ]
                },
                12
              ]
            }
          }
        ]
      }
    },
    {
      "name": "binArray",
      "docs": [
        "An account to contain a range of bin. For example: Bin 100 <-> 200.",
        "For example:",
        "BinArray index: 0 contains bin 0 <-> 599",
        "index: 2 contains bin 600 <-> 1199, ..."
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "index",
            "type": "i64"
          },
          {
            "name": "version",
            "docs": [
              "Version of binArray"
            ],
            "type": "u8"
          },
          {
            "name": "padding",
            "type": {
              "array": [
                "u8",
                7
              ]
            }
          },
          {
            "name": "lbPair",
            "type": "publicKey"
          },
          {
            "name": "bins",
            "type": {
              "array": [
                {
                  "defined": "Bin"
                },
                70
              ]
            }
          }
        ]
      }
    },
    {
      "name": "lbPair",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "parameters",
            "type": {
              "defined": "StaticParameters"
            }
          },
          {
            "name": "vParameters",
            "type": {
              "defined": "VariableParameters"
            }
          },
          {
            "name": "bumpSeed",
            "type": {
              "array": [
                "u8",
                1
              ]
            }
          },
          {
            "name": "binStepSeed",
            "docs": [
              "Bin step signer seed"
            ],
            "type": {
              "array": [
                "u8",
                2
              ]
            }
          },
          {
            "name": "pairType",
            "docs": [
              "Type of the pair"
            ],
            "type": "u8"
          },
          {
            "name": "activeId",
            "docs": [
              "Active bin id"
            ],
            "type": "i32"
          },
          {
            "name": "binStep",
            "docs": [
              "Bin step. Represent the price increment / decrement."
            ],
            "type": "u16"
          },
          {
            "name": "status",
            "docs": [
              "Status of the pair"
            ],
            "type": "u8"
          },
          {
            "name": "padding1",
            "type": {
              "array": [
                "u8",
                5
              ]
            }
          },
          {
            "name": "tokenXMint",
            "docs": [
              "Token X mint"
            ],
            "type": "publicKey"
          },
          {
            "name": "tokenYMint",
            "docs": [
              "Token Y mint"
            ],
            "type": "publicKey"
          },
          {
            "name": "reserveX",
            "docs": [
              "LB token X vault"
            ],
            "type": "publicKey"
          },
          {
            "name": "reserveY",
            "docs": [
              "LB token Y vault"
            ],
            "type": "publicKey"
          },
          {
            "name": "protocolFee",
            "docs": [
              "Uncollected protocol fee"
            ],
            "type": {
              "defined": "ProtocolFee"
            }
          },
          {
            "name": "feeOwner",
            "docs": [
              "Protocol fee owner,"
            ],
            "type": "publicKey"
          },
          {
            "name": "rewardInfos",
            "docs": [
              "Farming reward information"
            ],
            "type": {
              "array": [
                {
                  "defined": "RewardInfo"
                },
                2
              ]
            }
          },
          {
            "name": "oracle",
            "docs": [
              "Oracle pubkey"
            ],
            "type": "publicKey"
          },
          {
            "name": "binArrayBitmap",
            "docs": [
              "Packed initialized bin array state"
            ],
            "type": {
              "array": [
                "u64",
                16
              ]
            }
          },
          {
            "name": "lastUpdatedAt",
            "docs": [
              "Last time the pool fee parameter was updated"
            ],
            "type": "i64"
          },
          {
            "name": "whitelistedWallet",
            "docs": [
              "Whitelisted wallet"
            ],
            "type": {
              "array": [
                "publicKey",
                3
              ]
            }
          },
          {
            "name": "reserved",
            "docs": [
              "Reserved space for future use"
            ],
            "type": {
              "array": [
                "u8",
                88
              ]
            }
          }
        ]
      }
    },
    {
      "name": "oracle",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "idx",
            "docs": [
              "Index of latest observation slot"
            ],
            "type": "u64"
          },
          {
            "name": "activeSize",
            "docs": [
              "Size of active sample. Active sample is initialized observation."
            ],
            "type": "u64"
          },
          {
            "name": "length",
            "docs": [
              "Number of observations"
            ],
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "position",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "lbPair",
            "docs": [
              "The LB pair of this position"
            ],
            "type": "publicKey"
          },
          {
            "name": "owner",
            "docs": [
              "Owner of the position. Client rely on this to to fetch their positions."
            ],
            "type": "publicKey"
          },
          {
            "name": "liquidityShares",
            "docs": [
              "Liquidity shares of this position in bins (lower_bin_id <-> upper_bin_id). This is the same as LP concept."
            ],
            "type": {
              "array": [
                "u64",
                70
              ]
            }
          },
          {
            "name": "rewardInfos",
            "docs": [
              "Farming reward information"
            ],
            "type": {
              "array": [
                {
                  "defined": "UserRewardInfo"
                },
                70
              ]
            }
          },
          {
            "name": "feeInfos",
            "docs": [
              "Swap fee to claim information"
            ],
            "type": {
              "array": [
                {
                  "defined": "FeeInfo"
                },
                70
              ]
            }
          },
          {
            "name": "lowerBinId",
            "docs": [
              "Lower bin ID"
            ],
            "type": "i32"
          },
          {
            "name": "upperBinId",
            "docs": [
              "Upper bin ID"
            ],
            "type": "i32"
          },
          {
            "name": "lastUpdatedAt",
            "docs": [
              "Last updated timestamp"
            ],
            "type": "i64"
          },
          {
            "name": "totalClaimedFeeXAmount",
            "docs": [
              "Total claimed token fee X"
            ],
            "type": "u64"
          },
          {
            "name": "totalClaimedFeeYAmount",
            "docs": [
              "Total claimed token fee Y"
            ],
            "type": "u64"
          },
          {
            "name": "totalClaimedRewards",
            "docs": [
              "Total claimed rewards"
            ],
            "type": {
              "array": [
                "u64",
                2
              ]
            }
          },
          {
            "name": "reserved",
            "docs": [
              "Reserved space for future use"
            ],
            "type": {
              "array": [
                "u8",
                160
              ]
            }
          }
        ]
      }
    },
    {
      "name": "positionV2",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "lbPair",
            "docs": [
              "The LB pair of this position"
            ],
            "type": "publicKey"
          },
          {
            "name": "owner",
            "docs": [
              "Owner of the position. Client rely on this to to fetch their positions."
            ],
            "type": "publicKey"
          },
          {
            "name": "liquidityShares",
            "docs": [
              "Liquidity shares of this position in bins (lower_bin_id <-> upper_bin_id). This is the same as LP concept."
            ],
            "type": {
              "array": [
                "u128",
                70
              ]
            }
          },
          {
            "name": "rewardInfos",
            "docs": [
              "Farming reward information"
            ],
            "type": {
              "array": [
                {
                  "defined": "UserRewardInfo"
                },
                70
              ]
            }
          },
          {
            "name": "feeInfos",
            "docs": [
              "Swap fee to claim information"
            ],
            "type": {
              "array": [
                {
                  "defined": "FeeInfo"
                },
                70
              ]
            }
          },
          {
            "name": "lowerBinId",
            "docs": [
              "Lower bin ID"
            ],
            "type": "i32"
          },
          {
            "name": "upperBinId",
            "docs": [
              "Upper bin ID"
            ],
            "type": "i32"
          },
          {
            "name": "lastUpdatedAt",
            "docs": [
              "Last updated timestamp"
            ],
            "type": "i64"
          },
          {
            "name": "totalClaimedFeeXAmount",
            "docs": [
              "Total claimed token fee X"
            ],
            "type": "u64"
          },
          {
            "name": "totalClaimedFeeYAmount",
            "docs": [
              "Total claimed token fee Y"
            ],
            "type": "u64"
          },
          {
            "name": "totalClaimedRewards",
            "docs": [
              "Total claimed rewards"
            ],
            "type": {
              "array": [
                "u64",
                2
              ]
            }
          },
          {
            "name": "operator",
            "docs": [
              "Operator of position"
            ],
            "type": "publicKey"
          },
          {
            "name": "reserved",
            "docs": [
              "Reserved space for future use"
            ],
            "type": {
              "array": [
                "u8",
                128
              ]
            }
          }
        ]
      }
    },
    {
      "name": "presetParameter",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "binStep",
            "docs": [
              "Bin step. Represent the price increment / decrement."
            ],
            "type": "u16"
          },
          {
            "name": "baseFactor",
            "docs": [
              "Used for base fee calculation. base_fee_rate = base_factor * bin_step"
            ],
            "type": "u16"
          },
          {
            "name": "filterPeriod",
            "docs": [
              "Filter period determine high frequency trading time window."
            ],
            "type": "u16"
          },
          {
            "name": "decayPeriod",
            "docs": [
              "Decay period determine when the volatile fee start decay / decrease."
            ],
            "type": "u16"
          },
          {
            "name": "reductionFactor",
            "docs": [
              "Reduction factor controls the volatile fee rate decrement rate."
            ],
            "type": "u16"
          },
          {
            "name": "variableFeeControl",
            "docs": [
              "Used to scale the variable fee component depending on the dynamic of the market"
            ],
            "type": "u32"
          },
          {
            "name": "maxVolatilityAccumulator",
            "docs": [
              "Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate."
            ],
            "type": "u32"
          },
          {
            "name": "minBinId",
            "docs": [
              "Min bin id supported by the pool based on the configured bin step."
            ],
            "type": "i32"
          },
          {
            "name": "maxBinId",
            "docs": [
              "Max bin id supported by the pool based on the configured bin step."
            ],
            "type": "i32"
          },
          {
            "name": "protocolShare",
            "docs": [
              "Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"
            ],
            "type": "u16"
          }
        ]
      }
    }
  ],
  "types": [
    {
      "name": "LiquidityParameterByStrategyOneSide",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "amount",
            "docs": [
              "Amount of X token or Y token to deposit"
            ],
            "type": "u64"
          },
          {
            "name": "activeId",
            "docs": [
              "Active bin that integrator observe off-chain"
            ],
            "type": "i32"
          },
          {
            "name": "maxActiveBinSlippage",
            "docs": [
              "max active bin slippage allowed"
            ],
            "type": "i32"
          },
          {
            "name": "strategyParameters",
            "docs": [
              "strategy parameters"
            ],
            "type": {
              "defined": "StrategyParameters"
            }
          }
        ]
      }
    },
    {
      "name": "LiquidityParameterByStrategy",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "amountX",
            "docs": [
              "Amount of X token to deposit"
            ],
            "type": "u64"
          },
          {
            "name": "amountY",
            "docs": [
              "Amount of Y token to deposit"
            ],
            "type": "u64"
          },
          {
            "name": "activeId",
            "docs": [
              "Active bin that integrator observe off-chain"
            ],
            "type": "i32"
          },
          {
            "name": "maxActiveBinSlippage",
            "docs": [
              "max active bin slippage allowed"
            ],
            "type": "i32"
          },
          {
            "name": "strategyParameters",
            "docs": [
              "strategy parameters"
            ],
            "type": {
              "defined": "StrategyParameters"
            }
          }
        ]
      }
    },
    {
      "name": "StrategyParameters",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "minBinId",
            "docs": [
              "min bin id"
            ],
            "type": "i32"
          },
          {
            "name": "maxBinId",
            "docs": [
              "max bin id"
            ],
            "type": "i32"
          },
          {
            "name": "strategyType",
            "docs": [
              "strategy type"
            ],
            "type": {
              "defined": "StrategyType"
            }
          },
          {
            "name": "parameteres",
            "docs": [
              "parameters"
            ],
            "type": {
              "array": [
                "u8",
                64
              ]
            }
          }
        ]
      }
    },
    {
      "name": "ParabolicParameter",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "aAsk",
            "docs": [
              "amplification in ask side"
            ],
            "type": "i16"
          },
          {
            "name": "aBid",
            "docs": [
              "amplification in bid side"
            ],
            "type": "i16"
          },
          {
            "name": "aActiveBin",
            "docs": [
              "amplification in active bin"
            ],
            "type": "i16"
          },
          {
            "name": "centerBinId",
            "docs": [
              "center bin id"
            ],
            "type": "i32"
          }
        ]
      }
    },
    {
      "name": "SpotParameter",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "weightAsk",
            "docs": [
              "weight in ask side"
            ],
            "type": "u16"
          },
          {
            "name": "weightBid",
            "docs": [
              "weight in bid side"
            ],
            "type": "u16"
          },
          {
            "name": "weightActiveBin",
            "docs": [
              "weight in active bin"
            ],
            "type": "u16"
          }
        ]
      }
    },
    {
      "name": "BinLiquidityDistributionByWeight",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "binId",
            "docs": [
              "Define the bin ID wish to deposit to."
            ],
            "type": "i32"
          },
          {
            "name": "weight",
            "docs": [
              "weight of liquidity distributed for this bin id"
            ],
            "type": "u16"
          }
        ]
      }
    },
    {
      "name": "LiquidityParameterByWeight",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "amountX",
            "docs": [
              "Amount of X token to deposit"
            ],
            "type": "u64"
          },
          {
            "name": "amountY",
            "docs": [
              "Amount of Y token to deposit"
            ],
            "type": "u64"
          },
          {
            "name": "activeId",
            "docs": [
              "Active bin that integrator observe off-chain"
            ],
            "type": "i32"
          },
          {
            "name": "maxActiveBinSlippage",
            "docs": [
              "max active bin slippage allowed"
            ],
            "type": "i32"
          },
          {
            "name": "binLiquidityDist",
            "docs": [
              "Liquidity distribution to each bins"
            ],
            "type": {
              "vec": {
                "defined": "BinLiquidityDistributionByWeight"
              }
            }
          }
        ]
      }
    },
    {
      "name": "LiquidityOneSideParameter",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "amount",
            "docs": [
              "Amount of X token or Y token to deposit"
            ],
            "type": "u64"
          },
          {
            "name": "activeId",
            "docs": [
              "Active bin that integrator observe off-chain"
            ],
            "type": "i32"
          },
          {
            "name": "maxActiveBinSlippage",
            "docs": [
              "max active bin slippage allowed"
            ],
            "type": "i32"
          },
          {
            "name": "binLiquidityDist",
            "docs": [
              "Liquidity distribution to each bins"
            ],
            "type": {
              "vec": {
                "defined": "BinLiquidityDistributionByWeight"
              }
            }
          }
        ]
      }
    },
    {
      "name": "BinLiquidityDistribution",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "binId",
            "docs": [
              "Define the bin ID wish to deposit to."
            ],
            "type": "i32"
          },
          {
            "name": "distributionX",
            "docs": [
              "DistributionX (or distributionY) is the percentages of amountX (or amountY) you want to add to each bin."
            ],
            "type": "u16"
          },
          {
            "name": "distributionY",
            "docs": [
              "DistributionX (or distributionY) is the percentages of amountX (or amountY) you want to add to each bin."
            ],
            "type": "u16"
          }
        ]
      }
    },
    {
      "name": "LiquidityParameter",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "amountX",
            "docs": [
              "Amount of X token to deposit"
            ],
            "type": "u64"
          },
          {
            "name": "amountY",
            "docs": [
              "Amount of Y token to deposit"
            ],
            "type": "u64"
          },
          {
            "name": "binLiquidityDist",
            "docs": [
              "Liquidity distribution to each bins"
            ],
            "type": {
              "vec": {
                "defined": "BinLiquidityDistribution"
              }
            }
          }
        ]
      }
    },
    {
      "name": "InitPresetParametersIx",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "binStep",
            "docs": [
              "Bin step. Represent the price increment / decrement."
            ],
            "type": "u16"
          },
          {
            "name": "baseFactor",
            "docs": [
              "Used for base fee calculation. base_fee_rate = base_factor * bin_step"
            ],
            "type": "u16"
          },
          {
            "name": "filterPeriod",
            "docs": [
              "Filter period determine high frequency trading time window."
            ],
            "type": "u16"
          },
          {
            "name": "decayPeriod",
            "docs": [
              "Decay period determine when the volatile fee start decay / decrease."
            ],
            "type": "u16"
          },
          {
            "name": "reductionFactor",
            "docs": [
              "Reduction factor controls the volatile fee rate decrement rate."
            ],
            "type": "u16"
          },
          {
            "name": "variableFeeControl",
            "docs": [
              "Used to scale the variable fee component depending on the dynamic of the market"
            ],
            "type": "u32"
          },
          {
            "name": "maxVolatilityAccumulator",
            "docs": [
              "Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate."
            ],
            "type": "u32"
          },
          {
            "name": "minBinId",
            "docs": [
              "Min bin id supported by the pool based on the configured bin step."
            ],
            "type": "i32"
          },
          {
            "name": "maxBinId",
            "docs": [
              "Max bin id supported by the pool based on the configured bin step."
            ],
            "type": "i32"
          },
          {
            "name": "protocolShare",
            "docs": [
              "Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"
            ],
            "type": "u16"
          }
        ]
      }
    },
    {
      "name": "BinLiquidityReduction",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "binId",
            "type": "i32"
          },
          {
            "name": "bpsToRemove",
            "type": "u16"
          }
        ]
      }
    },
    {
      "name": "FeeParameter",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "protocolShare",
            "docs": [
              "Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"
            ],
            "type": "u16"
          },
          {
            "name": "baseFactor",
            "docs": [
              "Base factor for base fee rate"
            ],
            "type": "u16"
          }
        ]
      }
    },
    {
      "name": "Bin",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "amountX",
            "docs": [
              "Amount of token X in the bin. This already excluded protocol fees."
            ],
            "type": "u64"
          },
          {
            "name": "amountY",
            "docs": [
              "Amount of token Y in the bin. This already excluded protocol fees."
            ],
            "type": "u64"
          },
          {
            "name": "price",
            "docs": [
              "Bin price"
            ],
            "type": "u128"
          },
          {
            "name": "liquiditySupply",
            "docs": [
              "Liquidities of the bin. This is the same as LP mint supply. q-number"
            ],
            "type": "u128"
          },
          {
            "name": "rewardPerTokenStored",
            "docs": [
              "reward_a_per_token_stored"
            ],
            "type": {
              "array": [
                "u128",
                2
              ]
            }
          },
          {
            "name": "feeAmountXPerTokenStored",
            "docs": [
              "Swap fee amount of token X per liquidity deposited."
            ],
            "type": "u128"
          },
          {
            "name": "feeAmountYPerTokenStored",
            "docs": [
              "Swap fee amount of token Y per liquidity deposited."
            ],
            "type": "u128"
          },
          {
            "name": "amountXIn",
            "docs": [
              "Total token X swap into the bin. Only used for tracking purpose."
            ],
            "type": "u128"
          },
          {
            "name": "amountYIn",
            "docs": [
              "Total token Y swap into he bin. Only used for tracking purpose."
            ],
            "type": "u128"
          }
        ]
      }
    },
    {
      "name": "ProtocolFee",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "amountX",
            "type": "u64"
          },
          {
            "name": "amountY",
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "RewardInfo",
      "docs": [
        "Stores the state relevant for tracking liquidity mining rewards"
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "mint",
            "docs": [
              "Reward token mint."
            ],
            "type": "publicKey"
          },
          {
            "name": "vault",
            "docs": [
              "Reward vault token account."
            ],
            "type": "publicKey"
          },
          {
            "name": "funder",
            "docs": [
              "Authority account that allows to fund rewards"
            ],
            "type": "publicKey"
          },
          {
            "name": "rewardDuration",
            "docs": [
              "TODO check whether we need to store it in pool"
            ],
            "type": "u64"
          },
          {
            "name": "rewardDurationEnd",
            "docs": [
              "TODO check whether we need to store it in pool"
            ],
            "type": "u64"
          },
          {
            "name": "rewardRate",
            "docs": [
              "TODO check whether we need to store it in pool"
            ],
            "type": "u128"
          },
          {
            "name": "lastUpdateTime",
            "docs": [
              "The last time reward states were updated."
            ],
            "type": "u64"
          },
          {
            "name": "cumulativeSecondsWithEmptyLiquidityReward",
            "docs": [
              "Accumulated seconds where when farm distribute rewards, but the bin is empty. The reward will be accumulated for next reward time window."
            ],
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "Observation",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "cumulativeActiveBinId",
            "docs": [
              "Cumulative active bin ID"
            ],
            "type": "i128"
          },
          {
            "name": "createdAt",
            "docs": [
              "Observation sample created timestamp"
            ],
            "type": "i64"
          },
          {
            "name": "lastUpdatedAt",
            "docs": [
              "Observation sample last updated timestamp"
            ],
            "type": "i64"
          }
        ]
      }
    },
    {
      "name": "StaticParameters",
      "docs": [
        "Parameter that set by the protocol"
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "baseFactor",
            "docs": [
              "Used for base fee calculation. base_fee_rate = base_factor * bin_step"
            ],
            "type": "u16"
          },
          {
            "name": "filterPeriod",
            "docs": [
              "Filter period determine high frequency trading time window."
            ],
            "type": "u16"
          },
          {
            "name": "decayPeriod",
            "docs": [
              "Decay period determine when the volatile fee start decay / decrease."
            ],
            "type": "u16"
          },
          {
            "name": "reductionFactor",
            "docs": [
              "Reduction factor controls the volatile fee rate decrement rate."
            ],
            "type": "u16"
          },
          {
            "name": "variableFeeControl",
            "docs": [
              "Used to scale the variable fee component depending on the dynamic of the market"
            ],
            "type": "u32"
          },
          {
            "name": "maxVolatilityAccumulator",
            "docs": [
              "Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate."
            ],
            "type": "u32"
          },
          {
            "name": "minBinId",
            "docs": [
              "Min bin id supported by the pool based on the configured bin step."
            ],
            "type": "i32"
          },
          {
            "name": "maxBinId",
            "docs": [
              "Max bin id supported by the pool based on the configured bin step."
            ],
            "type": "i32"
          },
          {
            "name": "protocolShare",
            "docs": [
              "Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee"
            ],
            "type": "u16"
          },
          {
            "name": "padding",
            "docs": [
              "Padding for bytemuck safe alignment"
            ],
            "type": {
              "array": [
                "u8",
                6
              ]
            }
          }
        ]
      }
    },
    {
      "name": "VariableParameters",
      "docs": [
        "Parameters that changes based on dynamic of the market"
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "volatilityAccumulator",
            "docs": [
              "Volatility accumulator measure the number of bin crossed since reference bin ID. Normally (without filter period taken into consideration), reference bin ID is the active bin of last swap.",
              "It affects the variable fee rate"
            ],
            "type": "u32"
          },
          {
            "name": "volatilityReference",
            "docs": [
              "Volatility reference is decayed volatility accumulator. It is always <= volatility_accumulator"
            ],
            "type": "u32"
          },
          {
            "name": "indexReference",
            "docs": [
              "Active bin id of last swap."
            ],
            "type": "i32"
          },
          {
            "name": "padding",
            "docs": [
              "Padding for bytemuck safe alignment"
            ],
            "type": {
              "array": [
                "u8",
                4
              ]
            }
          },
          {
            "name": "lastUpdateTimestamp",
            "docs": [
              "Last timestamp the variable parameters was updated"
            ],
            "type": "i64"
          },
          {
            "name": "padding1",
            "docs": [
              "Padding for bytemuck safe alignment"
            ],
            "type": {
              "array": [
                "u8",
                8
              ]
            }
          }
        ]
      }
    },
    {
      "name": "FeeInfo",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "feeXPerTokenComplete",
            "type": "u128"
          },
          {
            "name": "feeYPerTokenComplete",
            "type": "u128"
          },
          {
            "name": "feeXPending",
            "type": "u64"
          },
          {
            "name": "feeYPending",
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "UserRewardInfo",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "rewardPerTokenCompletes",
            "type": {
              "array": [
                "u128",
                2
              ]
            }
          },
          {
            "name": "rewardPendings",
            "type": {
              "array": [
                "u64",
                2
              ]
            }
          }
        ]
      }
    },
    {
      "name": "StrategyType",
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Spot"
          },
          {
            "name": "Curve"
          },
          {
            "name": "BidAsk"
          }
        ]
      }
    },
    {
      "name": "Rounding",
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Up"
          },
          {
            "name": "Down"
          }
        ]
      }
    },
    {
      "name": "LayoutVersion",
      "docs": [
        "Layout version"
      ],
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "V0"
          },
          {
            "name": "V1"
          }
        ]
      }
    },
    {
      "name": "PairType",
      "docs": [
        "Type of the Pair. 0 = Permissionless, 1 = Permission. Putting 0 as permissionless for backward compatibility."
      ],
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Permissionless"
          },
          {
            "name": "Permission"
          }
        ]
      }
    },
    {
      "name": "PairStatus",
      "docs": [
        "Pair status. 0 = Enabled, 1 = Disabled. Putting 0 as enabled for backward compatibility."
      ],
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Enabled"
          },
          {
            "name": "Disabled"
          }
        ]
      }
    }
  ],
  "events": [
    {
      "name": "CompositionFee",
      "fields": [
        {
          "name": "from",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "binId",
          "type": "i16",
          "index": false
        },
        {
          "name": "tokenXFeeAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "tokenYFeeAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "protocolTokenXFeeAmount",
          "type": "u64",
          "index": false
        },
        {
          "name": "protocolTokenYFeeAmount",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "AddLiquidity",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "from",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "position",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "amounts",
          "type": {
            "array": [
              "u64",
              2
            ]
          },
          "index": false
        },
        {
          "name": "activeBinId",
          "type": "i32",
          "index": false
        }
      ]
    },
    {
      "name": "RemoveLiquidity",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "from",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "position",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "amounts",
          "type": {
            "array": [
              "u64",
              2
            ]
          },
          "index": false
        },
        {
          "name": "activeBinId",
          "type": "i32",
          "index": false
        }
      ]
    },
    {
      "name": "Swap",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "from",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "startBinId",
          "type": "i32",
          "index": false
        },
        {
          "name": "endBinId",
          "type": "i32",
          "index": false
        },
        {
          "name": "amountIn",
          "type": "u64",
          "index": false
        },
        {
          "name": "amountOut",
          "type": "u64",
          "index": false
        },
        {
          "name": "swapForY",
          "type": "bool",
          "index": false
        },
        {
          "name": "fee",
          "type": "u64",
          "index": false
        },
        {
          "name": "protocolFee",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeBps",
          "type": "u128",
          "index": false
        },
        {
          "name": "hostFee",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "ClaimReward",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "position",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "rewardIndex",
          "type": "u64",
          "index": false
        },
        {
          "name": "totalReward",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "FundReward",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "funder",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "rewardIndex",
          "type": "u64",
          "index": false
        },
        {
          "name": "amount",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "InitializeReward",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "rewardMint",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "funder",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "rewardIndex",
          "type": "u64",
          "index": false
        },
        {
          "name": "rewardDuration",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "UpdateRewardDuration",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "rewardIndex",
          "type": "u64",
          "index": false
        },
        {
          "name": "oldRewardDuration",
          "type": "u64",
          "index": false
        },
        {
          "name": "newRewardDuration",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "UpdateRewardFunder",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "rewardIndex",
          "type": "u64",
          "index": false
        },
        {
          "name": "oldFunder",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "newFunder",
          "type": "publicKey",
          "index": false
        }
      ]
    },
    {
      "name": "PositionClose",
      "fields": [
        {
          "name": "position",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        }
      ]
    },
    {
      "name": "ClaimFee",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "position",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "feeX",
          "type": "u64",
          "index": false
        },
        {
          "name": "feeY",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "LbPairCreate",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "binStep",
          "type": "u16",
          "index": false
        },
        {
          "name": "tokenX",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "tokenY",
          "type": "publicKey",
          "index": false
        }
      ]
    },
    {
      "name": "PositionCreate",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "position",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "owner",
          "type": "publicKey",
          "index": false
        }
      ]
    },
    {
      "name": "FeeParameterUpdate",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "protocolShare",
          "type": "u16",
          "index": false
        },
        {
          "name": "baseFactor",
          "type": "u16",
          "index": false
        }
      ]
    },
    {
      "name": "IncreaseObservation",
      "fields": [
        {
          "name": "oracle",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "newObservationLength",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "WithdrawIneligibleReward",
      "fields": [
        {
          "name": "lbPair",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "rewardMint",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "amount",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "UpdatePositionOperator",
      "fields": [
        {
          "name": "position",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "oldOperator",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "newOperator",
          "type": "publicKey",
          "index": false
        }
      ]
    }
  ],
  "errors": [
    {
      "code": 6e3,
      "name": "InvalidStartBinIndex",
      "msg": "Invalid start bin index"
    },
    {
      "code": 6001,
      "name": "InvalidBinId",
      "msg": "Invalid bin id"
    },
    {
      "code": 6002,
      "name": "InvalidInput",
      "msg": "Invalid input data"
    },
    {
      "code": 6003,
      "name": "ExceededAmountSlippageTolerance",
      "msg": "Exceeded amount slippage tolerance"
    },
    {
      "code": 6004,
      "name": "ExceededBinSlippageTolerance",
      "msg": "Exceeded bin slippage tolerance"
    },
    {
      "code": 6005,
      "name": "CompositionFactorFlawed",
      "msg": "Composition factor flawed"
    },
    {
      "code": 6006,
      "name": "NonPresetBinStep",
      "msg": "Non preset bin step"
    },
    {
      "code": 6007,
      "name": "ZeroLiquidity",
      "msg": "Zero liquidity"
    },
    {
      "code": 6008,
      "name": "InvalidPosition",
      "msg": "Invalid position"
    },
    {
      "code": 6009,
      "name": "BinArrayNotFound",
      "msg": "Bin array not found"
    },
    {
      "code": 6010,
      "name": "InvalidTokenMint",
      "msg": "Invalid token mint"
    },
    {
      "code": 6011,
      "name": "InvalidAccountForSingleDeposit",
      "msg": "Invalid account for single deposit"
    },
    {
      "code": 6012,
      "name": "PairInsufficientLiquidity",
      "msg": "Pair insufficient liquidity"
    },
    {
      "code": 6013,
      "name": "InvalidFeeOwner",
      "msg": "Invalid fee owner"
    },
    {
      "code": 6014,
      "name": "InvalidFeeWithdrawAmount",
      "msg": "Invalid fee withdraw amount"
    },
    {
      "code": 6015,
      "name": "InvalidAdmin",
      "msg": "Invalid admin"
    },
    {
      "code": 6016,
      "name": "IdenticalFeeOwner",
      "msg": "Identical fee owner"
    },
    {
      "code": 6017,
      "name": "InvalidBps",
      "msg": "Invalid basis point"
    },
    {
      "code": 6018,
      "name": "MathOverflow",
      "msg": "Math operation overflow"
    },
    {
      "code": 6019,
      "name": "TypeCastFailed",
      "msg": "Type cast error"
    },
    {
      "code": 6020,
      "name": "InvalidRewardIndex",
      "msg": "Invalid reward index"
    },
    {
      "code": 6021,
      "name": "InvalidRewardDuration",
      "msg": "Invalid reward duration"
    },
    {
      "code": 6022,
      "name": "RewardInitialized",
      "msg": "Reward already initialized"
    },
    {
      "code": 6023,
      "name": "RewardUninitialized",
      "msg": "Reward not initialized"
    },
    {
      "code": 6024,
      "name": "IdenticalFunder",
      "msg": "Identical funder"
    },
    {
      "code": 6025,
      "name": "RewardCampaignInProgress",
      "msg": "Reward campaign in progress"
    },
    {
      "code": 6026,
      "name": "IdenticalRewardDuration",
      "msg": "Reward duration is the same"
    },
    {
      "code": 6027,
      "name": "InvalidBinArray",
      "msg": "Invalid bin array"
    },
    {
      "code": 6028,
      "name": "NonContinuousBinArrays",
      "msg": "Bin arrays must be continuous"
    },
    {
      "code": 6029,
      "name": "InvalidRewardVault",
      "msg": "Invalid reward vault"
    },
    {
      "code": 6030,
      "name": "NonEmptyPosition",
      "msg": "Position is not empty"
    },
    {
      "code": 6031,
      "name": "UnauthorizedAlphaAccess",
      "msg": "Unauthorized alpha access"
    },
    {
      "code": 6032,
      "name": "InvalidFeeParameter",
      "msg": "Invalid fee parameter"
    },
    {
      "code": 6033,
      "name": "MissingOracle",
      "msg": "Missing oracle account"
    },
    {
      "code": 6034,
      "name": "InsufficientSample",
      "msg": "Insufficient observation sample"
    },
    {
      "code": 6035,
      "name": "InvalidLookupTimestamp",
      "msg": "Invalid lookup timestamp"
    },
    {
      "code": 6036,
      "name": "BitmapExtensionAccountIsNotProvided",
      "msg": "Bitmap extension account is not provided"
    },
    {
      "code": 6037,
      "name": "CannotFindNonZeroLiquidityBinArrayId",
      "msg": "Cannot find non-zero liquidity binArrayId"
    },
    {
      "code": 6038,
      "name": "BinIdOutOfBound",
      "msg": "Bin id out of bound"
    },
    {
      "code": 6039,
      "name": "InsufficientOutAmount",
      "msg": "Insufficient amount in for minimum out"
    },
    {
      "code": 6040,
      "name": "InvalidPositionWidth",
      "msg": "Invalid position width"
    },
    {
      "code": 6041,
      "name": "ExcessiveFeeUpdate",
      "msg": "Excessive fee update"
    },
    {
      "code": 6042,
      "name": "PoolDisabled",
      "msg": "Pool disabled"
    },
    {
      "code": 6043,
      "name": "InvalidPoolType",
      "msg": "Invalid pool type"
    },
    {
      "code": 6044,
      "name": "ExceedMaxWhitelist",
      "msg": "Whitelist for wallet is full"
    },
    {
      "code": 6045,
      "name": "InvalidIndex",
      "msg": "Invalid index"
    },
    {
      "code": 6046,
      "name": "RewardNotEnded",
      "msg": "Reward not ended"
    },
    {
      "code": 6047,
      "name": "MustWithdrawnIneligibleReward",
      "msg": "Must withdraw ineligible reward"
    },
    {
      "code": 6048,
      "name": "UnauthorizedAddress",
      "msg": "Unauthorized address"
    },
    {
      "code": 6049,
      "name": "OperatorsAreTheSame",
      "msg": "Cannot update because operators are the same"
    },
    {
      "code": 6050,
      "name": "WithdrawToWrongTokenAccount",
      "msg": "Withdraw to wrong token account"
    },
    {
      "code": 6051,
      "name": "WrongRentReceiver",
      "msg": "Wrong rent receiver"
    }
  ]
};

// src/clmm/constants.ts

var _anchor = require('@coral-xyz/anchor');
var LBCLMM_PROGRAM_IDS = {
  devnet: "LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo",
  localhost: "LbVRzDTvBDEcrthxfZ4RL6yiq3uZw8bS6MwtdY6UhFQ",
  "mainnet-beta": "LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo"
};
var ADMIN = {
  devnet: "6WaLrrRfReGKBYUSkmx2K6AuT21ida4j8at2SUiZdXu8",
  localhost: "bossj3JvwiNK7pvjr149DqdtJxf2gdygbcmEPTkb2F1"
};
var Network = /* @__PURE__ */ ((Network2) => {
  Network2["MAINNET"] = "mainnet-beta";
  Network2["TESTNET"] = "testnet";
  Network2["DEVNET"] = "devnet";
  Network2["LOCAL"] = "localhost";
  return Network2;
})(Network || {});
var BASIS_POINT_MAX = 1e4;
var SCALE_OFFSET = 64;
var SCALE = new (0, _anchor.BN)(1).shln(SCALE_OFFSET);
var FEE_PRECISION = new (0, _anchor.BN)(1e9);
var MAX_FEE_RATE = new (0, _anchor.BN)(1e8);
var CONSTANTS = Object.entries(IDL.constants);
var MAX_BIN_ARRAY_SIZE = new (0, _anchor.BN)(CONSTANTS.find(([k, v]) => v.name == "MAX_BIN_PER_ARRAY")[1].value);
var MAX_BIN_PER_POSITION = new (0, _anchor.BN)(CONSTANTS.find(([k, v]) => v.name == "MAX_BIN_PER_POSITION")[1].value);
var SIMULATION_USER = new (0, _web3js.PublicKey)("HrY9qR5TiB2xPzzvbBu5KrBorMfYGQXh9osXydz4jy9s");
var PRECISION = 18446744073709552e3;
var MAX_CLAIM_ALL_ALLOWED = 3;
var MAX_BIN_LENGTH_ALLOWED_IN_ONE_TX = 26;
var MAX_ACTIVE_BIN_SLIPPAGE = 3;

// src/clmm/typings.ts

var _bufferlayout = require('@solana/buffer-layout');
var CONSTANTS2 = Object.entries(IDL.constants);
var PositionVersion = /* @__PURE__ */ ((PositionVersion2) => {
  PositionVersion2[PositionVersion2["V1"] = 0] = "V1";
  PositionVersion2[PositionVersion2["V2"] = 1] = "V2";
  return PositionVersion2;
})(PositionVersion || {});
var StrategyType = /* @__PURE__ */ ((StrategyType2) => {
  StrategyType2[StrategyType2["Spot"] = 0] = "Spot";
  StrategyType2[StrategyType2["Curve"] = 1] = "Curve";
  StrategyType2[StrategyType2["BidAsk"] = 2] = "BidAsk";
  return StrategyType2;
})(StrategyType || {});
var parabolicParameter = _bufferlayout.struct.call(void 0, [
  _bufferlayout.s16.call(void 0, "aAsk"),
  _bufferlayout.s16.call(void 0, "aBid"),
  _bufferlayout.s16.call(void 0, `aActiveBin`),
  _bufferlayout.s32.call(void 0, `centerBinId`)
]);
var spotParameter = _bufferlayout.struct.call(void 0, [
  _bufferlayout.u16.call(void 0, "weightAsk"),
  _bufferlayout.u16.call(void 0, "weightBid"),
  _bufferlayout.u16.call(void 0, "weightActiveBin")
]);
var BIN_ARRAY_BITMAP_SIZE = new (0, _anchor.BN)(CONSTANTS2.find(([k, v]) => v.name == "BIN_ARRAY_BITMAP_SIZE")[1].value);
var EXTENSION_BINARRAY_BITMAP_SIZE = new (0, _anchor.BN)(
  CONSTANTS2.find(([k, v]) => v.name == "EXTENSION_BINARRAY_BITMAP_SIZE")[1].value
);
var BitmapType = /* @__PURE__ */ ((BitmapType2) => {
  BitmapType2[BitmapType2["U1024"] = 0] = "U1024";
  BitmapType2[BitmapType2["U512"] = 1] = "U512";
  return BitmapType2;
})(BitmapType || {});

// src/clmm/index.ts


// src/clmm/helpers/index.ts









var _spltoken = require('@solana/spl-token');


// src/clmm/helpers/math.ts

function mulShr(x, y, offset, rounding) {
  const denominator = new (0, _anchor.BN)(1).shln(offset);
  return mulDiv(x, y, denominator, rounding);
}
function shlDiv(x, y, offset, rounding) {
  const scale = new (0, _anchor.BN)(1).shln(offset);
  return mulDiv(x, scale, y, rounding);
}
function mulDiv(x, y, denominator, rounding) {
  const { div, mod } = x.mul(y).divmod(denominator);
  if (rounding == 0 /* Up */ && !mod.isZero()) {
    return div.add(new (0, _anchor.BN)(1));
  }
  return div;
}

// src/clmm/helpers/derive.ts

function sortTokenMints(tokenX, tokenY) {
  const [minKey, maxKey] = tokenX.toBuffer().compare(tokenY.toBuffer()) == 1 ? [tokenY, tokenX] : [tokenX, tokenY];
  return [minKey, maxKey];
}
function derivePresetParameter(binStep, programId) {
  return _web3js.PublicKey.findProgramAddressSync(
    [
      Buffer.from("preset_parameter"),
      new Uint8Array(binStep.toBuffer("le", 2))
    ],
    programId
  );
}
function deriveLbPair(tokenX, tokenY, binStep, programId) {
  const [minKey, maxKey] = sortTokenMints(tokenX, tokenY);
  return _web3js.PublicKey.findProgramAddressSync(
    [minKey.toBuffer(), maxKey.toBuffer(), new Uint8Array(binStep.toBuffer("le", 2))],
    programId
  );
}
function deriveOracle(lbPair, programId) {
  return _web3js.PublicKey.findProgramAddressSync([Buffer.from("oracle"), lbPair.toBytes()], programId);
}
function derivePosition(mint, programId) {
  return _web3js.PublicKey.findProgramAddressSync([Buffer.from("position"), mint.toBuffer()], programId);
}
function deriveBinArray(lbPair, index, programId) {
  let binArrayBytes;
  if (index.isNeg()) {
    binArrayBytes = new Uint8Array(index.toTwos(64).toBuffer("le", 8));
  } else {
    binArrayBytes = new Uint8Array(index.toBuffer("le", 8));
  }
  return _web3js.PublicKey.findProgramAddressSync([Buffer.from("bin_array"), lbPair.toBytes(), binArrayBytes], programId);
}
function deriveReserve(token, lbPair, programId) {
  return _web3js.PublicKey.findProgramAddressSync([lbPair.toBuffer(), token.toBuffer()], programId);
}

// src/clmm/helpers/binArray.ts


function internalBitmapRange() {
  const lowerBinArrayIndex = BIN_ARRAY_BITMAP_SIZE.neg();
  const upperBinArrayIndex = BIN_ARRAY_BITMAP_SIZE.sub(new (0, _anchor.BN)(1));
  return [lowerBinArrayIndex, upperBinArrayIndex];
}
function buildBitmapFromU64Arrays(u64Arrays, type) {
  const buffer = Buffer.concat(
    u64Arrays.map((b) => {
      return b.toBuffer("le", 8);
    })
  );
  return new (0, _anchor.BN)(buffer, "le");
}
function bitmapTypeDetail(type) {
  if (type == 0 /* U1024 */) {
    return {
      bits: 1024,
      bytes: 1024 / 8
    };
  } else {
    return {
      bits: 512,
      bytes: 512 / 8
    };
  }
}
function mostSignificantBit(number, bitLength) {
  const highestIndex = bitLength - 1;
  if (number.isZero()) {
    return null;
  }
  for (let i = highestIndex; i >= 0; i--) {
    if (number.testn(i)) {
      return highestIndex - i;
    }
  }
  return null;
}
function leastSignificantBit(number, bitLength) {
  if (number.isZero()) {
    return null;
  }
  for (let i = 0; i < bitLength; i++) {
    if (number.testn(i)) {
      return i;
    }
  }
  return null;
}
function extensionBitmapRange() {
  return [
    BIN_ARRAY_BITMAP_SIZE.neg().mul(EXTENSION_BINARRAY_BITMAP_SIZE.add(new (0, _anchor.BN)(1))),
    BIN_ARRAY_BITMAP_SIZE.mul(EXTENSION_BINARRAY_BITMAP_SIZE.add(new (0, _anchor.BN)(1))).sub(new (0, _anchor.BN)(1))
  ];
}
function findSetBit(startIndex, endIndex, binArrayBitmapExtension) {
  const getBinArrayOffset = (binArrayIndex) => {
    return binArrayIndex > 0 ? binArrayIndex % BIN_ARRAY_BITMAP_SIZE.toNumber() - 1 : Math.abs(binArrayIndex - 1) % BIN_ARRAY_BITMAP_SIZE.toNumber();
  };
  const getBitmapOffset = (binArrayIndex) => {
    return binArrayIndex > 0 ? binArrayIndex / BIN_ARRAY_BITMAP_SIZE.toNumber() - 1 : -(binArrayIndex + 1) / BIN_ARRAY_BITMAP_SIZE.toNumber() - 1;
  };
  if (startIndex <= endIndex) {
    for (let i = startIndex; i <= endIndex; i++) {
      const binArrayOffset = getBinArrayOffset(i);
      const bitmapOffset = getBitmapOffset(i);
      const bitmapChunks = i > 0 ? binArrayBitmapExtension.positiveBinArrayBitmap[bitmapOffset] : binArrayBitmapExtension.negativeBinArrayBitmap[bitmapOffset];
      const bitmap = buildBitmapFromU64Arrays(bitmapChunks, 1 /* U512 */);
      if (bitmap.testn(binArrayOffset)) {
        return i;
      }
    }
  } else {
    for (let i = startIndex; i >= endIndex; i--) {
      const binArrayOffset = getBinArrayOffset(i);
      const bitmapOffset = getBitmapOffset(i);
      const bitmapChunks = i > 0 ? binArrayBitmapExtension.positiveBinArrayBitmap[bitmapOffset] : binArrayBitmapExtension.negativeBinArrayBitmap[bitmapOffset];
      const bitmap = buildBitmapFromU64Arrays(bitmapChunks, 1 /* U512 */);
      if (bitmap.testn(binArrayOffset)) {
        return i;
      }
    }
  }
  return null;
}
function isOverflowDefaultBinArrayBitmap(binArrayIndex) {
  const [minBinArrayIndex, maxBinArrayIndex] = internalBitmapRange();
  return binArrayIndex.gt(maxBinArrayIndex) || binArrayIndex.lt(minBinArrayIndex);
}
function deriveBinArrayBitmapExtension(lbPair, programId) {
  return _web3js.PublicKey.findProgramAddressSync([Buffer.from("bitmap"), lbPair.toBytes()], programId);
}
function binIdToBinArrayIndex(binId) {
  const { div: idx, mod } = binId.divmod(MAX_BIN_ARRAY_SIZE);
  return binId.isNeg() && !mod.isZero() ? idx.sub(new (0, _anchor.BN)(1)) : idx;
}
function getBinArrayLowerUpperBinId(binArrayIndex) {
  const lowerBinId = binArrayIndex.mul(MAX_BIN_ARRAY_SIZE);
  const upperBinId = lowerBinId.add(MAX_BIN_ARRAY_SIZE).sub(new (0, _anchor.BN)(1));
  return [lowerBinId, upperBinId];
}
function isBinIdWithinBinArray(activeId, binArrayIndex) {
  const [lowerBinId, upperBinId] = getBinArrayLowerUpperBinId(binArrayIndex);
  return activeId.gte(lowerBinId) && activeId.lte(upperBinId);
}
function getBinFromBinArray(binId, binArray) {
  const [lowerBinId, upperBinId] = getBinArrayLowerUpperBinId(binArray.index);
  let index = 0;
  if (binId > 0) {
    index = binId - lowerBinId.toNumber();
  } else {
    const delta = upperBinId.toNumber() - binId;
    index = MAX_BIN_ARRAY_SIZE.toNumber() - delta - 1;
  }
  return binArray.bins[index];
}
function findNextBinArrayIndexWithLiquidity(swapForY, activeId, lbPairState, binArrayBitmapExtension) {
  const [lowerBinArrayIndex, upperBinArrayIndex] = internalBitmapRange();
  let startBinArrayIndex = binIdToBinArrayIndex(activeId);
  while (true) {
    if (isOverflowDefaultBinArrayBitmap(startBinArrayIndex)) {
      if (binArrayBitmapExtension == null) {
        return null;
      }
      const [minBinArrayIndex, maxBinArrayIndex] = extensionBitmapRange();
      if (startBinArrayIndex.isNeg()) {
        if (swapForY) {
          const binArrayIndex = findSetBit(
            startBinArrayIndex.toNumber(),
            minBinArrayIndex.toNumber(),
            binArrayBitmapExtension
          );
          if (binArrayIndex != null) {
            return new (0, _anchor.BN)(binArrayIndex);
          } else {
            return null;
          }
        } else {
          const binArrayIndex = findSetBit(
            startBinArrayIndex.toNumber(),
            BIN_ARRAY_BITMAP_SIZE.neg().sub(new (0, _anchor.BN)(1)).toNumber(),
            binArrayBitmapExtension
          );
          if (binArrayIndex != null) {
            return new (0, _anchor.BN)(binArrayIndex);
          } else {
            startBinArrayIndex = BIN_ARRAY_BITMAP_SIZE.neg();
          }
        }
      } else {
        if (swapForY) {
          const binArrayIndex = findSetBit(
            startBinArrayIndex.toNumber(),
            BIN_ARRAY_BITMAP_SIZE.toNumber(),
            binArrayBitmapExtension
          );
          if (binArrayIndex != null) {
            return new (0, _anchor.BN)(binArrayIndex);
          } else {
            startBinArrayIndex = BIN_ARRAY_BITMAP_SIZE;
          }
        } else {
          const binArrayIndex = findSetBit(
            startBinArrayIndex.toNumber(),
            maxBinArrayIndex.toNumber(),
            binArrayBitmapExtension
          );
          if (binArrayIndex != null) {
            return new (0, _anchor.BN)(binArrayIndex);
          } else {
            return null;
          }
        }
      }
    } else {
      const bitmapType = 0 /* U1024 */;
      const bitmapDetail = bitmapTypeDetail(bitmapType);
      const offset = startBinArrayIndex.add(BIN_ARRAY_BITMAP_SIZE);
      const bitmap = buildBitmapFromU64Arrays(lbPairState.binArrayBitmap, bitmapType);
      if (swapForY) {
        const upperBitRange = new (0, _anchor.BN)(bitmapDetail.bits - 1).sub(offset);
        const croppedBitmap = bitmap.shln(upperBitRange.toNumber());
        const msb = mostSignificantBit(croppedBitmap, bitmapDetail.bits);
        if (msb != null) {
          return startBinArrayIndex.sub(new (0, _anchor.BN)(msb));
        } else {
          startBinArrayIndex = lowerBinArrayIndex.sub(new (0, _anchor.BN)(1));
        }
      } else {
        const lowerBitRange = offset;
        const croppedBitmap = bitmap.shrn(lowerBitRange.toNumber());
        const lsb = leastSignificantBit(croppedBitmap, bitmapDetail.bits);
        if (lsb != null) {
          return startBinArrayIndex.add(new (0, _anchor.BN)(lsb));
        } else {
          startBinArrayIndex = upperBinArrayIndex.add(new (0, _anchor.BN)(1));
        }
      }
    }
  }
}
function findNextBinArrayWithLiquidity(swapForY, activeBinId, lbPairState, binArrayBitmapExtension, binArrays) {
  const nearestBinArrayIndexWithLiquidity = findNextBinArrayIndexWithLiquidity(
    swapForY,
    activeBinId,
    lbPairState,
    binArrayBitmapExtension
  );
  if (nearestBinArrayIndexWithLiquidity == null) {
    return null;
  }
  const binArrayAccount = binArrays.find((ba) => ba.account.index.eq(nearestBinArrayIndexWithLiquidity));
  if (!binArrayAccount) {
    throw new Error("Bin array not found based on indexing");
  }
  return binArrayAccount;
}

// src/clmm/helpers/strategy.ts

var _gaussian = require('gaussian'); var _gaussian2 = _interopRequireDefault(_gaussian);
var _decimaljs = require('decimal.js'); var _decimaljs2 = _interopRequireDefault(_decimaljs);
function getPriceOfBinByBinId(binId, binStep) {
  const binStepNum = new (0, _decimaljs2.default)(binStep).div(new (0, _decimaljs2.default)(BASIS_POINT_MAX));
  return new (0, _decimaljs2.default)(1).add(new (0, _decimaljs2.default)(binStepNum)).pow(new (0, _decimaljs2.default)(binId));
}
function buildGaussianFromBins(activeBin, binIds) {
  const smallestBin = Math.min(...binIds);
  const largestBin = Math.max(...binIds);
  let mean = 0;
  const isAroundActiveBin = binIds.find((bid) => bid == activeBin);
  if (isAroundActiveBin) {
    mean = activeBin;
  } else if (activeBin < smallestBin) {
    mean = smallestBin;
  } else {
    mean = largestBin;
  }
  const TWO_STANDARD_DEVIATION = 4;
  const stdDev = (largestBin - smallestBin) / TWO_STANDARD_DEVIATION;
  const variance = Math.max(stdDev ** 2, 1);
  return _gaussian2.default.call(void 0, mean, variance);
}
function generateBinLiquidityAllocation(gaussian2, binIds, invert) {
  const allocations = binIds.map((bid) => invert ? 1 / gaussian2.pdf(bid) : gaussian2.pdf(bid));
  const totalAllocations = allocations.reduce((acc, v) => acc + v, 0);
  return allocations.map((a) => a / totalAllocations);
}
function computeAllocationBps(allocations) {
  let totalAllocation = new (0, _anchor.BN)(0);
  const bpsAllocations = [];
  for (const allocation of allocations) {
    const allocBps = new (0, _anchor.BN)(allocation * 1e4);
    bpsAllocations.push(allocBps);
    totalAllocation = totalAllocation.add(allocBps);
  }
  const pLoss = new (0, _anchor.BN)(1e4).sub(totalAllocation);
  return {
    bpsAllocations,
    pLoss
  };
}
function toWeightDistribution(amountX, amountY, distributions, binStep) {
  let totalQuote = new (0, _anchor.BN)(0);
  const precision = 1e12;
  const quoteDistributions = distributions.map((bin) => {
    const price = new (0, _anchor.BN)(getPriceOfBinByBinId(bin.binId, binStep).mul(precision).floor().toString());
    const quoteValue = amountX.mul(new (0, _anchor.BN)(bin.xAmountBpsOfTotal)).mul(new (0, _anchor.BN)(price)).div(new (0, _anchor.BN)(BASIS_POINT_MAX)).div(new (0, _anchor.BN)(precision));
    const quoteAmount = quoteValue.add(amountY.mul(new (0, _anchor.BN)(bin.yAmountBpsOfTotal)).div(new (0, _anchor.BN)(BASIS_POINT_MAX)));
    totalQuote = totalQuote.add(quoteAmount);
    return {
      binId: bin.binId,
      quoteAmount
    };
  });
  if (totalQuote.eq(new (0, _anchor.BN)(0))) {
    return [];
  }
  const distributionWeights = quoteDistributions.map((bin) => {
    const weight = Math.floor(bin.quoteAmount.mul(new (0, _anchor.BN)(65535)).div(totalQuote).toNumber());
    return {
      binId: bin.binId,
      weight
    };
  }).filter((item) => item.weight > 0);
  return distributionWeights;
}
function fromWeightDistributionToAmount(amountX, amountY, distributions, binStep, activeId, amountXInActiveBin, amountYInActiveBin) {
  var distributions = distributions.sort((n1, n2) => {
    return n1.binId - n2.binId;
  }).filter((item) => item.weight > 0);
  if (distributions.length == 0) {
    return [];
  }
  if (activeId > distributions[distributions.length - 1].binId) {
    let totalWeight = distributions.reduce(function(sum, el) {
      return sum + el.weight;
    }, 0);
    return distributions.map((bin) => {
      const amount = amountX.mul(new (0, _anchor.BN)(bin.weight)).div(new (0, _anchor.BN)(totalWeight));
      return {
        binId: bin.binId,
        amountX: new (0, _anchor.BN)(0),
        amountY: amount
      };
    });
  }
  if (activeId < distributions[0].binId) {
    let totalWeight = distributions.reduce(function(sum, el) {
      let price = getPriceOfBinByBinId(el.binId, binStep);
      let weighPerPrice = new (0, _decimaljs2.default)(el.weight).div(price);
      return sum.add(weighPerPrice);
    }, new (0, _decimaljs2.default)(0));
    return distributions.map((bin) => {
      const amount = new (0, _decimaljs2.default)(amountX.toNumber()).mul(new (0, _decimaljs2.default)(bin.weight)).div(totalWeight);
      return {
        binId: bin.binId,
        amountX: new (0, _anchor.BN)(Math.floor(amount.toNumber())),
        amountY: new (0, _anchor.BN)(0)
      };
    });
  }
  const activeBins = distributions.filter((element) => {
    return element.binId === activeId;
  });
  if (activeBins.length == 1) {
    let p0 = getPriceOfBinByBinId(activeId, binStep);
    let wx0 = new (0, _decimaljs2.default)(0);
    let wy0 = new (0, _decimaljs2.default)(0);
    let activeBin = activeBins[0];
    if (amountXInActiveBin.isZero() && amountYInActiveBin.isZero()) {
      wx0 = new (0, _decimaljs2.default)(activeBin.weight).div(p0.mul(new (0, _decimaljs2.default)(2)));
      wy0 = new (0, _decimaljs2.default)(activeBin.weight).div(new (0, _decimaljs2.default)(2));
    } else {
      let amountXInActiveBinDec = new (0, _decimaljs2.default)(amountYInActiveBin.toNumber());
      let amountYInActiveBinDec = new (0, _decimaljs2.default)(amountYInActiveBin.toNumber());
      if (!amountXInActiveBin.isZero()) {
        wx0 = new (0, _decimaljs2.default)(activeBin.weight).div(p0.add(amountXInActiveBinDec.div(amountYInActiveBinDec)));
      }
      if (!amountYInActiveBin.isZero()) {
        wy0 = new (0, _decimaljs2.default)(activeBin.weight).div(new (0, _decimaljs2.default)(1).add(p0.mul(amountXInActiveBinDec).div(amountYInActiveBinDec)));
      }
    }
    let totalWeightX = wx0;
    let totalWeightY = wy0;
    distributions.forEach((element) => {
      if (element.binId < activeId) {
        totalWeightY = totalWeightY.add(new (0, _decimaljs2.default)(element.weight));
      }
      if (element.binId > activeId) {
        let price = getPriceOfBinByBinId(element.binId, binStep);
        let weighPerPrice = new (0, _decimaljs2.default)(element.weight).div(price);
        totalWeightX = totalWeightX.add(weighPerPrice);
      }
    });
    let kx = new (0, _decimaljs2.default)(amountX.toNumber()).div(totalWeightX);
    let ky = new (0, _decimaljs2.default)(amountY.toNumber()).div(totalWeightY);
    let k = kx.lessThan(ky) ? kx : ky;
    return distributions.map((bin) => {
      if (bin.binId < activeId) {
        const amount = k.mul(new (0, _decimaljs2.default)(bin.weight));
        return {
          binId: bin.binId,
          amountX: new (0, _anchor.BN)(0),
          amountY: new (0, _anchor.BN)(Math.floor(amount.toNumber()))
        };
      }
      if (bin.binId > activeId) {
        let price = getPriceOfBinByBinId(bin.binId, binStep);
        let weighPerPrice = new (0, _decimaljs2.default)(bin.weight).div(price);
        const amount = k.mul(weighPerPrice);
        return {
          binId: bin.binId,
          amountX: new (0, _anchor.BN)(Math.floor(amount.toNumber())),
          amountY: new (0, _anchor.BN)(0)
        };
      }
      let amounXActiveBin = k.mul(wx0);
      let amounYActiveBin = k.mul(wy0);
      return {
        binId: bin.binId,
        amountX: new (0, _anchor.BN)(Math.floor(amounXActiveBin.toNumber())),
        amountY: new (0, _anchor.BN)(Math.floor(amounYActiveBin.toNumber()))
      };
    });
  } else {
    let totalWeightX = new (0, _decimaljs2.default)(0);
    let totalWeightY = new (0, _decimaljs2.default)(0);
    distributions.forEach((element) => {
      if (element.binId < activeId) {
        totalWeightY = totalWeightY.add(new (0, _decimaljs2.default)(element.weight));
      } else {
        let price = getPriceOfBinByBinId(element.binId, binStep);
        let weighPerPrice = new (0, _decimaljs2.default)(element.weight).div(price);
        totalWeightX = totalWeightX.add(weighPerPrice);
      }
    });
    let kx = new (0, _decimaljs2.default)(amountX.toNumber()).div(totalWeightX);
    let ky = new (0, _decimaljs2.default)(amountY.toNumber()).div(totalWeightY);
    let k = kx.lessThan(ky) ? kx : ky;
    return distributions.map((bin) => {
      if (bin.binId < activeId) {
        const amount = k.mul(new (0, _decimaljs2.default)(bin.weight));
        return {
          binId: bin.binId,
          amountX: new (0, _anchor.BN)(0),
          amountY: new (0, _anchor.BN)(Math.floor(amount.toNumber()))
        };
      } else {
        let price = getPriceOfBinByBinId(bin.binId, binStep);
        let weighPerPrice = new (0, _decimaljs2.default)(bin.weight).div(price);
        const amount = k.mul(weighPerPrice);
        return {
          binId: bin.binId,
          amountX: new (0, _anchor.BN)(Math.floor(amount.toNumber())),
          amountY: new (0, _anchor.BN)(0)
        };
      }
    });
  }
  return [];
}
function calculateSpotDistribution(activeBin, binIds) {
  if (!binIds.includes(activeBin)) {
    const { div: dist, mod: rem } = new (0, _anchor.BN)(1e4).divmod(new (0, _anchor.BN)(binIds.length));
    const loss = rem.isZero() ? new (0, _anchor.BN)(0) : new (0, _anchor.BN)(1);
    const distributions = binIds[0] < activeBin ? binIds.map((binId) => ({
      binId,
      xAmountBpsOfTotal: new (0, _anchor.BN)(0),
      yAmountBpsOfTotal: dist
    })) : binIds.map((binId) => ({
      binId,
      xAmountBpsOfTotal: dist,
      yAmountBpsOfTotal: new (0, _anchor.BN)(0)
    }));
    if (binIds[0] < activeBin) {
      distributions[0].yAmountBpsOfTotal.add(loss);
    } else {
      distributions[binIds.length - 1].xAmountBpsOfTotal.add(loss);
    }
    return distributions;
  }
  const binYCount = binIds.filter((binId) => binId < activeBin).length;
  const binXCount = binIds.filter((binId) => binId > activeBin).length;
  const totalYBinCapacity = binYCount + 0.5;
  const totalXBinCapacity = binXCount + 0.5;
  const yBinBps = new (0, _anchor.BN)(1e4 / totalYBinCapacity);
  const yActiveBinBps = new (0, _anchor.BN)(1e4).sub(yBinBps.mul(new (0, _anchor.BN)(binYCount)));
  const xBinBps = new (0, _anchor.BN)(1e4 / totalXBinCapacity);
  const xActiveBinBps = new (0, _anchor.BN)(1e4).sub(xBinBps.mul(new (0, _anchor.BN)(binXCount)));
  return binIds.map((binId) => {
    const isYBin = binId < activeBin;
    const isXBin = binId > activeBin;
    const isActiveBin = binId === activeBin;
    if (isYBin) {
      return {
        binId,
        xAmountBpsOfTotal: new (0, _anchor.BN)(0),
        yAmountBpsOfTotal: yBinBps
      };
    }
    if (isXBin) {
      return {
        binId,
        xAmountBpsOfTotal: xBinBps,
        yAmountBpsOfTotal: new (0, _anchor.BN)(0)
      };
    }
    if (isActiveBin) {
      return {
        binId,
        xAmountBpsOfTotal: xActiveBinBps,
        yAmountBpsOfTotal: yActiveBinBps
      };
    }
  });
}
function calculateBidAskDistribution(activeBin, binIds) {
  const smallestBin = Math.min(...binIds);
  const largestBin = Math.max(...binIds);
  const rightOnly = activeBin < smallestBin;
  const leftOnly = activeBin > largestBin;
  const gaussian2 = buildGaussianFromBins(activeBin, binIds);
  const allocations = generateBinLiquidityAllocation(gaussian2, binIds, true);
  if (rightOnly) {
    const { bpsAllocations, pLoss } = computeAllocationBps(allocations);
    const binDistributions = binIds.map((bid, idx2) => ({
      binId: bid,
      xAmountBpsOfTotal: bpsAllocations[idx2],
      yAmountBpsOfTotal: new (0, _anchor.BN)(0)
    }));
    const idx = binDistributions.length - 1;
    binDistributions[idx].xAmountBpsOfTotal = binDistributions[idx].xAmountBpsOfTotal.add(pLoss);
    return binDistributions;
  }
  if (leftOnly) {
    const { bpsAllocations, pLoss } = computeAllocationBps(allocations);
    const binDistributions = binIds.map((bid, idx) => ({
      binId: bid,
      xAmountBpsOfTotal: new (0, _anchor.BN)(0),
      yAmountBpsOfTotal: bpsAllocations[idx]
    }));
    binDistributions[0].yAmountBpsOfTotal = binDistributions[0].yAmountBpsOfTotal.add(pLoss);
    return binDistributions;
  }
  const [totalXAllocation, totalYAllocation] = allocations.reduce(
    ([xAcc, yAcc], allocation, idx) => {
      const binId = binIds[idx];
      if (binId > activeBin) {
        return [xAcc + allocation, yAcc];
      } else if (binId < activeBin) {
        return [xAcc, yAcc + allocation];
      } else {
        const half = allocation / 2;
        return [xAcc + half, yAcc + half];
      }
    },
    [0, 0]
  );
  const [normXAllocations, normYAllocations] = allocations.reduce(
    ([xAllocations, yAllocations], allocation, idx) => {
      const binId = binIds[idx];
      if (binId > activeBin) {
        const distX = new (0, _anchor.BN)(allocation * 1e4 / totalXAllocation);
        xAllocations.push(distX);
      }
      if (binId < activeBin) {
        const distY = new (0, _anchor.BN)(allocation * 1e4 / totalYAllocation);
        yAllocations.push(distY);
      }
      if (binId == activeBin) {
        const half = allocation / 2;
        const distX = new (0, _anchor.BN)(half * 1e4 / totalXAllocation);
        const distY = new (0, _anchor.BN)(half * 1e4 / totalYAllocation);
        xAllocations.push(distX);
        yAllocations.push(distY);
      }
      return [xAllocations, yAllocations];
    },
    [[], []]
  );
  const totalXNormAllocations = normXAllocations.reduce((acc, v) => acc.add(v), new (0, _anchor.BN)(0));
  const totalYNormAllocations = normYAllocations.reduce((acc, v) => acc.add(v), new (0, _anchor.BN)(0));
  const xPLoss = new (0, _anchor.BN)(1e4).sub(totalXNormAllocations);
  const yPLoss = new (0, _anchor.BN)(1e4).sub(totalYNormAllocations);
  const distributions = binIds.map((binId) => {
    if (binId === activeBin) {
      return {
        binId,
        xAmountBpsOfTotal: normXAllocations.shift(),
        yAmountBpsOfTotal: normYAllocations.shift()
      };
    }
    if (binId > activeBin) {
      return {
        binId,
        xAmountBpsOfTotal: normXAllocations.shift(),
        yAmountBpsOfTotal: new (0, _anchor.BN)(0)
      };
    }
    if (binId < activeBin) {
      return {
        binId,
        xAmountBpsOfTotal: new (0, _anchor.BN)(0),
        yAmountBpsOfTotal: normYAllocations.shift()
      };
    }
  });
  if (!yPLoss.isZero()) {
    distributions[0].yAmountBpsOfTotal = distributions[0].yAmountBpsOfTotal.add(yPLoss);
  }
  if (!xPLoss.isZero()) {
    const last = distributions.length - 1;
    distributions[last].xAmountBpsOfTotal = distributions[last].xAmountBpsOfTotal.add(xPLoss);
  }
  return distributions;
}
function calculateNormalDistribution(activeBin, binIds) {
  const smallestBin = Math.min(...binIds);
  const largestBin = Math.max(...binIds);
  const rightOnly = activeBin < smallestBin;
  const leftOnly = activeBin > largestBin;
  const gaussian2 = buildGaussianFromBins(activeBin, binIds);
  const allocations = generateBinLiquidityAllocation(gaussian2, binIds, false);
  if (rightOnly) {
    const { bpsAllocations, pLoss } = computeAllocationBps(allocations);
    const binDistributions = binIds.map((bid, idx) => ({
      binId: bid,
      xAmountBpsOfTotal: bpsAllocations[idx],
      yAmountBpsOfTotal: new (0, _anchor.BN)(0)
    }));
    binDistributions[0].xAmountBpsOfTotal = binDistributions[0].xAmountBpsOfTotal.add(pLoss);
    return binDistributions;
  }
  if (leftOnly) {
    const { bpsAllocations, pLoss } = computeAllocationBps(allocations);
    const binDistributions = binIds.map((bid, idx2) => ({
      binId: bid,
      xAmountBpsOfTotal: new (0, _anchor.BN)(0),
      yAmountBpsOfTotal: bpsAllocations[idx2]
    }));
    const idx = binDistributions.length - 1;
    binDistributions[idx].yAmountBpsOfTotal = binDistributions[idx].yAmountBpsOfTotal.add(pLoss);
    return binDistributions;
  }
  const [totalXAllocation, totalYAllocation] = allocations.reduce(
    ([xAcc, yAcc], allocation, idx) => {
      const binId = binIds[idx];
      if (binId > activeBin) {
        return [xAcc + allocation, yAcc];
      } else if (binId < activeBin) {
        return [xAcc, yAcc + allocation];
      } else {
        const half = allocation / 2;
        return [xAcc + half, yAcc + half];
      }
    },
    [0, 0]
  );
  const [normXAllocations, normYAllocations] = allocations.reduce(
    ([xAllocations, yAllocations], allocation, idx) => {
      const binId = binIds[idx];
      if (binId > activeBin) {
        const distX = new (0, _anchor.BN)(allocation * 1e4 / totalXAllocation);
        xAllocations.push(distX);
      }
      if (binId < activeBin) {
        const distY = new (0, _anchor.BN)(allocation * 1e4 / totalYAllocation);
        yAllocations.push(distY);
      }
      return [xAllocations, yAllocations];
    },
    [[], []]
  );
  const normXActiveBinAllocation = normXAllocations.reduce((maxBps, bps) => maxBps.sub(bps), new (0, _anchor.BN)(1e4));
  const normYActiveBinAllocation = normYAllocations.reduce((maxBps, bps) => maxBps.sub(bps), new (0, _anchor.BN)(1e4));
  return binIds.map((binId) => {
    if (binId === activeBin) {
      return {
        binId,
        xAmountBpsOfTotal: normXActiveBinAllocation,
        yAmountBpsOfTotal: normYActiveBinAllocation
      };
    }
    if (binId > activeBin) {
      return {
        binId,
        xAmountBpsOfTotal: normXAllocations.shift(),
        yAmountBpsOfTotal: new (0, _anchor.BN)(0)
      };
    }
    if (binId < activeBin) {
      return {
        binId,
        xAmountBpsOfTotal: new (0, _anchor.BN)(0),
        yAmountBpsOfTotal: normYAllocations.shift()
      };
    }
  });
}
function fromStrategyParamstoWeightDistribution(activeId, strategyParameters) {
  const { maxBinId, minBinId, strategyType, aAsk, aBid, aActiveBin, centerBinId, weightAsk, weightBid, weightActiveBin } = strategyParameters;
  if (maxBinId < minBinId) {
    throw new Error("maxBinId cannot be smaller than minBinId");
  }
  let distributionWeights = [];
  switch (strategyType) {
    case 0 /* Spot */: {
      for (let i = minBinId; i <= maxBinId; i++) {
        if (i < activeId) {
          distributionWeights.push({
            binId: i,
            weight: weightBid
          });
        }
        if (i > activeId) {
          distributionWeights.push({
            binId: i,
            weight: weightAsk
          });
        }
        if (i == activeId) {
          distributionWeights.push({
            binId: i,
            weight: weightActiveBin
          });
        }
      }
      break;
    }
    case 1 /* Curve */: {
      if (aAsk > 0 || aAsk < -32768) {
        throw new Error("aAsk is out of range");
      }
      if (aBid > 0 || aBid < -32768) {
        throw new Error("aBid is out of range");
      }
      const midBinId = centerBinId;
      const binWidth = maxBinId - minBinId;
      const b = binWidth * binWidth;
      for (let i = minBinId; i <= maxBinId; i++) {
        let binDelta = i - midBinId;
        let a = aActiveBin;
        if (i < activeId) {
          a = aBid;
        } else if (i > activeId) {
          a = aAsk;
        }
        distributionWeights.push({
          binId: i,
          weight: Math.max(Math.floor(a * binDelta * binDelta - a * b) / 15e3, 0)
        });
      }
      break;
    }
    case 2 /* BidAsk */: {
      if (aAsk < 0 || aAsk > 32768) {
        throw new Error("aAsk is out of range");
      }
      if (aBid < 0 || aBid > 32768) {
        throw new Error("aBid is out of range");
      }
      const midBinId = centerBinId;
      for (let i = minBinId; i <= maxBinId; i++) {
        let binDelta = i - midBinId;
        let a = aActiveBin;
        if (i < activeId) {
          a = aBid;
        } else if (i > activeId) {
          a = aAsk;
        }
        distributionWeights.push({
          binId: i,
          weight: Math.max(Math.floor(a * binDelta * binDelta) / 15e3, 0)
        });
      }
      break;
    }
  }
  return distributionWeights;
}
function toStrategyParameters(strategyParameters) {
  const { maxBinId, minBinId, strategyType, aAsk, aBid, aActiveBin, centerBinId, weightAsk, weightBid, weightActiveBin } = strategyParameters;
  switch (strategyType) {
    case 0 /* Spot */: {
      const data2 = Buffer.alloc(spotParameter.span);
      spotParameter.encode(
        {
          weightAsk,
          weightBid,
          weightActiveBin
        },
        data2
      );
      let parameters2 = Buffer.concat([data2, Buffer.from(new Array(58).fill(0))]);
      return {
        minBinId,
        maxBinId,
        strategyType: { spot: {} },
        parameteres: parameters2.toJSON().data
      };
    }
    case 1 /* Curve */: {
      const data2 = Buffer.alloc(parabolicParameter.span);
      parabolicParameter.encode(
        {
          aAsk,
          aBid,
          aActiveBin,
          centerBinId
        },
        data2
      );
      let parameters2 = Buffer.concat([data2, Buffer.from(new Array(54).fill(0))]);
      return {
        minBinId,
        maxBinId,
        strategyType: { curve: {} },
        parameteres: parameters2.toJSON().data
      };
    }
    case 2 /* BidAsk */:
      const data = Buffer.alloc(parabolicParameter.span);
      parabolicParameter.encode(
        {
          aAsk,
          aBid,
          aActiveBin,
          centerBinId
        },
        data
      );
      let parameters = Buffer.concat([data, Buffer.from(new Array(54).fill(0))]);
      return {
        minBinId,
        maxBinId,
        strategyType: { bidAsk: {} },
        parameteres: parameters.toJSON().data
      };
  }
}

// src/clmm/helpers/fee.ts

function getBaseFee(binStep, sParameter) {
  return new (0, _anchor.BN)(sParameter.baseFactor).mul(new (0, _anchor.BN)(binStep)).mul(new (0, _anchor.BN)(10));
}
function getVariableFee(binStep, sParameter, vParameter) {
  if (sParameter.variableFeeControl > 0) {
    const square_vfa_bin = new (0, _anchor.BN)(vParameter.volatilityAccumulator).mul(new (0, _anchor.BN)(binStep)).pow(new (0, _anchor.BN)(2));
    const v_fee = new (0, _anchor.BN)(sParameter.variableFeeControl).mul(square_vfa_bin);
    return v_fee.add(new (0, _anchor.BN)(99999999999)).div(new (0, _anchor.BN)(1e11));
  }
  return new (0, _anchor.BN)(0);
}
function getTotalFee(binStep, sParameter, vParameter) {
  const totalFee = getBaseFee(binStep, sParameter).add(getVariableFee(binStep, sParameter, vParameter));
  return totalFee.gt(MAX_FEE_RATE) ? MAX_FEE_RATE : totalFee;
}
function computeFee(binStep, sParameter, vParameter, inAmount) {
  const totalFee = getTotalFee(binStep, sParameter, vParameter);
  const denominator = FEE_PRECISION.sub(totalFee);
  return inAmount.mul(totalFee).add(denominator).sub(new (0, _anchor.BN)(1)).div(denominator);
}
function computeFeeFromAmount(binStep, sParameter, vParameter, inAmountWithFees) {
  const totalFee = getTotalFee(binStep, sParameter, vParameter);
  return inAmountWithFees.mul(totalFee).add(FEE_PRECISION.sub(new (0, _anchor.BN)(1))).div(FEE_PRECISION);
}
function computeProtocolFee(feeAmount, sParameter) {
  return feeAmount.mul(new (0, _anchor.BN)(sParameter.protocolShare)).div(new (0, _anchor.BN)(BASIS_POINT_MAX));
}
function swapQuoteAtBin(bin, binStep, sParameter, vParameter, inAmount, swapForY) {
  if (swapForY && bin.amountY.isZero()) {
    return {
      amountIn: new (0, _anchor.BN)(0),
      amountOut: new (0, _anchor.BN)(0),
      fee: new (0, _anchor.BN)(0),
      protocolFee: new (0, _anchor.BN)(0)
    };
  }
  if (!swapForY && bin.amountX.isZero()) {
    return {
      amountIn: new (0, _anchor.BN)(0),
      amountOut: new (0, _anchor.BN)(0),
      fee: new (0, _anchor.BN)(0),
      protocolFee: new (0, _anchor.BN)(0)
    };
  }
  let maxAmountOut;
  let maxAmountIn;
  if (swapForY) {
    maxAmountOut = bin.amountY;
    maxAmountIn = shlDiv(bin.amountY, bin.price, SCALE_OFFSET, 0 /* Up */);
  } else {
    maxAmountOut = bin.amountX;
    maxAmountIn = mulShr(bin.amountX, bin.price, SCALE_OFFSET, 0 /* Up */);
  }
  const maxFee = computeFee(binStep, sParameter, vParameter, maxAmountIn);
  maxAmountIn = maxAmountIn.add(maxFee);
  let amountInWithFees;
  let amountOut;
  let fee;
  let protocolFee;
  if (inAmount.gt(maxAmountIn)) {
    amountInWithFees = maxAmountIn;
    amountOut = maxAmountOut;
    fee = maxFee;
    protocolFee = computeProtocolFee(maxFee, sParameter);
  } else {
    fee = computeFeeFromAmount(binStep, sParameter, vParameter, inAmount);
    const amountInAfterFee = inAmount.sub(fee);
    const computedOutAmount = getOutAmount(bin, amountInAfterFee, swapForY);
    amountOut = computedOutAmount.gt(maxAmountOut) ? maxAmountOut : computedOutAmount;
    protocolFee = computeProtocolFee(fee, sParameter);
    amountInWithFees = inAmount;
  }
  return {
    amountIn: amountInWithFees,
    amountOut,
    fee,
    protocolFee
  };
}

// src/clmm/helpers/index.ts
function chunks(array, size) {
  return Array.apply(0, new Array(Math.ceil(array.length / size))).map(
    (_, index) => array.slice(index * size, (index + 1) * size)
  );
}
async function chunkedFetchMultiplePoolAccount(program, pks, chunkSize = 100) {
  const accounts = (await Promise.all(chunks(pks, chunkSize).map((chunk) => program.account.lbPair.fetchMultiple(chunk)))).flat();
  return accounts.filter(Boolean);
}
async function chunkedFetchMultipleBinArrayBitmapExtensionAccount(program, pks, chunkSize = 100) {
  const accounts = (await Promise.all(
    chunks(pks, chunkSize).map((chunk) => program.account.binArrayBitmapExtension.fetchMultiple(chunk))
  )).flat();
  return accounts;
}
function getOutAmount(bin, inAmount, swapForY) {
  return swapForY ? mulShr(inAmount, bin.price, SCALE_OFFSET, 1 /* Down */) : shlDiv(inAmount, bin.price, SCALE_OFFSET, 1 /* Down */);
}
async function getTokenDecimals(conn, mint) {
  const token = await _spltoken.getMint.call(void 0, conn, mint);
  return await token.decimals;
}
var getOrCreateATAInstruction = async (connection, tokenMint, owner, payer = owner, allowOwnerOffCurve = true) => {
  try {
    const toAccount = await _spltoken.getAssociatedTokenAddress.call(void 0, tokenMint, owner, allowOwnerOffCurve);
    const account = await connection.getAccountInfo(toAccount);
    if (account)
      return { ataPubKey: toAccount, ix: void 0 };
    const ix = _spltoken.createAssociatedTokenAccountInstruction.call(void 0, payer, toAccount, owner, tokenMint);
    return { ataPubKey: toAccount, ix };
  } catch (e) {
    console.error("Error::getOrCreateATAInstruction", e);
    throw e;
  }
};
async function getTokenBalance(conn, tokenAccount) {
  const acc = await _spltoken.getAccount.call(void 0, conn, tokenAccount);
  return acc.amount;
}
var parseLogs = (eventParser, logs) => {
  if (!logs.length)
    throw new Error("No logs found");
  for (const event of _optionalChain([eventParser, 'optionalAccess', _2 => _2.parseLogs, 'call', _3 => _3(logs)])) {
    return event.data;
  }
  throw new Error("No events found");
};
var wrapSOLInstruction = (from, to, amount) => {
  return [
    _web3js.SystemProgram.transfer({
      fromPubkey: from,
      toPubkey: to,
      lamports: amount
    }),
    new (0, _web3js.TransactionInstruction)({
      keys: [
        {
          pubkey: to,
          isSigner: false,
          isWritable: true
        }
      ],
      data: Buffer.from(new Uint8Array([17])),
      programId: _spltoken.TOKEN_PROGRAM_ID
    })
  ];
};
var unwrapSOLInstruction = async (owner) => {
  const wSolATAAccount = _spltoken.getAssociatedTokenAddressSync.call(void 0, _spltoken.NATIVE_MINT, owner);
  if (wSolATAAccount) {
    const closedWrappedSolInstruction = _spltoken.createCloseAccountInstruction.call(void 0, 
      wSolATAAccount,
      owner,
      owner,
      [],
      _spltoken.TOKEN_PROGRAM_ID
    );
    return closedWrappedSolInstruction;
  }
  return null;
};
async function chunkedGetMultipleAccountInfos(connection, pks, chunkSize = 100) {
  const accountInfos = (await Promise.all(chunks(pks, chunkSize).map((chunk) => connection.getMultipleAccountsInfo(chunk)))).flat();
  return accountInfos;
}
var computeBudgetIx = () => {
  return _web3js.ComputeBudgetProgram.setComputeUnitLimit({
    units: 14e5
  });
};

// src/clmm/index.ts
var _bytes = require('@coral-xyz/anchor/dist/cjs/utils/bytes');



// src/clmm/error.ts

var DLMMError = class extends Error {
  
  
  
  constructor(error) {
    let _errorCode = 0;
    let _errorName = "Something went wrong";
    let _errorMessage = "Something went wrong";
    if (error instanceof Error) {
      const anchorError = _anchor.AnchorError.parse(JSON.parse(JSON.stringify(error)).logs);
      if (_optionalChain([anchorError, 'optionalAccess', _4 => _4.program, 'access', _5 => _5.toBase58, 'call', _6 => _6()]) === LBCLMM_PROGRAM_IDS["mainnet-beta"]) {
        _errorCode = anchorError.error.errorCode.number;
        _errorName = anchorError.error.errorCode.code;
        _errorMessage = anchorError.error.errorMessage;
      }
    } else {
      const idlError = IDL.errors.find((err) => err.code === error);
      if (idlError) {
        _errorCode = idlError.code;
        _errorName = idlError.name;
        _errorMessage = idlError.msg;
      }
    }
    super(_errorMessage);
    this.errorCode = _errorCode;
    this.errorName = _errorName;
    this.errorMessage = _errorMessage;
  }
};
var error_default = DLMMError;

// src/clmm/index.ts
var LBCLMM = class {
  constructor(pubkey, program, lbPair, binArrayBitmapExtension, tokenX, tokenY, opt) {
    this.pubkey = pubkey;
    this.program = program;
    this.lbPair = lbPair;
    this.binArrayBitmapExtension = binArrayBitmapExtension;
    this.tokenX = tokenX;
    this.tokenY = tokenY;
    this.opt = opt;
  }
  static async getLbPairs(connection, opt) {
    const provider = new (0, _anchor.AnchorProvider)(connection, {}, _anchor.AnchorProvider.defaultOptions());
    const program = new (0, _anchor.Program)(IDL, LBCLMM_PROGRAM_IDS[opt.cluster], provider);
    return program.account.lbPair.all();
  }
  static async createLbPair(connection, funder, tokenX, tokenY, activeId, binStep, opt) {
    const provider = new (0, _anchor.AnchorProvider)(connection, {}, _anchor.AnchorProvider.defaultOptions());
    const program = new (0, _anchor.Program)(IDL, LBCLMM_PROGRAM_IDS[opt.cluster], provider);
    const [lbPair] = deriveLbPair(tokenX, tokenY, binStep, program.programId);
    const [reserveX] = deriveReserve(tokenX, lbPair, program.programId);
    const [reserveY] = deriveReserve(tokenY, lbPair, program.programId);
    const [oracle] = deriveOracle(lbPair, program.programId);
    const [presetParameter] = derivePresetParameter(binStep, program.programId);
    const activeBinArrayIndex = binIdToBinArrayIndex(activeId);
    const binArrayBitmapExtension = isOverflowDefaultBinArrayBitmap(activeBinArrayIndex) ? deriveBinArrayBitmapExtension(lbPair, program.programId)[0] : null;
    return program.methods.initializeLbPair(activeId.toNumber(), binStep.toNumber()).accounts({
      funder,
      lbPair,
      rent: _web3js.SYSVAR_RENT_PUBKEY,
      reserveX,
      reserveY,
      binArrayBitmapExtension,
      tokenMintX: tokenX,
      tokenMintY: tokenY,
      tokenProgram: _spltoken.TOKEN_PROGRAM_ID,
      oracle,
      presetParameter,
      systemProgram: _web3js.SystemProgram.programId
    }).transaction();
  }
  static async createMultiple(connection, clmmList, opt) {
    const cluster = _optionalChain([opt, 'optionalAccess', _7 => _7.cluster]) || "mainnet-beta";
    const provider = new (0, _anchor.AnchorProvider)(connection, {}, _anchor.AnchorProvider.defaultOptions());
    const program = new (0, _anchor.Program)(IDL, LBCLMM_PROGRAM_IDS[cluster], provider);
    const binArrayBitMapExtensions = clmmList.map(
      (lbPair) => deriveBinArrayBitmapExtension(lbPair, program.programId)[0]
    );
    const accountsToFetch = [...clmmList, ...binArrayBitMapExtensions];
    const accountsInfo = await chunkedGetMultipleAccountInfos(connection, accountsToFetch);
    const lbPairArraysMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < clmmList.length; i++) {
      const lbPairPubKey = clmmList[i];
      const lbPairAccountInfoBuffer = _optionalChain([accountsInfo, 'access', _8 => _8[i], 'optionalAccess', _9 => _9.data]);
      if (!lbPairAccountInfoBuffer)
        throw new Error(`LB Pair account ${lbPairPubKey.toBase58()} not found`);
      const binArrayAccInfo = program.coder.accounts.decode("lbPair", lbPairAccountInfoBuffer);
      lbPairArraysMap.set(lbPairPubKey.toBase58(), binArrayAccInfo);
    }
    const binArrayBitMapExtensionsMap = /* @__PURE__ */ new Map();
    for (let i = clmmList.length; i < accountsInfo.length; i++) {
      const index = i - clmmList.length;
      const lbPairPubkey = clmmList[index];
      const binArrayBitMapAccountInfoBuffer = _optionalChain([accountsInfo, 'access', _10 => _10[i], 'optionalAccess', _11 => _11.data]);
      if (binArrayBitMapAccountInfoBuffer) {
        const binArrayBitMapExtensionAccInfo = program.coder.accounts.decode(
          "binArrayBitmapExtension",
          binArrayBitMapAccountInfoBuffer
        );
        binArrayBitMapExtensionsMap.set(lbPairPubkey.toBase58(), binArrayBitMapExtensionAccInfo);
      }
    }
    const reservePublicKeys = Array.from(lbPairArraysMap.values()).map(({ reserveX, reserveY }) => [reserveX, reserveY]).flat();
    const reserveAccountsInfo = await chunkedGetMultipleAccountInfos(program.provider.connection, reservePublicKeys);
    const lbClmmImpl = await Promise.all(
      clmmList.map(async (lbPair, index) => {
        const lbPairState = lbPairArraysMap.get(lbPair.toBase58());
        const binArrayBitmapExtensionState = binArrayBitMapExtensionsMap.get(lbPair.toBase58());
        const binArrayBitmapExtensionPubkey = binArrayBitMapExtensions[index];
        let binArrayBitmapExtension;
        if (binArrayBitmapExtensionState) {
          binArrayBitmapExtension = {
            account: binArrayBitmapExtensionState,
            publicKey: binArrayBitmapExtensionPubkey
          };
        }
        const reserveXBalance = _spltoken.AccountLayout.decode(reserveAccountsInfo[index * 2].data);
        const reserveYBalance = _spltoken.AccountLayout.decode(reserveAccountsInfo[index * 2 + 1].data);
        const [tokenXDecimal, tokenYDecimal] = await Promise.all([
          getTokenDecimals(program.provider.connection, lbPairState.tokenXMint),
          getTokenDecimals(program.provider.connection, lbPairState.tokenYMint)
        ]);
        const tokenX = {
          publicKey: lbPairState.tokenXMint,
          reserve: lbPairState.reserveX,
          amount: reserveXBalance.amount,
          decimal: tokenXDecimal
        };
        const tokenY = {
          publicKey: lbPairState.tokenYMint,
          reserve: lbPairState.reserveY,
          amount: reserveYBalance.amount,
          decimal: tokenYDecimal
        };
        return new LBCLMM(lbPair, program, lbPairState, binArrayBitmapExtension, tokenX, tokenY, opt);
      })
    );
    return lbClmmImpl;
  }
  static async getAllLbPairPositionsByUser(connection, userPubKey, opt) {
    const cluster = _optionalChain([opt, 'optionalAccess', _12 => _12.cluster]) || "mainnet-beta";
    const provider = new (0, _anchor.AnchorProvider)(connection, {}, _anchor.AnchorProvider.defaultOptions());
    const program = new (0, _anchor.Program)(IDL, LBCLMM_PROGRAM_IDS[cluster], provider);
    const positions = await program.account.position.all([
      {
        memcmp: {
          bytes: _bytes.bs58.encode(userPubKey.toBuffer()),
          offset: 8 + 32
        }
      }
    ]);
    const positionsV2 = await program.account.positionV2.all([
      {
        memcmp: {
          bytes: _bytes.bs58.encode(userPubKey.toBuffer()),
          offset: 8 + 32
        }
      }
    ]);
    const binArrayPubkeySet = /* @__PURE__ */ new Set();
    const lbPairSet = /* @__PURE__ */ new Set();
    positions.forEach(({ account: { upperBinId, lowerBinId, lbPair } }) => {
      const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(lowerBinId));
      const upperBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(upperBinId));
      const [lowerBinArrayPubKey] = deriveBinArray(lbPair, lowerBinArrayIndex, program.programId);
      const [upperBinArrayPubKey] = deriveBinArray(lbPair, upperBinArrayIndex, program.programId);
      binArrayPubkeySet.add(lowerBinArrayPubKey.toBase58());
      binArrayPubkeySet.add(upperBinArrayPubKey.toBase58());
      lbPairSet.add(lbPair.toBase58());
    });
    const binArrayPubkeyArray = Array.from(binArrayPubkeySet).map((pubkey) => new (0, _web3js.PublicKey)(pubkey));
    const lbPairArray = Array.from(lbPairSet).map((pubkey) => new (0, _web3js.PublicKey)(pubkey));
    const binArrayPubkeySetV2 = /* @__PURE__ */ new Set();
    const lbPairSetV2 = /* @__PURE__ */ new Set();
    positionsV2.forEach(({ account: { upperBinId, lowerBinId, lbPair } }) => {
      const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(lowerBinId));
      const upperBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(upperBinId));
      const [lowerBinArrayPubKey] = deriveBinArray(lbPair, lowerBinArrayIndex, program.programId);
      const [upperBinArrayPubKey] = deriveBinArray(lbPair, upperBinArrayIndex, program.programId);
      binArrayPubkeySetV2.add(lowerBinArrayPubKey.toBase58());
      binArrayPubkeySetV2.add(upperBinArrayPubKey.toBase58());
      lbPairSetV2.add(lbPair.toBase58());
    });
    const binArrayPubkeyArrayV2 = Array.from(binArrayPubkeySetV2).map((pubkey) => new (0, _web3js.PublicKey)(pubkey));
    const lbPairArrayV2 = Array.from(lbPairSetV2).map((pubkey) => new (0, _web3js.PublicKey)(pubkey));
    const binArraysAccInfo = await chunkedGetMultipleAccountInfos(connection, [
      ...binArrayPubkeyArray,
      ...lbPairArray,
      ...binArrayPubkeyArrayV2,
      ...lbPairArrayV2
    ]);
    const positionBinArraysMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < binArrayPubkeyArray.length; i++) {
      const binArrayPubkey = binArrayPubkeyArray[i];
      const binArrayAccInfo = program.coder.accounts.decode("binArray", binArraysAccInfo[i].data);
      positionBinArraysMap.set(binArrayPubkey.toBase58(), binArrayAccInfo);
    }
    const lbPairArraysMap = /* @__PURE__ */ new Map();
    for (let i = binArrayPubkeyArray.length; i < binArrayPubkeyArray.length + lbPairArray.length; i++) {
      const lbPairPubkey = lbPairArray[i - binArrayPubkeyArray.length];
      const lbPairAccInfo = program.coder.accounts.decode("lbPair", binArraysAccInfo[i].data);
      lbPairArraysMap.set(lbPairPubkey.toBase58(), lbPairAccInfo);
    }
    const reservePublicKeys = Array.from(lbPairArraysMap.values()).map(({ reserveX, reserveY }) => [reserveX, reserveY]).flat();
    const positionBinArraysMapV2 = /* @__PURE__ */ new Map();
    for (let i = binArrayPubkeyArray.length + lbPairArray.length; i < binArrayPubkeyArray.length + lbPairArray.length + binArrayPubkeyArrayV2.length; i++) {
      const binArrayPubkey = binArrayPubkeyArrayV2[i - (binArrayPubkeyArray.length + lbPairArray.length)];
      const binArrayAccInfo = program.coder.accounts.decode("binArray", binArraysAccInfo[i].data);
      positionBinArraysMapV2.set(binArrayPubkey.toBase58(), binArrayAccInfo);
    }
    const lbPairArraysMapV2 = /* @__PURE__ */ new Map();
    for (let i = binArrayPubkeyArray.length + lbPairArray.length + binArrayPubkeyArrayV2.length; i < binArraysAccInfo.length; i++) {
      const lbPairPubkey = lbPairArrayV2[i - (binArrayPubkeyArray.length + lbPairArray.length + binArrayPubkeyArrayV2.length)];
      const lbPairAccInfo = program.coder.accounts.decode("lbPair", binArraysAccInfo[i].data);
      lbPairArraysMapV2.set(lbPairPubkey.toBase58(), lbPairAccInfo);
    }
    const reservePublicKeysV2 = Array.from(lbPairArraysMapV2.values()).map(({ reserveX, reserveY }) => [reserveX, reserveY]).flat();
    const reserveAccountsInfo = await chunkedGetMultipleAccountInfos(program.provider.connection, [
      ...reservePublicKeys,
      ...reservePublicKeysV2
    ]);
    const lbPairReserveMap = /* @__PURE__ */ new Map();
    lbPairArray.forEach((lbPair, idx) => {
      const index = idx * 2;
      const reserveAccX = _spltoken.AccountLayout.decode(reserveAccountsInfo[index].data);
      const reserveAccY = _spltoken.AccountLayout.decode(reserveAccountsInfo[index + 1].data);
      lbPairReserveMap.set(lbPair.toBase58(), {
        reserveX: reserveAccX.amount,
        reserveY: reserveAccY.amount
      });
    });
    const lbPairReserveMapV2 = /* @__PURE__ */ new Map();
    lbPairArrayV2.forEach((lbPair, idx) => {
      const index = idx * 2;
      const reserveAccX = _spltoken.AccountLayout.decode(reserveAccountsInfo[reservePublicKeys.length + index].data);
      const reserveAccY = _spltoken.AccountLayout.decode(reserveAccountsInfo[reservePublicKeys.length + index + 1].data);
      lbPairReserveMapV2.set(lbPair.toBase58(), {
        reserveX: reserveAccX.amount,
        reserveY: reserveAccY.amount
      });
    });
    const positionsMap = /* @__PURE__ */ new Map();
    for (let position of positions) {
      const { account, publicKey: positionPubKey } = position;
      const { upperBinId, lowerBinId, lbPair } = account;
      const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(lowerBinId));
      const upperBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(upperBinId));
      const [lowerBinArrayPubKey] = deriveBinArray(lbPair, lowerBinArrayIndex, program.programId);
      const [upperBinArrayPubKey] = deriveBinArray(lbPair, upperBinArrayIndex, program.programId);
      const lowerBinArray = positionBinArraysMap.get(lowerBinArrayPubKey.toBase58());
      const upperBinArray = positionBinArraysMap.get(upperBinArrayPubKey.toBase58());
      const lbPairAcc = lbPairArraysMap.get(lbPair.toBase58());
      const [baseTokenDecimal, quoteTokenDecimal] = await Promise.all([
        getTokenDecimals(program.provider.connection, lbPairAcc.tokenXMint),
        getTokenDecimals(program.provider.connection, lbPairAcc.tokenYMint)
      ]);
      const reserveXBalance = lbPairReserveMap.get(lbPair.toBase58()).reserveX;
      const reserveYBalance = lbPairReserveMap.get(lbPair.toBase58()).reserveY;
      const tokenX = {
        publicKey: lbPairAcc.tokenXMint,
        reserve: lbPairAcc.reserveX,
        amount: reserveXBalance,
        decimal: baseTokenDecimal
      };
      const tokenY = {
        publicKey: lbPairAcc.tokenYMint,
        reserve: lbPairAcc.reserveY,
        amount: reserveYBalance,
        decimal: quoteTokenDecimal
      };
      const positionData = await LBCLMM.processPosition(
        program,
        0 /* V1 */,
        lbPairAcc,
        account,
        baseTokenDecimal,
        quoteTokenDecimal,
        lowerBinArray,
        upperBinArray
      );
      positionsMap.set(lbPair.toBase58(), {
        publicKey: lbPair,
        lbPair: lbPairAcc,
        tokenX,
        tokenY,
        lbPairPositionsData: [
          ..._nullishCoalesce(_optionalChain([positionsMap, 'access', _13 => _13.get, 'call', _14 => _14(lbPair.toBase58()), 'optionalAccess', _15 => _15.lbPairPositionsData]), () => ( [])),
          {
            publicKey: positionPubKey,
            positionData,
            version: 0 /* V1 */
          }
        ]
      });
    }
    for (let position of positionsV2) {
      const { account, publicKey: positionPubKey } = position;
      const { upperBinId, lowerBinId, lbPair } = account;
      const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(lowerBinId));
      const upperBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(upperBinId));
      const [lowerBinArrayPubKey] = deriveBinArray(lbPair, lowerBinArrayIndex, program.programId);
      const [upperBinArrayPubKey] = deriveBinArray(lbPair, upperBinArrayIndex, program.programId);
      const lowerBinArray = positionBinArraysMapV2.get(lowerBinArrayPubKey.toBase58());
      const upperBinArray = positionBinArraysMapV2.get(upperBinArrayPubKey.toBase58());
      const lbPairAcc = lbPairArraysMapV2.get(lbPair.toBase58());
      const [baseTokenDecimal, quoteTokenDecimal] = await Promise.all([
        getTokenDecimals(program.provider.connection, lbPairAcc.tokenXMint),
        getTokenDecimals(program.provider.connection, lbPairAcc.tokenYMint)
      ]);
      const reserveXBalance = lbPairReserveMapV2.get(lbPair.toBase58()).reserveX;
      const reserveYBalance = lbPairReserveMapV2.get(lbPair.toBase58()).reserveY;
      const tokenX = {
        publicKey: lbPairAcc.tokenXMint,
        reserve: lbPairAcc.reserveX,
        amount: reserveXBalance,
        decimal: baseTokenDecimal
      };
      const tokenY = {
        publicKey: lbPairAcc.tokenYMint,
        reserve: lbPairAcc.reserveY,
        amount: reserveYBalance,
        decimal: quoteTokenDecimal
      };
      const positionData = await LBCLMM.processPosition(
        program,
        1 /* V2 */,
        lbPairAcc,
        account,
        baseTokenDecimal,
        quoteTokenDecimal,
        lowerBinArray,
        upperBinArray
      );
      positionsMap.set(lbPair.toBase58(), {
        publicKey: lbPair,
        lbPair: lbPairAcc,
        tokenX,
        tokenY,
        lbPairPositionsData: [
          ..._nullishCoalesce(_optionalChain([positionsMap, 'access', _16 => _16.get, 'call', _17 => _17(lbPair.toBase58()), 'optionalAccess', _18 => _18.lbPairPositionsData]), () => ( [])),
          {
            publicKey: positionPubKey,
            positionData,
            version: 1 /* V2 */
          }
        ]
      });
    }
    return positionsMap;
  }
  static async processPosition(program, version, lbPair, positionAccount, baseTokenDecimal, quoteTokenDecimal, lowerBinArray, upperBinArray) {
    const { lowerBinId, upperBinId, liquidityShares: posShares, lastUpdatedAt } = positionAccount;
    const bins = LBCLMM.getBinsBetweenLowerAndUpperBound(
      lbPair,
      lowerBinId,
      upperBinId,
      baseTokenDecimal,
      quoteTokenDecimal,
      lowerBinArray,
      upperBinArray
    );
    if (!bins.length)
      return null;
    if (bins[0].binId !== lowerBinId || bins[bins.length - 1].binId !== upperBinId)
      throw new Error("Bin ID mismatch");
    const positionData = [];
    let totalXAmount = new (0, _decimaljs2.default)(0);
    let totalYAmount = new (0, _decimaljs2.default)(0);
    bins.forEach((bin, idx) => {
      const binSupply = new (0, _decimaljs2.default)(bin.supply.toString());
      let posShare;
      if (bin.version === 1 && version === 0 /* V1 */) {
        posShare = new (0, _decimaljs2.default)(posShares[idx].shln(64).toString());
      } else {
        posShare = new (0, _decimaljs2.default)(posShares[idx].toString());
      }
      const positionXAmount = binSupply.eq(new (0, _decimaljs2.default)("0")) ? new (0, _decimaljs2.default)("0") : posShare.mul(bin.xAmount.toString()).div(binSupply).floor();
      const positionYAmount = binSupply.eq(new (0, _decimaljs2.default)("0")) ? new (0, _decimaljs2.default)("0") : posShare.mul(bin.yAmount.toString()).div(binSupply).floor();
      totalXAmount = totalXAmount.add(positionXAmount);
      totalYAmount = totalYAmount.add(positionYAmount);
      positionData.push({
        binId: bin.binId,
        price: bin.price,
        pricePerToken: bin.pricePerToken,
        binXAmount: bin.xAmount.toString(),
        binYAmount: bin.yAmount.toString(),
        binLiquidity: binSupply.toString(),
        positionLiquidity: posShare.toString(),
        positionXAmount: positionXAmount.toString(),
        positionYAmount: positionYAmount.toString()
      });
    });
    const { feeX, feeY } = await LBCLMM.getClaimableSwapFee(
      program,
      version,
      positionAccount,
      lowerBinArray,
      upperBinArray
    );
    const { rewardOne, rewardTwo } = await LBCLMM.getClaimableLMReward(
      program,
      version,
      lbPair,
      positionAccount,
      lowerBinArray,
      upperBinArray
    );
    return {
      totalXAmount: totalXAmount.toString(),
      totalYAmount: totalYAmount.toString(),
      positionBinData: positionData,
      lastUpdatedAt,
      lowerBinId,
      upperBinId,
      feeX,
      feeY,
      rewardOne,
      rewardTwo
    };
  }
  static getBinsBetweenLowerAndUpperBound(lbPair, lowerBinId, upperBinId, baseTokenDecimal, quoteTokenDecimal, lowerBinArrays, upperBinArrays) {
    const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(lowerBinId));
    const upperBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(upperBinId));
    let bins = [];
    if (lowerBinArrayIndex.eq(upperBinArrayIndex)) {
      const binArray = lowerBinArrays;
      const [lowerBinIdForBinArray] = getBinArrayLowerUpperBinId(binArray.index);
      binArray.bins.forEach((bin, idx) => {
        const binId = lowerBinIdForBinArray.toNumber() + idx;
        if (binId >= lowerBinId && binId <= upperBinId) {
          const pricePerLamport = LBCLMM.getPriceOfBinByBinId(lbPair.binStep, binId);
          bins.push({
            binId,
            xAmount: bin.amountX,
            yAmount: bin.amountY,
            supply: bin.liquiditySupply,
            price: pricePerLamport,
            version: binArray.version,
            pricePerToken: new (0, _decimaljs2.default)(pricePerLamport).mul(new (0, _decimaljs2.default)(10 ** (baseTokenDecimal - quoteTokenDecimal))).toString()
          });
        }
      });
    } else {
      const binArrays = [lowerBinArrays, upperBinArrays];
      binArrays.forEach((binArray) => {
        const [lowerBinIdForBinArray] = getBinArrayLowerUpperBinId(binArray.index);
        binArray.bins.forEach((bin, idx) => {
          const binId = lowerBinIdForBinArray.toNumber() + idx;
          if (binId >= lowerBinId && binId <= upperBinId) {
            const pricePerLamport = LBCLMM.getPriceOfBinByBinId(lbPair.binStep, binId);
            bins.push({
              binId,
              xAmount: bin.amountX,
              yAmount: bin.amountY,
              supply: bin.liquiditySupply,
              price: pricePerLamport,
              version: binArray.version,
              pricePerToken: new (0, _decimaljs2.default)(pricePerLamport).mul(new (0, _decimaljs2.default)(10 ** (baseTokenDecimal - quoteTokenDecimal))).toString()
            });
          }
        });
      });
    }
    return bins;
  }
  static getPriceOfBinByBinId(binStep, binId) {
    const binStepNum = new (0, _decimaljs2.default)(binStep).div(new (0, _decimaljs2.default)(BASIS_POINT_MAX));
    return new (0, _decimaljs2.default)(1).add(new (0, _decimaljs2.default)(binStepNum)).pow(new (0, _decimaljs2.default)(binId)).toString();
  }
  static async migratePosition(connection, positions, newPositions, walletPubkey, opt) {
    const cluster = _optionalChain([opt, 'optionalAccess', _19 => _19.cluster]) || "mainnet-beta";
    const provider = new (0, _anchor.AnchorProvider)(connection, {}, _anchor.AnchorProvider.defaultOptions());
    const program = new (0, _anchor.Program)(IDL, LBCLMM_PROGRAM_IDS[cluster], provider);
    const positionsState = await program.account.position.fetchMultiple(positions);
    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash("confirmed");
    return Promise.all(
      positionsState.map(async ({ lbPair, lowerBinId }, idx) => {
        const position = positions[idx];
        const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(lowerBinId));
        const upperBinArrayIndex = lowerBinArrayIndex.add(new (0, _anchor.BN)(1));
        const [lowerBinArrayPubKey] = deriveBinArray(lbPair, lowerBinArrayIndex, program.programId);
        const [upperBinArrayPubKey] = deriveBinArray(lbPair, upperBinArrayIndex, program.programId);
        const migrateTx = await program.methods.migratePosition().accounts({
          binArrayLower: lowerBinArrayPubKey,
          binArrayUpper: upperBinArrayPubKey,
          lbPair,
          owner: walletPubkey,
          positionV1: position,
          positionV2: newPositions[idx],
          program: program.programId,
          rentReceiver: walletPubkey,
          systemProgram: _web3js.SystemProgram.programId
        }).transaction();
        return new (0, _web3js.Transaction)({
          blockhash,
          lastValidBlockHeight,
          feePayer: walletPubkey
        }).add(migrateTx);
      })
    );
  }
  async refetchStates() {
    const binArrayBitmapExtensionPubkey = deriveBinArrayBitmapExtension(this.pubkey, this.program.programId)[0];
    const binArrayBitmapExtensionState = await this.program.account.binArrayBitmapExtension.fetchNullable(
      binArrayBitmapExtensionPubkey
    );
    if (binArrayBitmapExtensionState) {
      this.binArrayBitmapExtension = {
        account: binArrayBitmapExtensionState,
        publicKey: binArrayBitmapExtensionPubkey
      };
    }
    const newLbPair = await this.program.account.lbPair.fetch(this.pubkey);
    this.lbPair = newLbPair;
  }
  static async getBinArrays(program, lbPairPubkey) {
    return program.account.binArray.all([
      {
        memcmp: {
          bytes: _bytes.bs58.encode(lbPairPubkey.toBuffer()),
          offset: 8 + 16
        }
      }
    ]);
  }
  async getBinArrays() {
    return this.program.account.binArray.all([
      {
        memcmp: {
          bytes: _bytes.bs58.encode(this.pubkey.toBuffer()),
          offset: 8 + 16
        }
      }
    ]);
  }
  getFeeInfo() {
    const { baseFactor, protocolShare } = this.lbPair.parameters;
    const baseFeeRate = new (0, _anchor.BN)(baseFactor).mul(new (0, _anchor.BN)(this.lbPair.binStep)).mul(new (0, _anchor.BN)(10));
    const baseFeeRatePercentage = new (0, _decimaljs2.default)(baseFeeRate.toString()).mul(new (0, _decimaljs2.default)(100)).div(new (0, _decimaljs2.default)(FEE_PRECISION.toString()));
    const maxFeeRatePercentage = new (0, _decimaljs2.default)(MAX_FEE_RATE.toString()).mul(new (0, _decimaljs2.default)(100)).div(new (0, _decimaljs2.default)(FEE_PRECISION.toString()));
    const protocolFeePercentage = new (0, _decimaljs2.default)(protocolShare.toString()).mul(new (0, _decimaljs2.default)(100)).div(new (0, _decimaljs2.default)(BASIS_POINT_MAX));
    return {
      baseFeeRatePercentage,
      maxFeeRatePercentage,
      protocolFeePercentage
    };
  }
  getDynamicFee() {
    let vParameterClone = Object.assign({}, this.lbPair.vParameters);
    let activeId = new (0, _anchor.BN)(this.lbPair.activeId);
    const sParameters2 = this.lbPair.parameters;
    const currentTimestamp = Date.now() / 1e3;
    this.updateReference(activeId.toNumber(), vParameterClone, sParameters2, currentTimestamp);
    this.updateVolatilityAccumulator(vParameterClone, sParameters2, activeId.toNumber());
    const totalFee = getTotalFee(this.lbPair.binStep, sParameters2, vParameterClone);
    return new (0, _decimaljs2.default)(totalFee.toString()).div(new (0, _decimaljs2.default)(FEE_PRECISION.toString())).mul(100);
  }
  getEmissionRate() {
    const [rewardOneEmissionRate, rewardTwoEmissionRate] = this.lbPair.rewardInfos.map(({ rewardRate }) => rewardRate);
    return {
      rewardOne: new (0, _decimaljs2.default)(rewardOneEmissionRate.toString()).div(PRECISION),
      rewardTwo: new (0, _decimaljs2.default)(rewardTwoEmissionRate.toString()).div(PRECISION)
    };
  }
  async getBinsAroundActiveBin(numberOfBinsToTheLeft, numberOfBinsToTheRight) {
    const lowerBinId = this.lbPair.activeId - numberOfBinsToTheLeft - 1;
    const upperBinId = this.lbPair.activeId + numberOfBinsToTheRight + 1;
    const bins = await this.getBins(this.pubkey, lowerBinId, upperBinId, this.tokenX.decimal, this.tokenY.decimal);
    return { activeBin: this.lbPair.activeId, bins };
  }
  async getBinsBetweenMinAndMaxPrice(minPrice, maxPrice) {
    const lowerBinId = this.getBinIdFromPrice(minPrice, true) - 1;
    const upperBinId = this.getBinIdFromPrice(maxPrice, false) + 1;
    const bins = await this.getBins(this.pubkey, lowerBinId, upperBinId, this.tokenX.decimal, this.tokenX.decimal);
    return { activeBin: this.lbPair.activeId, bins };
  }
  async getBinsBetweenLowerAndUpperBound(lowerBinId, upperBinId, lowerBinArrays, upperBinArrays) {
    const bins = await this.getBins(
      this.pubkey,
      lowerBinId,
      upperBinId,
      this.tokenX.decimal,
      this.tokenY.decimal,
      lowerBinArrays,
      upperBinArrays
    );
    return { activeBin: this.lbPair.activeId, bins };
  }
  async getBins(lbPairPubKey, lowerBinId, upperBinId, baseTokenDecimal, quoteTokenDecimal, lowerBinArrays, upperBinArrays) {
    const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(lowerBinId));
    const upperBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(upperBinId));
    let bins = [];
    if (lowerBinArrayIndex.eq(upperBinArrayIndex)) {
      const [binArrayPubKey] = deriveBinArray(lbPairPubKey, lowerBinArrayIndex, this.program.programId);
      const binArray = await _asyncNullishCoalesce(lowerBinArrays, async () => ( await this.program.account.binArray.fetch(binArrayPubKey)));
      const [lowerBinIdForBinArray] = getBinArrayLowerUpperBinId(binArray.index);
      binArray.bins.forEach((bin, idx) => {
        const binId = lowerBinIdForBinArray.toNumber() + idx;
        if (binId >= lowerBinId && binId <= upperBinId) {
          const pricePerLamport = this.getPriceOfBinByBinId(binId);
          bins.push({
            binId,
            xAmount: bin.amountX,
            yAmount: bin.amountY,
            supply: bin.liquiditySupply,
            price: pricePerLamport,
            version: binArray.version,
            pricePerToken: new (0, _decimaljs2.default)(pricePerLamport).mul(new (0, _decimaljs2.default)(10 ** (baseTokenDecimal - quoteTokenDecimal))).toString()
          });
        }
      });
    } else {
      const [lowerBinArrayPubKey] = deriveBinArray(lbPairPubKey, lowerBinArrayIndex, this.program.programId);
      const [upperBinArrayPubKey] = deriveBinArray(lbPairPubKey, upperBinArrayIndex, this.program.programId);
      const binArrays = await (async () => {
        if (!lowerBinArrays || !upperBinArrays) {
          return (await this.program.account.binArray.fetchMultiple([lowerBinArrayPubKey, upperBinArrayPubKey])).filter(
            (binArray) => binArray !== null
          );
        }
        return [lowerBinArrays, upperBinArrays];
      })();
      binArrays.forEach((binArray) => {
        const [lowerBinIdForBinArray] = getBinArrayLowerUpperBinId(binArray.index);
        binArray.bins.forEach((bin, idx) => {
          const binId = lowerBinIdForBinArray.toNumber() + idx;
          if (binId >= lowerBinId && binId <= upperBinId) {
            const pricePerLamport = this.getPriceOfBinByBinId(binId);
            bins.push({
              binId,
              xAmount: bin.amountX,
              yAmount: bin.amountY,
              supply: bin.liquiditySupply,
              price: pricePerLamport,
              version: binArray.version,
              pricePerToken: new (0, _decimaljs2.default)(pricePerLamport).mul(new (0, _decimaljs2.default)(10 ** (baseTokenDecimal - quoteTokenDecimal))).toString()
            });
          }
        });
      });
    }
    return bins;
  }
  toPricePerLamport(price) {
    return new (0, _decimaljs2.default)(price).mul(new (0, _decimaljs2.default)(10 ** (this.tokenY.decimal - this.tokenX.decimal))).toString();
  }
  fromPricePerLamport(pricePerLamport) {
    return new (0, _decimaljs2.default)(pricePerLamport).div(new (0, _decimaljs2.default)(10 ** (this.tokenY.decimal - this.tokenX.decimal))).toString();
  }
  async getActiveBin() {
    const { activeId } = await this.program.account.lbPair.fetch(this.pubkey);
    return {
      binId: activeId,
      price: this.getPriceOfBinByBinId(activeId)
    };
  }
  getPriceOfBinByBinId(binId) {
    const binStepNum = new (0, _decimaljs2.default)(this.lbPair.binStep).div(new (0, _decimaljs2.default)(BASIS_POINT_MAX));
    return new (0, _decimaljs2.default)(1).add(new (0, _decimaljs2.default)(binStepNum)).pow(new (0, _decimaljs2.default)(binId)).toString();
  }
  getBinIdFromPrice(price, min) {
    const binStepNum = new (0, _decimaljs2.default)(this.lbPair.binStep).div(new (0, _decimaljs2.default)(BASIS_POINT_MAX));
    const binId = new (0, _decimaljs2.default)(price).log().dividedBy(new (0, _decimaljs2.default)(1).add(binStepNum).log());
    return (min ? binId.floor() : binId.ceil()).toNumber();
  }
  async getPositionsByUserAndLbPair(userPubKey) {
    if (!userPubKey) {
      return {
        activeBin: await this.getActiveBin(),
        userPositions: []
      };
    }
    const positions = await this.program.account.position.all([
      {
        memcmp: {
          bytes: _bytes.bs58.encode(userPubKey.toBuffer()),
          offset: 8 + 32
        }
      },
      {
        memcmp: {
          bytes: _bytes.bs58.encode(this.pubkey.toBuffer()),
          offset: 8
        }
      }
    ]);
    const positionsV2 = await this.program.account.positionV2.all([
      {
        memcmp: {
          bytes: _bytes.bs58.encode(userPubKey.toBuffer()),
          offset: 8 + 32
        }
      },
      {
        memcmp: {
          bytes: _bytes.bs58.encode(this.pubkey.toBuffer()),
          offset: 8
        }
      }
    ]);
    const binArrayPubkeySet = /* @__PURE__ */ new Set();
    positions.forEach(({ account: { upperBinId, lowerBinId } }) => {
      const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(lowerBinId));
      const upperBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(upperBinId));
      const [lowerBinArrayPubKey] = deriveBinArray(this.pubkey, lowerBinArrayIndex, this.program.programId);
      const [upperBinArrayPubKey] = deriveBinArray(this.pubkey, upperBinArrayIndex, this.program.programId);
      binArrayPubkeySet.add(lowerBinArrayPubKey.toBase58());
      binArrayPubkeySet.add(upperBinArrayPubKey.toBase58());
    });
    const binArrayPubkeyArray = Array.from(binArrayPubkeySet).map((pubkey) => new (0, _web3js.PublicKey)(pubkey));
    const binArrayPubkeySetV2 = /* @__PURE__ */ new Set();
    positionsV2.forEach(({ account: { upperBinId, lowerBinId } }) => {
      const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(lowerBinId));
      const upperBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(upperBinId));
      const [lowerBinArrayPubKey] = deriveBinArray(this.pubkey, lowerBinArrayIndex, this.program.programId);
      const [upperBinArrayPubKey] = deriveBinArray(this.pubkey, upperBinArrayIndex, this.program.programId);
      binArrayPubkeySetV2.add(lowerBinArrayPubKey.toBase58());
      binArrayPubkeySetV2.add(upperBinArrayPubKey.toBase58());
    });
    const binArrayPubkeyArrayV2 = Array.from(binArrayPubkeySetV2).map((pubkey) => new (0, _web3js.PublicKey)(pubkey));
    const lbPairAndBinArrays = await chunkedGetMultipleAccountInfos(this.program.provider.connection, [
      this.pubkey,
      ...binArrayPubkeyArray,
      ...binArrayPubkeyArrayV2
    ]);
    const [lbPairAccInfo, ...binArraysAccInfo] = lbPairAndBinArrays;
    const positionBinArraysMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < binArrayPubkeyArray.length; i++) {
      const binArrayPubkey = binArrayPubkeyArray[i];
      const binArrayAccInfo = this.program.coder.accounts.decode("binArray", binArraysAccInfo[i].data);
      positionBinArraysMap.set(binArrayPubkey.toBase58(), binArrayAccInfo);
    }
    const positionBinArraysMapV2 = /* @__PURE__ */ new Map();
    for (let i = binArrayPubkeyArray.length; i < binArraysAccInfo.length; i++) {
      const binArrayPubkey = binArrayPubkeyArrayV2[i - binArrayPubkeyArray.length];
      const binArrayAccInfo = this.program.coder.accounts.decode("binArray", binArraysAccInfo[i].data);
      positionBinArraysMapV2.set(binArrayPubkey.toBase58(), binArrayAccInfo);
    }
    const { activeId } = this.program.coder.accounts.decode("lbPair", lbPairAccInfo.data);
    const userPositions = await Promise.all(
      positions.map(async ({ publicKey, account }) => {
        const { lowerBinId, upperBinId } = account;
        const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(lowerBinId));
        const upperBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(upperBinId));
        const [lowerBinArrayPubKey] = deriveBinArray(this.pubkey, lowerBinArrayIndex, this.program.programId);
        const [upperBinArrayPubKey] = deriveBinArray(this.pubkey, upperBinArrayIndex, this.program.programId);
        const lowerBinArray = positionBinArraysMap.get(lowerBinArrayPubKey.toBase58());
        const upperBinArray = positionBinArraysMap.get(upperBinArrayPubKey.toBase58());
        return {
          publicKey,
          positionData: await LBCLMM.processPosition(
            this.program,
            0 /* V1 */,
            this.lbPair,
            account,
            this.tokenX.decimal,
            this.tokenY.decimal,
            lowerBinArray,
            upperBinArray
          ),
          version: 0 /* V1 */
        };
      })
    );
    const userPositionsV2 = await Promise.all(
      positionsV2.map(async ({ publicKey, account }) => {
        const { lowerBinId, upperBinId } = account;
        const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(lowerBinId));
        const upperBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(upperBinId));
        const [lowerBinArrayPubKey] = deriveBinArray(this.pubkey, lowerBinArrayIndex, this.program.programId);
        const [upperBinArrayPubKey] = deriveBinArray(this.pubkey, upperBinArrayIndex, this.program.programId);
        const lowerBinArray = positionBinArraysMapV2.get(lowerBinArrayPubKey.toBase58());
        const upperBinArray = positionBinArraysMapV2.get(upperBinArrayPubKey.toBase58());
        return {
          publicKey,
          positionData: await LBCLMM.processPosition(
            this.program,
            1 /* V2 */,
            this.lbPair,
            account,
            this.tokenX.decimal,
            this.tokenY.decimal,
            lowerBinArray,
            upperBinArray
          ),
          version: 1 /* V2 */
        };
      })
    );
    return {
      activeBin: {
        binId: activeId,
        price: this.getPriceOfBinByBinId(activeId)
      },
      userPositions: [...userPositions, ...userPositionsV2]
    };
  }
  async initializePositionAndAddLiquidityByWeight({
    positionPubKey,
    totalXAmount,
    totalYAmount,
    xYAmountDistribution,
    user
  }) {
    const { lowerBinId, upperBinId, binIds } = this.processXYAmountDistribution(xYAmountDistribution);
    if (upperBinId >= lowerBinId + MAX_BIN_PER_POSITION.toNumber()) {
      throw new Error(`Position must be within a range of 1 to ${MAX_BIN_PER_POSITION.toNumber()} bins.`);
    }
    const preInstructions = [];
    const initializePositionIx = await this.program.methods.initializePosition(lowerBinId, upperBinId - lowerBinId + 1).accounts({
      payer: user,
      position: positionPubKey,
      lbPair: this.pubkey,
      owner: user
    }).instruction();
    preInstructions.push(initializePositionIx);
    const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(lowerBinId));
    const [binArrayLower] = deriveBinArray(this.pubkey, lowerBinArrayIndex, this.program.programId);
    const upperBinArrayIndex = lowerBinArrayIndex.add(new (0, _anchor.BN)(1));
    const [binArrayUpper] = deriveBinArray(this.pubkey, upperBinArrayIndex, this.program.programId);
    const binArraysNeeded = Array.from(
      { length: upperBinArrayIndex.sub(lowerBinArrayIndex).toNumber() + 4 },
      (_, index) => index - 2 + lowerBinArrayIndex.toNumber()
    ).map((idx) => new (0, _anchor.BN)(idx));
    const createBinArrayIxs = await this.createBinArraysIfNeeded(this.pubkey, binArraysNeeded, user);
    preInstructions.push(...createBinArrayIxs);
    const [{ ataPubKey: userTokenX, ix: createPayerTokenXIx }, { ataPubKey: userTokenY, ix: createPayerTokenYIx }] = await Promise.all([
      getOrCreateATAInstruction(this.program.provider.connection, this.tokenX.publicKey, user),
      getOrCreateATAInstruction(this.program.provider.connection, this.tokenY.publicKey, user)
    ]);
    createPayerTokenXIx && preInstructions.push(createPayerTokenXIx);
    createPayerTokenYIx && preInstructions.push(createPayerTokenYIx);
    if (this.tokenX.publicKey.equals(_spltoken.NATIVE_MINT)) {
      const wrapSOLIx = wrapSOLInstruction(user, userTokenX, BigInt(totalXAmount.toString()));
      preInstructions.push(...wrapSOLIx);
    }
    if (this.tokenY.publicKey.equals(_spltoken.NATIVE_MINT)) {
      const wrapSOLIx = wrapSOLInstruction(user, userTokenY, BigInt(totalYAmount.toString()));
      preInstructions.push(...wrapSOLIx);
    }
    const postInstructions = [];
    if ([this.tokenX.publicKey.toBase58(), this.tokenY.publicKey.toBase58()].includes(_spltoken.NATIVE_MINT.toBase58())) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    const setComputeUnitLimitIx = _web3js.ComputeBudgetProgram.setComputeUnitLimit({
      units: 14e5
    });
    const minBinId = Math.min(...binIds);
    const maxBinId = Math.max(...binIds);
    const minBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(minBinId));
    const maxBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(maxBinId));
    const useExtension = isOverflowDefaultBinArrayBitmap(minBinArrayIndex) || isOverflowDefaultBinArrayBitmap(maxBinArrayIndex);
    const binArrayBitmapExtension = useExtension ? deriveBinArrayBitmapExtension(this.pubkey, this.program.programId)[0] : null;
    const activeId = (await this.getActiveBin()).binId;
    const binLiquidityDist = toWeightDistribution(
      totalXAmount,
      totalYAmount,
      xYAmountDistribution.map((item) => ({
        binId: item.binId,
        xAmountBpsOfTotal: item.xAmountBpsOfTotal,
        yAmountBpsOfTotal: item.yAmountBpsOfTotal
      })),
      this.lbPair.binStep
    );
    if (binLiquidityDist.length === 0) {
      throw new Error("No liquidity to add");
    }
    const liquidityParams = {
      amountX: totalXAmount,
      amountY: totalYAmount,
      binLiquidityDist,
      activeId,
      maxActiveBinSlippage: MAX_ACTIVE_BIN_SLIPPAGE
    };
    const addLiquidityAccounts = {
      position: positionPubKey,
      lbPair: this.pubkey,
      userTokenX,
      userTokenY,
      reserveX: this.lbPair.reserveX,
      reserveY: this.lbPair.reserveY,
      tokenXMint: this.lbPair.tokenXMint,
      tokenYMint: this.lbPair.tokenYMint,
      binArrayLower,
      binArrayUpper,
      binArrayBitmapExtension,
      sender: user,
      tokenXProgram: _spltoken.TOKEN_PROGRAM_ID,
      tokenYProgram: _spltoken.TOKEN_PROGRAM_ID
    };
    const oneSideLiquidityParams = {
      amount: totalXAmount.isZero() ? totalYAmount : totalXAmount,
      activeId,
      maxActiveBinSlippage: MAX_ACTIVE_BIN_SLIPPAGE,
      binLiquidityDist
    };
    const oneSideAddLiquidityAccounts = {
      binArrayLower,
      binArrayUpper,
      lbPair: this.pubkey,
      binArrayBitmapExtension: null,
      sender: user,
      position: positionPubKey,
      reserve: totalXAmount.isZero() ? this.lbPair.reserveY : this.lbPair.reserveX,
      tokenMint: totalXAmount.isZero() ? this.lbPair.tokenYMint : this.lbPair.tokenXMint,
      tokenProgram: _spltoken.TOKEN_PROGRAM_ID,
      userToken: totalXAmount.isZero() ? userTokenY : userTokenX
    };
    const isOneSideDeposit = totalXAmount.isZero() || totalYAmount.isZero();
    const programMethod = isOneSideDeposit ? this.program.methods.addLiquidityOneSide(oneSideLiquidityParams) : this.program.methods.addLiquidityByWeight(liquidityParams);
    if (xYAmountDistribution.length < MAX_BIN_LENGTH_ALLOWED_IN_ONE_TX) {
      const addLiqTx2 = await programMethod.accounts(isOneSideDeposit ? oneSideAddLiquidityAccounts : addLiquidityAccounts).preInstructions([setComputeUnitLimitIx, ...preInstructions]).postInstructions(postInstructions).transaction();
      const { blockhash: blockhash2, lastValidBlockHeight: lastValidBlockHeight2 } = await this.program.provider.connection.getLatestBlockhash(
        "confirmed"
      );
      return new (0, _web3js.Transaction)({
        blockhash: blockhash2,
        lastValidBlockHeight: lastValidBlockHeight2,
        feePayer: user
      }).add(addLiqTx2);
    }
    const addLiqTx = await programMethod.accounts(isOneSideDeposit ? oneSideAddLiquidityAccounts : addLiquidityAccounts).preInstructions([setComputeUnitLimitIx]).transaction();
    const transactions = [];
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    if (preInstructions.length) {
      const preInstructionsTx = new (0, _web3js.Transaction)({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(...preInstructions);
      transactions.push(preInstructionsTx);
    }
    const mainTx = new (0, _web3js.Transaction)({
      blockhash,
      lastValidBlockHeight,
      feePayer: user
    }).add(addLiqTx);
    transactions.push(mainTx);
    if (postInstructions.length) {
      const postInstructionsTx = new (0, _web3js.Transaction)({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(...postInstructions);
      transactions.push(postInstructionsTx);
    }
    return transactions;
  }
  async addLiquidityByWeight({
    lbPairPubKey,
    positionPubKey,
    totalXAmount,
    totalYAmount,
    xYAmountDistribution,
    user
  }) {
    const positionAccount = await this.program.account.positionV2.fetch(positionPubKey);
    const { lowerBinId, upperBinId, binIds } = this.processXYAmountDistribution(xYAmountDistribution);
    if (lowerBinId < positionAccount.lowerBinId)
      throw new Error(`Lower Bin ID (${lowerBinId}) lower than Position Lower Bin Id (${positionAccount.lowerBinId})`);
    if (upperBinId > positionAccount.upperBinId)
      throw new Error(`Upper Bin ID (${upperBinId}) higher than Position Upper Bin Id (${positionAccount.upperBinId})`);
    const minBinId = Math.min(...binIds);
    const maxBinId = Math.max(...binIds);
    const minBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(minBinId));
    const maxBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(maxBinId));
    const useExtension = isOverflowDefaultBinArrayBitmap(minBinArrayIndex) || isOverflowDefaultBinArrayBitmap(maxBinArrayIndex);
    const binArrayBitmapExtension = useExtension ? deriveBinArrayBitmapExtension(this.pubkey, this.program.programId)[0] : null;
    const activeId = (await this.getActiveBin()).binId;
    const binLiquidityDist = toWeightDistribution(
      totalXAmount,
      totalYAmount,
      xYAmountDistribution.map((item) => ({
        binId: item.binId,
        xAmountBpsOfTotal: item.xAmountBpsOfTotal,
        yAmountBpsOfTotal: item.yAmountBpsOfTotal
      })),
      this.lbPair.binStep
    );
    if (binLiquidityDist.length === 0) {
      throw new Error("No liquidity to add");
    }
    const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(positionAccount.lowerBinId));
    const [binArrayLower] = deriveBinArray(lbPairPubKey, lowerBinArrayIndex, this.program.programId);
    const upperBinArrayIndex = lowerBinArrayIndex.add(new (0, _anchor.BN)(1));
    const [binArrayUpper] = deriveBinArray(lbPairPubKey, upperBinArrayIndex, this.program.programId);
    const binArraysNeeded = Array.from(
      { length: upperBinArrayIndex.sub(lowerBinArrayIndex).toNumber() + 4 },
      (_, index) => index - 2 + lowerBinArrayIndex.toNumber()
    ).map((idx) => new (0, _anchor.BN)(idx));
    const preInstructions = [];
    const createBinArrayIxs = await this.createBinArraysIfNeeded(lbPairPubKey, binArraysNeeded, user);
    preInstructions.push(...createBinArrayIxs);
    const [{ ataPubKey: userTokenX, ix: createPayerTokenXIx }, { ataPubKey: userTokenY, ix: createPayerTokenYIx }] = await Promise.all([
      getOrCreateATAInstruction(this.program.provider.connection, this.tokenX.publicKey, user),
      getOrCreateATAInstruction(this.program.provider.connection, this.tokenY.publicKey, user)
    ]);
    createPayerTokenXIx && preInstructions.push(createPayerTokenXIx);
    createPayerTokenYIx && preInstructions.push(createPayerTokenYIx);
    if (this.tokenX.publicKey.equals(_spltoken.NATIVE_MINT)) {
      const wrapSOLIx = wrapSOLInstruction(user, userTokenX, BigInt(totalXAmount.toString()));
      preInstructions.push(...wrapSOLIx);
    }
    if (this.tokenY.publicKey.equals(_spltoken.NATIVE_MINT)) {
      const wrapSOLIx = wrapSOLInstruction(user, userTokenY, BigInt(totalYAmount.toString()));
      preInstructions.push(...wrapSOLIx);
    }
    const postInstructions = [];
    if ([this.tokenX.publicKey.toBase58(), this.tokenY.publicKey.toBase58()].includes(_spltoken.NATIVE_MINT.toBase58())) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    const setComputeUnitLimitIx = _web3js.ComputeBudgetProgram.setComputeUnitLimit({
      units: 14e5
    });
    const liquidityParams = {
      amountX: totalXAmount,
      amountY: totalYAmount,
      binLiquidityDist,
      activeId,
      maxActiveBinSlippage: MAX_ACTIVE_BIN_SLIPPAGE
    };
    const addLiquidityAccounts = {
      position: positionPubKey,
      lbPair: this.pubkey,
      userTokenX,
      userTokenY,
      reserveX: this.lbPair.reserveX,
      reserveY: this.lbPair.reserveY,
      tokenXMint: this.lbPair.tokenXMint,
      tokenYMint: this.lbPair.tokenYMint,
      binArrayLower,
      binArrayUpper,
      binArrayBitmapExtension,
      sender: user,
      tokenXProgram: _spltoken.TOKEN_PROGRAM_ID,
      tokenYProgram: _spltoken.TOKEN_PROGRAM_ID
    };
    const oneSideLiquidityParams = {
      amount: totalXAmount.isZero() ? totalYAmount : totalXAmount,
      activeId,
      maxActiveBinSlippage: MAX_ACTIVE_BIN_SLIPPAGE,
      binLiquidityDist
    };
    const oneSideAddLiquidityAccounts = {
      binArrayLower,
      binArrayUpper,
      lbPair: this.pubkey,
      binArrayBitmapExtension: null,
      sender: user,
      position: positionPubKey,
      reserve: totalXAmount.isZero() ? this.lbPair.reserveY : this.lbPair.reserveX,
      tokenMint: totalXAmount.isZero() ? this.lbPair.tokenYMint : this.lbPair.tokenXMint,
      tokenProgram: _spltoken.TOKEN_PROGRAM_ID,
      userToken: totalXAmount.isZero() ? userTokenY : userTokenX
    };
    const isOneSideDeposit = totalXAmount.isZero() || totalYAmount.isZero();
    const programMethod = isOneSideDeposit ? this.program.methods.addLiquidityOneSide(oneSideLiquidityParams) : this.program.methods.addLiquidityByWeight(liquidityParams);
    if (xYAmountDistribution.length < MAX_BIN_LENGTH_ALLOWED_IN_ONE_TX) {
      const addLiqTx2 = await programMethod.accounts(isOneSideDeposit ? oneSideAddLiquidityAccounts : addLiquidityAccounts).preInstructions([setComputeUnitLimitIx, ...preInstructions]).postInstructions(postInstructions).transaction();
      const { blockhash: blockhash2, lastValidBlockHeight: lastValidBlockHeight2 } = await this.program.provider.connection.getLatestBlockhash(
        "confirmed"
      );
      return new (0, _web3js.Transaction)({
        blockhash: blockhash2,
        lastValidBlockHeight: lastValidBlockHeight2,
        feePayer: user
      }).add(addLiqTx2);
    }
    const addLiqTx = await programMethod.accounts(isOneSideDeposit ? oneSideAddLiquidityAccounts : addLiquidityAccounts).preInstructions([setComputeUnitLimitIx]).transaction();
    const transactions = [];
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    if (preInstructions.length) {
      const preInstructionsTx = new (0, _web3js.Transaction)({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(...preInstructions);
      transactions.push(preInstructionsTx);
    }
    const mainTx = new (0, _web3js.Transaction)({
      blockhash,
      lastValidBlockHeight,
      feePayer: user
    }).add(addLiqTx);
    transactions.push(mainTx);
    if (postInstructions.length) {
      const postInstructionsTx = new (0, _web3js.Transaction)({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(...postInstructions);
      transactions.push(postInstructionsTx);
    }
    return transactions;
  }
  processXYAmountDistribution(xYAmountDistribution) {
    let currentBinId = null;
    const xAmountDistribution = [];
    const yAmountDistribution = [];
    const binIds = [];
    xYAmountDistribution.forEach((binAndAmount) => {
      xAmountDistribution.push(binAndAmount.xAmountBpsOfTotal);
      yAmountDistribution.push(binAndAmount.yAmountBpsOfTotal);
      binIds.push(binAndAmount.binId);
      if (currentBinId && binAndAmount.binId !== currentBinId + 1) {
        throw new Error("Discontinuous Bin ID");
      } else {
        currentBinId = binAndAmount.binId;
      }
    });
    return {
      lowerBinId: xYAmountDistribution[0].binId,
      upperBinId: xYAmountDistribution[xYAmountDistribution.length - 1].binId,
      xAmountDistribution,
      yAmountDistribution,
      binIds
    };
  }
  async createBinArraysIfNeeded(lbPair, binArrayIndexes, funder) {
    const ixs = [];
    for (const idx of binArrayIndexes) {
      const [binArray] = deriveBinArray(lbPair, idx, this.program.programId);
      const binArrayAccount = await this.program.provider.connection.getAccountInfo(binArray);
      if (binArrayAccount == null) {
        ixs.push(
          await this.program.methods.initializeBinArray(idx).accounts({
            binArray,
            funder,
            lbPair
          }).instruction()
        );
      }
    }
    return ixs;
  }
  async removeLiquidity({
    user,
    position,
    binIds,
    liquiditiesBpsToRemove,
    shouldClaimAndClose = false
  }) {
    const { lbPair, lowerBinId } = await this.program.account.positionV2.fetch(position);
    if (binIds.length !== liquiditiesBpsToRemove.length)
      throw new Error("binIds and liquiditiesBpsToRemove should be of equal length");
    const { reserveX, reserveY, tokenXMint, tokenYMint } = await this.program.account.lbPair.fetch(lbPair);
    const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(lowerBinId));
    const upperBinArrayIndex = lowerBinArrayIndex.add(new (0, _anchor.BN)(1));
    const [binArrayLower] = deriveBinArray(lbPair, lowerBinArrayIndex, this.program.programId);
    const [binArrayUpper] = deriveBinArray(lbPair, upperBinArrayIndex, this.program.programId);
    const preInstructions = [];
    const setComputeUnitLimitIx = _web3js.ComputeBudgetProgram.setComputeUnitLimit({
      units: 14e5
    });
    preInstructions.push(setComputeUnitLimitIx);
    const [{ ataPubKey: userTokenX, ix: createPayerTokenXIx }, { ataPubKey: userTokenY, ix: createPayerTokenYIx }] = await Promise.all([
      getOrCreateATAInstruction(this.program.provider.connection, this.tokenX.publicKey, user),
      getOrCreateATAInstruction(this.program.provider.connection, this.tokenY.publicKey, user)
    ]);
    createPayerTokenXIx && preInstructions.push(createPayerTokenXIx);
    createPayerTokenYIx && preInstructions.push(createPayerTokenYIx);
    const secondTransactionsIx = [];
    const postInstructions = [];
    if (shouldClaimAndClose) {
      const claimSwapFeeIx = await this.program.methods.claimFee().accounts({
        binArrayLower,
        binArrayUpper,
        lbPair: this.pubkey,
        sender: user,
        position,
        reserveX,
        reserveY,
        tokenProgram: _spltoken.TOKEN_PROGRAM_ID,
        tokenXMint: this.tokenX.publicKey,
        tokenYMint: this.tokenY.publicKey,
        userTokenX,
        userTokenY
      }).instruction();
      postInstructions.push(claimSwapFeeIx);
      for (let i = 0; i < 2; i++) {
        const rewardInfo = this.lbPair.rewardInfos[i];
        if (!rewardInfo || rewardInfo.mint.equals(_web3js.PublicKey.default))
          continue;
        const { ataPubKey, ix: rewardAtaIx } = await getOrCreateATAInstruction(
          this.program.provider.connection,
          rewardInfo.mint,
          user
        );
        rewardAtaIx && preInstructions.push(rewardAtaIx);
        const claimRewardIx = await this.program.methods.claimReward(new (0, _anchor.BN)(i)).accounts({
          lbPair: this.pubkey,
          sender: user,
          position,
          binArrayLower,
          binArrayUpper,
          rewardVault: rewardInfo.vault,
          rewardMint: rewardInfo.mint,
          tokenProgram: _spltoken.TOKEN_PROGRAM_ID,
          userTokenAccount: ataPubKey
        }).instruction();
        secondTransactionsIx.push(claimRewardIx);
      }
      const closePositionIx = await this.program.methods.closePosition().accounts({
        binArrayLower,
        binArrayUpper,
        rentReceiver: user,
        position,
        lbPair: this.pubkey,
        sender: user
      }).instruction();
      if (secondTransactionsIx.length) {
        secondTransactionsIx.push(closePositionIx);
      } else {
        postInstructions.push(closePositionIx);
      }
    }
    if ([this.tokenX.publicKey.toBase58(), this.tokenY.publicKey.toBase58()].includes(_spltoken.NATIVE_MINT.toBase58())) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    const binLiquidityReduction = binIds.map((binId, idx) => {
      return {
        binId,
        bpsToRemove: liquiditiesBpsToRemove[idx].toNumber()
      };
    });
    const minBinId = Math.min(...binIds);
    const maxBinId = Math.max(...binIds);
    const minBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(minBinId));
    const maxBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(maxBinId));
    const useExtension = isOverflowDefaultBinArrayBitmap(minBinArrayIndex) || isOverflowDefaultBinArrayBitmap(maxBinArrayIndex);
    const binArrayBitmapExtension = useExtension ? deriveBinArrayBitmapExtension(this.pubkey, this.program.programId)[0] : null;
    const removeLiquidityTx = await this.program.methods.removeLiquidity(binLiquidityReduction).accounts({
      position,
      lbPair,
      userTokenX,
      userTokenY,
      reserveX,
      reserveY,
      tokenXMint,
      tokenYMint,
      binArrayLower,
      binArrayUpper,
      binArrayBitmapExtension,
      tokenXProgram: _spltoken.TOKEN_PROGRAM_ID,
      tokenYProgram: _spltoken.TOKEN_PROGRAM_ID,
      sender: user
    }).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    if (secondTransactionsIx.length) {
      const claimRewardsTx = new (0, _web3js.Transaction)({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(...secondTransactionsIx);
      const mainTx = new (0, _web3js.Transaction)({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(removeLiquidityTx);
      return [mainTx, claimRewardsTx];
    } else {
      return new (0, _web3js.Transaction)({
        blockhash,
        lastValidBlockHeight,
        feePayer: user
      }).add(removeLiquidityTx);
    }
  }
  async closePosition({
    owner,
    position
  }) {
    const { lowerBinId } = await this.program.account.positionV2.fetch(position.publicKey);
    const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(lowerBinId));
    const [binArrayLower] = deriveBinArray(this.pubkey, lowerBinArrayIndex, this.program.programId);
    const upperBinArrayIndex = lowerBinArrayIndex.add(new (0, _anchor.BN)(1));
    const [binArrayUpper] = deriveBinArray(this.pubkey, upperBinArrayIndex, this.program.programId);
    const closePositionTx = await this.program.methods.closePosition().accounts({
      binArrayLower,
      binArrayUpper,
      rentReceiver: owner,
      position: position.publicKey,
      lbPair: this.pubkey,
      sender: owner
    }).transaction();
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new (0, _web3js.Transaction)({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(closePositionTx);
  }
  /**
   * Returns an equal weightage amount of the opposing token based on ratio.
   * @param {number} lbPair - The pubkey of the LB Pair
   * @param {"X" | "Y"} token - X or Y as string. If X, returns equal weightage of Y or if Y, returns equal weightage of X.
   * @param {BN} tokenAmount - The amount of token X or token Y. If token is "X", pass in the amount of token X. If token is "Y", pass in the amount of token Y.
   * @returns {BN} The equal weightage of the opposing token. If tokenXAmount was passed in, token Y amount is returned else if tokenYAmount was passed in, token X amount is returned
   */
  async getEqualWeightageAmount(lbPairPubKey, token, tokenAmount) {
    const {
      bins: [activeBin]
    } = await this.getBinsAroundActiveBin(0, 0);
    if (new (0, _decimaljs2.default)(activeBin.yAmount.toString()).gt(new (0, _decimaljs2.default)("0"))) {
      const xYRatio = new (0, _decimaljs2.default)(activeBin.xAmount.toString()).div(new (0, _decimaljs2.default)(activeBin.yAmount.toString()));
      if (token === "X")
        return new (0, _anchor.BN)(new (0, _decimaljs2.default)(tokenAmount.toString()).mul(new (0, _decimaljs2.default)(1).div(xYRatio)).floor().toString());
      if (token === "Y")
        return new (0, _anchor.BN)(new (0, _decimaljs2.default)(tokenAmount.toString()).mul(xYRatio).floor().toString());
    }
    if (token === "X")
      return new (0, _anchor.BN)(new (0, _decimaljs2.default)(tokenAmount.toString()).mul(new (0, _decimaljs2.default)(activeBin.price)).toString());
    if (token === "Y")
      return new (0, _anchor.BN)(new (0, _decimaljs2.default)(tokenAmount.toString()).div(new (0, _decimaljs2.default)(activeBin.price)).toString());
  }
  updateVolatilityAccumulator(vParameter, sParameter, activeId) {
    const deltaId = Math.abs(vParameter.indexReference - activeId);
    const newVolatilityAccumulator = vParameter.volatilityReference + deltaId * BASIS_POINT_MAX;
    vParameter.volatilityAccumulator = Math.min(newVolatilityAccumulator, sParameter.maxVolatilityAccumulator);
  }
  updateReference(activeId, vParameter, sParameter, currentTimestamp) {
    const elapsed = currentTimestamp - vParameter.lastUpdateTimestamp.toNumber();
    if (elapsed >= sParameter.filterPeriod) {
      vParameter.indexReference = activeId;
      if (elapsed < sParameter.decayPeriod) {
        const decayedVolatilityReference = Math.floor(
          vParameter.volatilityAccumulator * sParameter.reductionFactor / BASIS_POINT_MAX
        );
        vParameter.volatilityReference = decayedVolatilityReference;
      } else {
        vParameter.volatilityReference = 0;
      }
    }
  }
  /**
   * inAmount: Amount of lamport to swap in
   * swapForY: Swap token X to Y when it is true, else reversed.
   * allowedSlipage: Allowed slippage for the swap. Expressed in BPS. To convert from slippage percentage to BPS unit: SLIPPAGE_PERCENTAGE * 100
   * binArrays: Array of bin arrays to swap from (Can fetch from `getBinArrays`)
   */
  swapQuote(inAmount, swapForY, allowedSlippage, binArrays) {
    const currentTimestamp = Date.now() / 1e3;
    let inAmountLeft = inAmount;
    let vParameterClone = Object.assign({}, this.lbPair.vParameters);
    let activeId = new (0, _anchor.BN)(this.lbPair.activeId);
    const binStep = this.lbPair.binStep;
    const sParameters2 = this.lbPair.parameters;
    this.updateReference(activeId.toNumber(), vParameterClone, sParameters2, currentTimestamp);
    let startBin = null;
    let binArraysForSwap = /* @__PURE__ */ new Map();
    let actualOutAmount = new (0, _anchor.BN)(0);
    let feeAmount = new (0, _anchor.BN)(0);
    let protocolFeeAmount = new (0, _anchor.BN)(0);
    while (!inAmountLeft.isZero()) {
      let binArrayAccountToSwap = findNextBinArrayWithLiquidity(
        swapForY,
        activeId,
        this.lbPair,
        _optionalChain([this, 'access', _20 => _20.binArrayBitmapExtension, 'optionalAccess', _21 => _21.account]),
        binArrays
      );
      if (binArrayAccountToSwap == null) {
        throw new Error("Insufficient liquidity");
      }
      binArraysForSwap.set(binArrayAccountToSwap.publicKey, true);
      this.updateVolatilityAccumulator(vParameterClone, sParameters2, activeId.toNumber());
      if (isBinIdWithinBinArray(activeId, binArrayAccountToSwap.account.index)) {
        const bin = getBinFromBinArray(activeId.toNumber(), binArrayAccountToSwap.account);
        const { amountIn, amountOut, fee, protocolFee } = swapQuoteAtBin(
          bin,
          binStep,
          sParameters2,
          vParameterClone,
          inAmountLeft,
          swapForY
        );
        if (!amountIn.isZero()) {
          inAmountLeft = inAmountLeft.sub(amountIn);
          actualOutAmount = actualOutAmount.add(amountOut);
          feeAmount = feeAmount.add(fee);
          protocolFeeAmount = protocolFee.add(protocolFee);
          if (!startBin) {
            startBin = bin;
          }
        }
      }
      if (!inAmountLeft.isZero()) {
        if (swapForY) {
          activeId = activeId.sub(new (0, _anchor.BN)(1));
        } else {
          activeId = activeId.add(new (0, _anchor.BN)(1));
        }
      }
    }
    const outAmountWithoutSlippage = getOutAmount(
      startBin,
      inAmount.sub(computeFeeFromAmount(binStep, sParameters2, vParameterClone, inAmount)),
      swapForY
    );
    const priceImpact = new (0, _decimaljs2.default)(actualOutAmount.toString()).sub(new (0, _decimaljs2.default)(outAmountWithoutSlippage.toString())).div(new (0, _decimaljs2.default)(outAmountWithoutSlippage.toString())).mul(new (0, _decimaljs2.default)(100));
    const minOutAmount = actualOutAmount.mul(new (0, _anchor.BN)(BASIS_POINT_MAX).sub(allowedSlippage)).div(new (0, _anchor.BN)(BASIS_POINT_MAX));
    return {
      outAmount: actualOutAmount,
      fee: feeAmount,
      protocolFee: protocolFeeAmount,
      minOutAmount,
      priceImpact,
      binArraysPubkey: [...binArraysForSwap.keys()]
    };
  }
  /**
   * Returns a transaction to be signed and sent by user performing swap.
   * @param {SwapParams} {inToken, outToken, inAmount, minOutAmount, lbPair, user, outTokenAccount, inTokenAccount}
   * @returns {Transaction}
   */
  async swap({ inToken, outToken, inAmount, minOutAmount, lbPair, user, binArraysPubkey }) {
    const { tokenXMint, tokenYMint, reserveX, reserveY, activeId, oracle } = await this.program.account.lbPair.fetch(
      lbPair
    );
    const preInstructions = [
      _web3js.ComputeBudgetProgram.setComputeUnitLimit({
        units: 14e5
      })
    ];
    const [
      { ataPubKey: userTokenIn, ix: createInTokenAccountIx },
      { ataPubKey: userTokenOut, ix: createOutTokenAccountIx }
    ] = await Promise.all([
      getOrCreateATAInstruction(this.program.provider.connection, inToken, user),
      getOrCreateATAInstruction(this.program.provider.connection, outToken, user)
    ]);
    createInTokenAccountIx && preInstructions.push(createInTokenAccountIx);
    createOutTokenAccountIx && preInstructions.push(createOutTokenAccountIx);
    if (inToken.equals(_spltoken.NATIVE_MINT)) {
      const wrapSOLIx = wrapSOLInstruction(user, userTokenIn, BigInt(inAmount.toString()));
      preInstructions.push(...wrapSOLIx);
    }
    const postInstructions = [];
    if (outToken.equals(_spltoken.NATIVE_MINT)) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(user);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    let swapForY = true;
    if (outToken.equals(tokenXMint))
      swapForY = false;
    const binArrays = binArraysPubkey.map((pubkey) => {
      return {
        isSigner: false,
        isWritable: true,
        pubkey
      };
    });
    return await this.program.methods.swap(inAmount, minOutAmount).accounts({
      lbPair,
      reserveX,
      reserveY,
      tokenXMint,
      tokenYMint,
      tokenXProgram: _spltoken.TOKEN_PROGRAM_ID,
      // dont use 2022 first; lack familiarity
      tokenYProgram: _spltoken.TOKEN_PROGRAM_ID,
      // dont use 2022 first; lack familiarity
      user,
      userTokenIn,
      userTokenOut,
      binArrayBitmapExtension: this.binArrayBitmapExtension ? this.binArrayBitmapExtension.publicKey : null,
      oracle,
      hostFeeIn: null
    }).remainingAccounts(binArrays).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
  }
  async createClaimBuildMethod({
    owner,
    position,
    shouldIncludePreIx = true
  }) {
    const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(position.positionData.lowerBinId));
    const [binArrayLower] = deriveBinArray(this.pubkey, lowerBinArrayIndex, this.program.programId);
    const upperBinArrayIndex = lowerBinArrayIndex.add(new (0, _anchor.BN)(1));
    const [binArrayUpper] = deriveBinArray(this.pubkey, upperBinArrayIndex, this.program.programId);
    const claimTransactions = [];
    for (let i = 0; i < 2; i++) {
      const rewardInfo = this.lbPair.rewardInfos[i];
      if (!rewardInfo || rewardInfo.mint.equals(_web3js.PublicKey.default))
        continue;
      const preInstructions = [];
      const { ataPubKey, ix } = await getOrCreateATAInstruction(
        this.program.provider.connection,
        rewardInfo.mint,
        owner
      );
      ix && preInstructions.push(ix);
      const claimTransaction = await this.program.methods.claimReward(new (0, _anchor.BN)(i)).accounts({
        lbPair: this.pubkey,
        sender: owner,
        position: position.publicKey,
        binArrayLower,
        binArrayUpper,
        rewardVault: rewardInfo.vault,
        rewardMint: rewardInfo.mint,
        tokenProgram: _spltoken.TOKEN_PROGRAM_ID,
        userTokenAccount: ataPubKey
      }).preInstructions(shouldIncludePreIx ? preInstructions : []).transaction();
      claimTransactions.push(claimTransaction);
    }
    return claimTransactions;
  }
  async createClaimSwapFeeMethod({
    owner,
    position,
    shouldIncludePretIx = true,
    shouldIncludePostIx = true
  }) {
    const { lowerBinId } = position.positionData;
    const lowerBinArrayIndex = binIdToBinArrayIndex(new (0, _anchor.BN)(lowerBinId));
    const [binArrayLower] = deriveBinArray(this.pubkey, lowerBinArrayIndex, this.program.programId);
    const upperBinArrayIndex = lowerBinArrayIndex.add(new (0, _anchor.BN)(1));
    const [binArrayUpper] = deriveBinArray(this.pubkey, upperBinArrayIndex, this.program.programId);
    const [reserveX] = deriveReserve(this.tokenX.publicKey, this.pubkey, this.program.programId);
    const [reserveY] = deriveReserve(this.tokenY.publicKey, this.pubkey, this.program.programId);
    const preInstructions = [];
    const [
      { ataPubKey: userTokenX, ix: createInTokenAccountIx },
      { ataPubKey: userTokenY, ix: createOutTokenAccountIx }
    ] = await Promise.all([
      getOrCreateATAInstruction(this.program.provider.connection, this.tokenX.publicKey, owner),
      getOrCreateATAInstruction(this.program.provider.connection, this.tokenY.publicKey, owner)
    ]);
    createInTokenAccountIx && preInstructions.push(createInTokenAccountIx);
    createOutTokenAccountIx && preInstructions.push(createOutTokenAccountIx);
    const postInstructions = [];
    if ([this.tokenX.publicKey.toBase58(), this.tokenY.publicKey.toBase58()].includes(_spltoken.NATIVE_MINT.toBase58())) {
      const closeWrappedSOLIx = await unwrapSOLInstruction(owner);
      closeWrappedSOLIx && postInstructions.push(closeWrappedSOLIx);
    }
    const claimFeeTx = await this.program.methods.claimFee().accounts({
      binArrayLower,
      binArrayUpper,
      lbPair: this.pubkey,
      sender: owner,
      position: position.publicKey,
      reserveX,
      reserveY,
      tokenProgram: _spltoken.TOKEN_PROGRAM_ID,
      tokenXMint: this.tokenX.publicKey,
      tokenYMint: this.tokenY.publicKey,
      userTokenX,
      userTokenY
    }).preInstructions(shouldIncludePretIx ? preInstructions : []).postInstructions(shouldIncludePostIx ? postInstructions : []).transaction();
    return claimFeeTx;
  }
  static async getClaimableLMReward(program, positionVersion, lbPair, position, lowerBinArray, upperBinArray) {
    const lowerBinArrayIdx = binIdToBinArrayIndex(new (0, _anchor.BN)(position.lowerBinId));
    const currentTimestamp = Date.now() / 1e3;
    let rewards = [new (0, _anchor.BN)(0), new (0, _anchor.BN)(0)];
    let _lowerBinArray = lowerBinArray;
    let _upperBinArray = upperBinArray;
    if (!lowerBinArray || !upperBinArray) {
      const lowerBinArrayIdx2 = binIdToBinArrayIndex(new (0, _anchor.BN)(position.lowerBinId));
      const [lowerBinArray2] = deriveBinArray(position.lbPair, lowerBinArrayIdx2, program.programId);
      const upperBinArrayIdx = lowerBinArrayIdx2.add(new (0, _anchor.BN)(1));
      const [upperBinArray2] = deriveBinArray(position.lbPair, upperBinArrayIdx, program.programId);
      [_lowerBinArray, _upperBinArray] = await program.account.binArray.fetchMultiple([lowerBinArray2, upperBinArray2]);
    }
    for (let i = position.lowerBinId; i <= position.upperBinId; i++) {
      const binArrayIdx = binIdToBinArrayIndex(new (0, _anchor.BN)(i));
      const binArray = binArrayIdx.eq(lowerBinArrayIdx) ? _lowerBinArray : _upperBinArray;
      const binState = getBinFromBinArray(i, binArray);
      const binIdxInPosition = i - position.lowerBinId;
      const positionRewardInfo = position.rewardInfos[binIdxInPosition];
      const liquidityShare = positionVersion === 0 /* V1 */ ? position.liquidityShares[binIdxInPosition] : position.liquidityShares[binIdxInPosition].shrn(64);
      for (let j = 0; j < 2; j++) {
        const pairRewardInfo = lbPair.rewardInfos[j];
        if (!pairRewardInfo.mint.equals(_web3js.PublicKey.default)) {
          let rewardPerTokenStored = binState.rewardPerTokenStored[j];
          if (i == lbPair.activeId && !binState.liquiditySupply.isZero()) {
            const currentTime = new (0, _anchor.BN)(Math.min(currentTimestamp, pairRewardInfo.rewardDurationEnd.toNumber()));
            const delta2 = currentTime.sub(pairRewardInfo.lastUpdateTime);
            const liquiditySupply = binArray.version == 0 ? binState.liquiditySupply : binState.liquiditySupply.shrn(64);
            const rewardPerTokenStoredDelta = pairRewardInfo.rewardRate.mul(delta2).div(liquiditySupply);
            rewardPerTokenStored = rewardPerTokenStored.add(rewardPerTokenStoredDelta);
          }
          const delta = rewardPerTokenStored.sub(positionRewardInfo.rewardPerTokenCompletes[j]);
          const newReward = mulShr(delta, liquidityShare, SCALE_OFFSET, 1 /* Down */);
          rewards[j] = rewards[j].add(newReward).add(positionRewardInfo.rewardPendings[j]);
        }
      }
    }
    return {
      rewardOne: rewards[0],
      rewardTwo: rewards[1]
    };
  }
  async claimLMReward({
    owner,
    position
  }) {
    const claimTransactions = await this.createClaimBuildMethod({ owner, position });
    if (!claimTransactions.length)
      return;
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new (0, _web3js.Transaction)({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(...claimTransactions);
  }
  async claimAllLMRewards({
    owner,
    positions
  }) {
    const claimAllTxs = (await Promise.all(
      positions.map(async (position, idx) => {
        return await this.createClaimBuildMethod({ owner, position, shouldIncludePreIx: idx === 0 });
      })
    )).flat();
    const chunkedClaimAllTx = chunks(claimAllTxs, MAX_CLAIM_ALL_ALLOWED);
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return Promise.all(
      chunkedClaimAllTx.map(async (claimAllTx) => {
        return new (0, _web3js.Transaction)({
          feePayer: owner,
          blockhash,
          lastValidBlockHeight
        }).add(computeBudgetIx()).add(...claimAllTx);
      })
    );
  }
  static async getClaimableSwapFee(program, positionVersion, position, lowerBinArray, upperBinArray) {
    const lowerBinArrayIdx = binIdToBinArrayIndex(new (0, _anchor.BN)(position.lowerBinId));
    let feeX = new (0, _anchor.BN)(0);
    let feeY = new (0, _anchor.BN)(0);
    let _lowerBinArray = lowerBinArray;
    let _upperBinArray = upperBinArray;
    if (!lowerBinArray || !upperBinArray) {
      const lowerBinArrayIdx2 = binIdToBinArrayIndex(new (0, _anchor.BN)(position.lowerBinId));
      const [lowerBinArray2] = deriveBinArray(position.lbPair, lowerBinArrayIdx2, program.programId);
      const upperBinArrayIdx = lowerBinArrayIdx2.add(new (0, _anchor.BN)(1));
      const [upperBinArray2] = deriveBinArray(position.lbPair, upperBinArrayIdx, program.programId);
      [_lowerBinArray, _upperBinArray] = await program.account.binArray.fetchMultiple([lowerBinArray2, upperBinArray2]);
    }
    for (let i = position.lowerBinId; i <= position.upperBinId; i++) {
      const binArrayIdx = binIdToBinArrayIndex(new (0, _anchor.BN)(i));
      const binArray = binArrayIdx.eq(lowerBinArrayIdx) ? _lowerBinArray : _upperBinArray;
      const binState = getBinFromBinArray(i, binArray);
      const binIdxInPosition = i - position.lowerBinId;
      const feeInfos = position.feeInfos[binIdxInPosition];
      const liquidityShare = positionVersion === 0 /* V1 */ ? position.liquidityShares[binIdxInPosition] : position.liquidityShares[binIdxInPosition].shrn(64);
      const newFeeX = mulShr(
        liquidityShare,
        binState.feeAmountXPerTokenStored.sub(feeInfos.feeXPerTokenComplete),
        SCALE_OFFSET,
        1 /* Down */
      );
      const newFeeY = mulShr(
        liquidityShare,
        binState.feeAmountYPerTokenStored.sub(feeInfos.feeYPerTokenComplete),
        SCALE_OFFSET,
        1 /* Down */
      );
      feeX = feeX.add(newFeeX).add(feeInfos.feeXPending);
      feeY = feeY.add(newFeeY).add(feeInfos.feeYPending);
    }
    return { feeX, feeY };
  }
  async claimSwapFee({
    owner,
    position
  }) {
    const claimFeeTx = await this.createClaimSwapFeeMethod({ owner, position });
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return new (0, _web3js.Transaction)({
      blockhash,
      lastValidBlockHeight,
      feePayer: owner
    }).add(claimFeeTx);
  }
  async claimAllSwapFee({
    owner,
    positions
  }) {
    const claimAllTxs = (await Promise.all(
      positions.map(async (position, idx) => {
        return await this.createClaimSwapFeeMethod({
          owner,
          position,
          shouldIncludePretIx: idx === 0,
          shouldIncludePostIx: idx === positions.length - 1
        });
      })
    )).flat();
    const chunkedClaimAllTx = chunks(claimAllTxs, MAX_CLAIM_ALL_ALLOWED);
    return Promise.all(
      chunkedClaimAllTx.map(async (claimAllTx) => {
        const { recentBlockhash, lastValidBlockHeight } = claimAllTx[0];
        return new (0, _web3js.Transaction)({
          feePayer: owner,
          blockhash: recentBlockhash,
          lastValidBlockHeight
        }).add(computeBudgetIx()).add(...claimAllTx);
      })
    );
  }
  async claimAllRewardsByPosition({
    owner,
    position
  }) {
    const claimAllSwapFeeTxs = await this.createClaimSwapFeeMethod({ owner, position });
    const claimAllLMTxs = await this.createClaimBuildMethod({ owner, position });
    const claimAllTxs = chunks([claimAllSwapFeeTxs, ...claimAllLMTxs], MAX_CLAIM_ALL_ALLOWED);
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return Promise.all(
      claimAllTxs.map(async (claimAllTx) => {
        return new (0, _web3js.Transaction)({
          feePayer: owner,
          blockhash,
          lastValidBlockHeight
        }).add(computeBudgetIx()).add(...claimAllTx);
      })
    );
  }
  async claimAllRewards({
    owner,
    positions
  }) {
    const claimAllSwapFeeTxs = (await Promise.all(
      positions.map(async (position, idx) => {
        return await this.createClaimSwapFeeMethod({
          owner,
          position,
          shouldIncludePretIx: idx === 0,
          shouldIncludePostIx: idx === positions.length - 1
        });
      })
    )).flat();
    const claimAllLMTxs = (await Promise.all(
      positions.map(async (position, idx) => {
        return await this.createClaimBuildMethod({ owner, position, shouldIncludePreIx: idx === 0 });
      })
    )).flat();
    const chunkedClaimAllTx = chunks([...claimAllSwapFeeTxs, ...claimAllLMTxs], MAX_CLAIM_ALL_ALLOWED);
    const { blockhash, lastValidBlockHeight } = await this.program.provider.connection.getLatestBlockhash("confirmed");
    return Promise.all(
      chunkedClaimAllTx.map(async (claimAllTx) => {
        return new (0, _web3js.Transaction)({
          feePayer: owner,
          blockhash,
          lastValidBlockHeight
        }).add(computeBudgetIx()).add(...claimAllTx);
      })
    );
  }
};

































































exports.ADMIN = ADMIN; exports.BASIS_POINT_MAX = BASIS_POINT_MAX; exports.BIN_ARRAY_BITMAP_SIZE = BIN_ARRAY_BITMAP_SIZE; exports.BitmapType = BitmapType; exports.DLMMError = error_default; exports.EXTENSION_BINARRAY_BITMAP_SIZE = EXTENSION_BINARRAY_BITMAP_SIZE; exports.FEE_PRECISION = FEE_PRECISION; exports.LBCLMM = LBCLMM; exports.LBCLMM_PROGRAM_IDS = LBCLMM_PROGRAM_IDS; exports.MAX_ACTIVE_BIN_SLIPPAGE = MAX_ACTIVE_BIN_SLIPPAGE; exports.MAX_BIN_ARRAY_SIZE = MAX_BIN_ARRAY_SIZE; exports.MAX_BIN_LENGTH_ALLOWED_IN_ONE_TX = MAX_BIN_LENGTH_ALLOWED_IN_ONE_TX; exports.MAX_BIN_PER_POSITION = MAX_BIN_PER_POSITION; exports.MAX_CLAIM_ALL_ALLOWED = MAX_CLAIM_ALL_ALLOWED; exports.MAX_FEE_RATE = MAX_FEE_RATE; exports.Network = Network; exports.PRECISION = PRECISION; exports.PositionVersion = PositionVersion; exports.SCALE = SCALE; exports.SCALE_OFFSET = SCALE_OFFSET; exports.SIMULATION_USER = SIMULATION_USER; exports.StrategyType = StrategyType; exports.binIdToBinArrayIndex = binIdToBinArrayIndex; exports.calculateBidAskDistribution = calculateBidAskDistribution; exports.calculateNormalDistribution = calculateNormalDistribution; exports.calculateSpotDistribution = calculateSpotDistribution; exports.chunkedFetchMultipleBinArrayBitmapExtensionAccount = chunkedFetchMultipleBinArrayBitmapExtensionAccount; exports.chunkedFetchMultiplePoolAccount = chunkedFetchMultiplePoolAccount; exports.chunkedGetMultipleAccountInfos = chunkedGetMultipleAccountInfos; exports.chunks = chunks; exports.computeBudgetIx = computeBudgetIx; exports.computeFee = computeFee; exports.computeFeeFromAmount = computeFeeFromAmount; exports.computeProtocolFee = computeProtocolFee; exports.deriveBinArray = deriveBinArray; exports.deriveBinArrayBitmapExtension = deriveBinArrayBitmapExtension; exports.deriveLbPair = deriveLbPair; exports.deriveOracle = deriveOracle; exports.derivePosition = derivePosition; exports.derivePresetParameter = derivePresetParameter; exports.deriveReserve = deriveReserve; exports.findNextBinArrayIndexWithLiquidity = findNextBinArrayIndexWithLiquidity; exports.findNextBinArrayWithLiquidity = findNextBinArrayWithLiquidity; exports.fromStrategyParamstoWeightDistribution = fromStrategyParamstoWeightDistribution; exports.fromWeightDistributionToAmount = fromWeightDistributionToAmount; exports.getBaseFee = getBaseFee; exports.getBinArrayLowerUpperBinId = getBinArrayLowerUpperBinId; exports.getBinFromBinArray = getBinFromBinArray; exports.getOrCreateATAInstruction = getOrCreateATAInstruction; exports.getOutAmount = getOutAmount; exports.getTokenBalance = getTokenBalance; exports.getTokenDecimals = getTokenDecimals; exports.getTotalFee = getTotalFee; exports.getVariableFee = getVariableFee; exports.isBinIdWithinBinArray = isBinIdWithinBinArray; exports.isOverflowDefaultBinArrayBitmap = isOverflowDefaultBinArrayBitmap; exports.parabolicParameter = parabolicParameter; exports.parseLogs = parseLogs; exports.spotParameter = spotParameter; exports.swapQuoteAtBin = swapQuoteAtBin; exports.toStrategyParameters = toStrategyParameters; exports.toWeightDistribution = toWeightDistribution; exports.unwrapSOLInstruction = unwrapSOLInstruction; exports.wrapSOLInstruction = wrapSOLInstruction;
//# sourceMappingURL=index.js.map