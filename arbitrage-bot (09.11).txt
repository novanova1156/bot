--- File: /home/newvovi5/arbitrage-bot-rust/.cargo/config.toml ---
# .cargo/config.toml
[build]
rustflags = [
    "-A", "dead_code",
    "-A", "unused_imports",
    "-A", "unused_variables",
    "-A", "unexpected_cfgs"
]
--- End File: /home/newvovi5/arbitrage-bot-rust/.cargo/config.toml ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/scanner/raydium_clmm.rs ---
// bot/src/scanner/raydium_clmm.rs
use anyhow::{Result, Context};
use rayon::prelude::*;
use solana_client::rpc_client::RpcClient;
use solana_client::rpc_config::{RpcAccountInfoConfig, RpcProgramAccountsConfig};
use solana_client::rpc_filter::{RpcFilterType, Memcmp, MemcmpEncodedBytes};
use solana_sdk::commitment_config::CommitmentConfig;
use solana_sdk::pubkey::Pubkey;
use std::sync::Arc;
use tracing::{info, warn};

use crate::config::BotConfig;
use crate::types::{PoolState, DexProtocol};
use super::DexScanner;

#[derive(Clone)]
pub struct RaydiumClmmScanner {
    rpc_client: Arc<RpcClient>,
    config: Arc<BotConfig>,
    program_id: Pubkey,
}

// –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è CLMM —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ –∫–ª—é—á–µ–≤—ã—Ö –ø–æ–ª–µ–π
#[derive(Debug)]
struct ClmmPoolInfo {
    token_mint_0: Pubkey,
    token_mint_1: Pubkey,
    token_vault_0: Pubkey,
    token_vault_1: Pubkey,
    tick_spacing: u16,
    liquidity: u128,
}

impl ClmmPoolInfo {
    /// –ü–∞—Ä—Å–∏–Ω–≥ CLMM pool –∏–∑ —Å—ã—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
    fn try_from_slice(data: &[u8]) -> Result<Self> {
        if data.len() < 400 {
            return Err(anyhow::anyhow!("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è CLMM pool"));
        }

        // –ü—Ä–∏–º–µ—Ä–Ω—ã–µ –æ—Ñ—Å–µ—Ç—ã –¥–ª—è CLMM (–Ω—É–∂–Ω–æ —É—Ç–æ—á–Ω–∏—Ç—å –ø–æ IDL)
        let token_mint_0 = crate::dex_structs::read_pubkey(data, 72)?;
        let token_mint_1 = crate::dex_structs::read_pubkey(data, 104)?;
        let token_vault_0 = crate::dex_structs::read_pubkey(data, 136)?;
        let token_vault_1 = crate::dex_structs::read_pubkey(data, 168)?;
        let tick_spacing = u16::from_le_bytes([data[200], data[201]]);
        let liquidity = u128::from_le_bytes(
            data[300..316].try_into().unwrap_or([0u8; 16])
        );

        Ok(Self {
            token_mint_0,
            token_mint_1,
            token_vault_0,
            token_vault_1,
            tick_spacing,
            liquidity,
        })
    }
}

impl RaydiumClmmScanner {
    pub fn new(config: Arc<BotConfig>, rpc_client: Arc<RpcClient>) -> Result<Self> {
        let program_id = config.dex.raydium_clmm.to_pubkey()
            .context("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π Raydium CLMM program ID")?;

        info!("üåä –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Raydium CLMM —Å–∫–∞–Ω–µ—Ä–∞ —Å program_id: {}", program_id);

        Ok(Self {
            rpc_client,
            config,
            program_id,
        })
    }

    fn parse_clmm_pool(&self, pool_id: Pubkey, data: &[u8]) -> Result<PoolState> {
        let pool_info = ClmmPoolInfo::try_from_slice(data)?;

        Ok(PoolState {
            id: pool_id,
            protocol: DexProtocol::RaydiumClmm,
            token_a: pool_info.token_mint_0,
            token_b: pool_info.token_mint_1,
            reserve_a: 0, // –ë—É–¥–µ—Ç –ø–æ–ª—É—á–µ–Ω–æ –∏–∑ vault'–æ–≤
            reserve_b: 0,
            fee_bps: 30, // –¢–∏–ø–∏—á–Ω–∞—è –∫–æ–º–∏—Å—Å–∏—è CLMM (0.3%)
            last_updated: chrono::Utc::now().timestamp(),
            full_state_data: data.to_vec(),
            decimals_a: 9,
            decimals_b: 9,
        })
    }
}

#[async_trait::async_trait]
impl DexScanner for RaydiumClmmScanner {
    fn protocol(&self) -> DexProtocol {
        DexProtocol::RaydiumClmm
    }

    async fn scan_pools(&self) -> Result<Vec<PoolState>> {
        info!("üì° –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ Raydium CLMM –ø—É–ª–æ–≤...");

        // –§–∏–ª—å—Ç—Ä—ã –¥–ª—è –ø–æ–∏—Å–∫–∞ CLMM –ø—É–ª–æ–≤
        let config = RpcProgramAccountsConfig {
            filters: Some(vec![
                RpcFilterType::DataSize(1544), // –†–∞–∑–º–µ—Ä CLMM pool account
            ]),
            account_config: RpcAccountInfoConfig {
                encoding: Some(solana_account_decoder::UiAccountEncoding::Base64),
                commitment: Some(CommitmentConfig::confirmed()),
                data_slice: None,
                min_context_slot: None,
            },
            with_context: None,
            sort_results: None,
        };

        let accounts = self.rpc_client
            .get_program_accounts_with_config(&self.program_id, config)
            .context("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è CLMM –∞–∫–∫–∞—É–Ω—Ç–æ–≤")?;

        info!("   üìä –ù–∞–π–¥–µ–Ω–æ {} –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö CLMM –ø—É–ª–æ–≤", accounts.len());

        // –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥
        let pools: Vec<PoolState> = accounts
            .par_iter()
            .filter_map(|(pubkey, account)| {
                match self.parse_clmm_pool(*pubkey, &account.data) {
                    Ok(pool) => Some(pool),
                    Err(e) => {
                        warn!("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å CLMM –ø—É–ª {}: {}", pubkey, e);
                        None
                    }
                }
            })
            .collect();

        info!("‚úÖ Raydium CLMM: –Ω–∞–π–¥–µ–Ω–æ {} –ø—É–ª–æ–≤", pools.len());
        Ok(pools)
    }

    fn clone_box(&self) -> Box<dyn DexScanner> {
        Box::new(self.clone())
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/scanner/raydium_clmm.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/scanner/pool_monitor.rs ---
// bot/src/scanner/pool_monitor.rs
// –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ –ø—É–ª–∞—Ö –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏

// use anyhow::Result;
use dashmap::DashMap;
use solana_sdk::pubkey::Pubkey;
use std::sync::Arc;
use tokio::time::{interval, Duration};
use tracing::{info, debug};

use crate::types::PoolState;

/// –ö—ç—à —Å–æ—Å—Ç–æ—è–Ω–∏–π –ø—É–ª–æ–≤ —Å –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
pub struct PoolMonitor {
    /// –ö—ç—à –ø—É–ª–æ–≤: pool_id -> PoolState
    cache: Arc<DashMap<Pubkey, PoolState>>,

    /// –ò–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö
    update_interval_ms: u64,
}

impl PoolMonitor {
    pub fn new(update_interval_ms: u64) -> Self {
        Self {
            cache: Arc::new(DashMap::new()),
            update_interval_ms,
        }
    }

    /// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø—É–ª–∞
    pub fn update_pool(&self, pool: PoolState) {
        let pool_id = pool.id;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è
        if let Some(old_pool) = self.cache.get(&pool_id) {
            let price_change = self.calculate_price_change(&old_pool, &pool);

            if price_change > 0.5 {
                debug!("–ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã –≤ –ø—É–ª–µ {}: {:.2}%",
                       pool_id, price_change);
            }
        }

        self.cache.insert(pool_id, pool);
    }

    /// –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –ø—É–ª–æ–≤ –∏–∑ –∫—ç—à–∞
    pub fn get_all_pools(&self) -> Vec<PoolState> {
        self.cache.iter()
            .map(|entry| entry.value().clone())
            .collect()
    }

    /// –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø—É–ª–∞
    pub fn get_pool(&self, pool_id: &Pubkey) -> Option<PoolState> {
        self.cache.get(pool_id).map(|entry| entry.value().clone())
    }

    /// –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—É–ª–æ–≤ –≤ –∫—ç—à–µ
    pub fn pool_count(&self) -> usize {
        self.cache.len()
    }

    /// –†–∞—Å—á—ë—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ü–µ–Ω—ã –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö
    fn calculate_price_change(&self, old: &PoolState, new: &PoolState) -> f64 {
        let old_price = old.price_a_to_b();
        let new_price = new.price_a_to_b();

        if old_price == 0.0 {
            return 0.0;
        }

        ((new_price - old_price) / old_price).abs() * 100.0
    }

    /// –û—á–∏—Å—Ç–∫–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –ø—É–ª–æ–≤ (—Å—Ç–∞—Ä—à–µ threshold_seconds)
    pub fn cleanup_stale_pools(&self, threshold_seconds: i64) {
        let now = chrono::Utc::now().timestamp();

        self.cache.retain(|_pool_id, pool| {
            let age = now - pool.last_updated;
            age < threshold_seconds
        });
    }
}

/// –§–æ–Ω–æ–≤–∞—è –∑–∞–¥–∞—á–∞ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–π –æ—á–∏—Å—Ç–∫–∏ –∫—ç—à–∞
pub async fn start_cache_cleanup_task(monitor: Arc<PoolMonitor>) {
    let mut cleanup_interval = interval(Duration::from_secs(60)); // –ö–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É

    loop {
        cleanup_interval.tick().await;

        let count_before = monitor.pool_count();
        monitor.cleanup_stale_pools(300); // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—à–µ 5 –º–∏–Ω—É—Ç
        let count_after = monitor.pool_count();

        if count_before != count_after {
            info!("üßπ –û—á–∏—Å—Ç–∫–∞ –∫—ç—à–∞: —É–¥–∞–ª–µ–Ω–æ {} —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –ø—É–ª–æ–≤",
                  count_before - count_after);
        }
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/scanner/pool_monitor.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/scanner/raydium_amm.rs ---
// bot/src/scanner/raydium_amm.rs
use anyhow::{Result, Context};
use rayon::prelude::*;
use solana_client::rpc_client::RpcClient;
use solana_client::rpc_config::{RpcAccountInfoConfig, RpcProgramAccountsConfig};
use solana_client::rpc_filter::RpcFilterType;
use solana_sdk::commitment_config::CommitmentConfig;
use solana_sdk::pubkey::Pubkey;
use solana_program_pack::Pack;
use spl_token::state::Account as TokenAccount;
use std::sync::Arc;
use std::collections::HashMap;
use tracing::{info, warn, debug};

use crate::config::BotConfig;
use crate::dex_structs::AmmInfo;
use crate::types::{DexProtocol, PoolState};
use super::DexScanner;

#[derive(Clone)]
pub struct RaydiumAmmScanner {
    rpc_client: Arc<RpcClient>,
    config: Arc<BotConfig>,
    program_id: Pubkey,
}

impl RaydiumAmmScanner {
    pub fn new(config: Arc<BotConfig>, rpc_client: Arc<RpcClient>) -> Result<Self> {
        let program_id = config.dex.raydium_amm_v4.to_pubkey()
            .context("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π Raydium AMM program ID –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏")?;

        info!("üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Raydium AMM —Å–∫–∞–Ω–µ—Ä–∞ —Å program_id: {}", program_id);

        Ok(Self {
            rpc_client,
            config,
            program_id,
        })
    }

    /// –°–ò–ù–•–†–û–ù–ù–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å rayon
    fn parse_pool_account_sync(&self, pool_id: Pubkey, data: &[u8]) -> Result<PoolState> {
        debug!("üîç –ü–∞—Ä—Å–∏–Ω–≥ –ø—É–ª–∞ {} (—Ä–∞–∑–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö: {} –±–∞–π—Ç)", pool_id, data.len());

        let amm_info = AmmInfo::try_from_slice(data)
            .context("–û—à–∏–±–∫–∞ –¥–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏ AmmInfo")?;

        // –í–ê–õ–ò–î–ê–¶–ò–Ø OpenBook ID
        let expected_openbook_id = self.config.dex.openbook_id.to_pubkey()
            .context("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π OpenBook ID –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏")?;

        if amm_info.market_program_id != expected_openbook_id {
            return Err(anyhow::anyhow!(
                "–ù–µ–≤–µ—Ä–Ω—ã–π market_program_id: –æ–∂–∏–¥–∞–ª—Å—è {}, –ø–æ–ª—É—á–µ–Ω {}",
                expected_openbook_id,
                amm_info.market_program_id
            ));
        }

        // –°–æ–∑–¥–∞–µ–º PoolState —Å –±–∞–∑–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ (—Ä–µ–∑–µ—Ä–≤—ã –±—É–¥—É—Ç –ø–æ–ª—É—á–µ–Ω—ã –æ—Ç–¥–µ–ª—å–Ω–æ)
        Ok(PoolState {
            id: pool_id,
            protocol: DexProtocol::RaydiumAmmV4,
            token_a: amm_info.base_mint,
            token_b: amm_info.quote_mint,
            reserve_a: 0, // –ë—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–æ –≤ fetch_vault_reserves_batch
            reserve_b: 0,
            fee_bps: (amm_info.fees.swap_fee_numerator * 10000 / amm_info.fees.swap_fee_denominator) as u16,
            last_updated: chrono::Utc::now().timestamp(),
            full_state_data: data.to_vec(),
            decimals_a: 9, // –î–û–ë–ê–í–õ–ï–ù–û
            decimals_b: 9, // –î–û–ë–ê–í–õ–ï–ù–û
        })
    }

    /// –ü–ê–ö–ï–¢–ù–û–ï –ø–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∑–µ—Ä–≤–æ–≤ vault'–æ–≤
    fn fetch_vault_reserves_batch(&self, pools: &mut [PoolState]) -> Result<()> {
        if pools.is_empty() {
            return Ok(());
        }

        // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ vault –∞–¥—Ä–µ—Å–∞
        let mut vault_keys = Vec::new();
        let mut pool_vault_map = HashMap::new();

        for (pool_idx, pool) in pools.iter().enumerate() {
            // –ü–∞—Ä—Å–∏–º amm_info –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è vault –∞–¥—Ä–µ—Å–æ–≤
            if let Ok(amm_info) = AmmInfo::try_from_slice(&pool.full_state_data) {
                vault_keys.push(amm_info.base_vault);
                vault_keys.push(amm_info.quote_vault);

                pool_vault_map.insert(amm_info.base_vault, (pool_idx, true));  // true = base
                pool_vault_map.insert(amm_info.quote_vault, (pool_idx, false)); // false = quote
            }
        }

        // –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã
        vault_keys.sort();
        vault_keys.dedup();

        info!("üìä –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∑–µ—Ä–≤–æ–≤ –¥–ª—è {} vault'–æ–≤", vault_keys.len());

        // –ü–ê–ö–ï–¢–ù–´–ï –∑–∞–ø—Ä–æ—Å—ã –ø–æ 100 –∞–∫–∫–∞—É–Ω—Ç–æ–≤
        let vault_accounts = self.get_multiple_accounts_batch(&vault_keys)?;

        // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–µ–∑–µ—Ä–≤—ã –≤ pools
        for (vault_key, account_opt) in vault_keys.iter().zip(vault_accounts.iter()) {
            if let (Some(account), Some((pool_idx, is_base))) = (account_opt, pool_vault_map.get(vault_key)) {
                if let Ok(token_account) = TokenAccount::unpack(&account.data) {
                    if *is_base {
                        pools[*pool_idx].reserve_a = token_account.amount;
                    } else {
                        pools[*pool_idx].reserve_b = token_account.amount;
                    }
                }
            }
        }

        Ok(())
    }

    /// –ü–∞–∫–µ—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å –∞–∫–∫–∞—É–Ω—Ç–æ–≤ —Å —Ä–∞–∑–±–∏–≤–∫–æ–π –Ω–∞ —á–∞–Ω–∫–∏ –ø–æ 100
    fn get_multiple_accounts_batch(&self, keys: &[Pubkey]) -> Result<Vec<Option<solana_sdk::account::Account>>> {
        const BATCH_SIZE: usize = 100;
        let mut all_accounts = Vec::with_capacity(keys.len());

        for chunk in keys.chunks(BATCH_SIZE) {
            let accounts = self.rpc_client.get_multiple_accounts(chunk)?;
            all_accounts.extend(accounts);
        }

        Ok(all_accounts)
    }
}

#[async_trait::async_trait]
impl DexScanner for RaydiumAmmScanner {
    fn protocol(&self) -> DexProtocol {
        DexProtocol::RaydiumAmmV4
    }

    async fn scan_pools(&self) -> Result<Vec<PoolState>> {
        info!("üì° –ù–∞—á–∏–Ω–∞–µ–º –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ Raydium AMM V4 –ø—É–ª–æ–≤...");
        info!("   üéØ Program ID: {}", self.program_id);

        let config = RpcProgramAccountsConfig {
            filters: Some(vec![RpcFilterType::DataSize(752)]), // –†–∞–∑–º–µ—Ä AmmInfo
            account_config: RpcAccountInfoConfig {
                encoding: Some(solana_account_decoder::UiAccountEncoding::Base64),
                commitment: Some(CommitmentConfig::confirmed()),
                data_slice: None,
                min_context_slot: None,
            },
            with_context: None,
            sort_results: None,
        };

        let accounts = self.rpc_client
            .get_program_accounts_with_config(&self.program_id, config)
            .context("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º—ã")?;

        info!("   üìä –ù–∞–π–¥–µ–Ω–æ {} –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –ø—É–ª–æ–≤", accounts.len());

        // –ü–ê–†–ê–õ–õ–ï–õ–¨–ù–´–ô –ø–∞—Ä—Å–∏–Ω–≥ —Å rayon
        let mut pools: Vec<PoolState> = accounts
            .par_iter()
            .filter_map(|(pubkey, account)| {
                match self.parse_pool_account_sync(*pubkey, &account.data) {
                    Ok(pool) => Some(pool),
                    Err(e) => {
                        debug!("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –ø—É–ª {}: {}", pubkey, e);
                        None
                    }
                }
            })
            .collect();

        info!("‚úÖ –£—Å–ø–µ—à–Ω–æ —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω–æ {} –≤–∞–ª–∏–¥–Ω—ã—Ö –ø—É–ª–æ–≤", pools.len());

        // –ü–ê–ö–ï–¢–ù–û–ï –ø–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∑–µ—Ä–≤–æ–≤
        if !pools.is_empty() {
            self.fetch_vault_reserves_batch(&mut pools)?;

            // –§–∏–ª—å—Ç—Ä—É–µ–º –ø—É–ª—ã —Å –Ω—É–ª–µ–≤—ã–º–∏ —Ä–µ–∑–µ—Ä–≤–∞–º–∏
            pools.retain(|pool| pool.reserve_a > 0 && pool.reserve_b > 0);

            info!("üí∞ –ü—É–ª–æ–≤ —Å –Ω–µ–Ω—É–ª–µ–≤—ã–º–∏ —Ä–µ–∑–µ—Ä–≤–∞–º–∏: {}", pools.len());
        }

        Ok(pools)
    }

    fn clone_box(&self) -> Box<dyn DexScanner> {
        Box::new(self.clone())
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/scanner/raydium_amm.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/scanner/mod.rs ---
// bot/src/scanner/mod.rs
pub mod pool_monitor; // –î–û–ë–ê–í–¨–¢–ï –≠–¢–£ –°–¢–†–û–ö–£ –í –ù–ê–ß–ê–õ–û
pub mod raydium_amm;
pub mod raydium_cpmm;
pub mod raydium_clmm;
pub mod meteora_dlmm;

use futures::future::join_all;
use anyhow::Result;
use async_trait::async_trait;
use std::sync::Arc;
use tracing::info;
use solana_client::rpc_client::RpcClient;

use crate::config::BotConfig;
use crate::types::{PoolState, DexProtocol};

use raydium_amm::RaydiumAmmScanner;
use raydium_cpmm::RaydiumCpmmScanner;
use raydium_clmm::RaydiumClmmScanner;
use meteora_dlmm::MeteoraDlmmScanner;

#[async_trait]
pub trait DexScanner: Send + Sync {
    fn protocol(&self) -> DexProtocol;
    async fn scan_pools(&self) -> Result<Vec<PoolState>>;
    fn clone_box(&self) -> Box<dyn DexScanner>;
}

pub struct MultiDexScanner {
    scanners: Vec<Box<dyn DexScanner>>,
    config: Arc<BotConfig>,
    cached_test_pools: std::sync::Mutex<Option<Vec<PoolState>>>,
}

impl MultiDexScanner {
    pub fn new(config: Arc<BotConfig>, rpc_client: Arc<RpcClient>) -> Self {
        let scanners: Vec<Box<dyn DexScanner>> = vec![
            Box::new(RaydiumAmmScanner::new(config.clone(), rpc_client.clone()).unwrap()),
            Box::new(RaydiumCpmmScanner::new(config.clone(), rpc_client.clone()).unwrap()),
            Box::new(RaydiumClmmScanner::new(config.clone(), rpc_client.clone()).unwrap()),
            Box::new(MeteoraDlmmScanner::new(config.clone())),
        ];
        Self {
            scanners,
            config,
            cached_test_pools: std::sync::Mutex::new(None),
        }
    }

    /// –ù–û–í–´–ô –ú–ï–¢–û–î: –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–µ—Å—Ç–æ–≤—ã—Ö –ø—É–ª–æ–≤ –¥–ª—è devnet
    pub fn set_test_pools(&self, pools: Vec<PoolState>) {
        let pools_count = pools.len(); // –ü–û–õ–£–ß–ê–ï–ú –î–õ–ò–ù–£ –î–û –ü–ï–†–ï–ú–ï–©–ï–ù–ò–Ø
        *self.cached_test_pools.lock().unwrap() = Some(pools);
        info!("üß™ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ {} —Ç–µ—Å—Ç–æ–≤—ã—Ö –ø—É–ª–æ–≤ –¥–ª—è devnet —Ä–µ–∂–∏–º–∞", pools_count);
    }

    pub async fn scan_all_dex(&self) -> Result<Vec<PoolState>> {
        // –ü–†–û–í–ï–†–ö–ê DEVNET –†–ï–ñ–ò–ú–ê
        let is_devnet = self.config.rpc.url.contains("devnet");

        if is_devnet {
            // –í devnet —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ç–µ—Å—Ç–æ–≤—ã—Ö –ø—É–ª–æ–≤
            if let Some(test_pools) = self.cached_test_pools.lock().unwrap().as_ref() {
                if !test_pools.is_empty() {
                    info!("üß™ Devnet —Ä–µ–∂–∏–º: –∏—Å–ø–æ–ª—å–∑—É–µ–º {} —Ç–µ—Å—Ç–æ–≤—ã—Ö –ø—É–ª–æ–≤ –¥–ª—è –∞—Ä–±–∏—Ç—Ä–∞–∂–∞", test_pools.len());
                    return Ok(test_pools.clone());
                }
            }
        }

        info!("üîç –ó–∞–ø—É—Å–∫ {} —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Å–µ—Ö DEX...",
              if is_devnet { "–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–≥–æ devnet" } else { "–ø–æ–ª–Ω–æ–≥–æ mainnet" });

        let scan_futures = self.scanners.iter().map(|scanner| {
            scanner.scan_pools()
        });

        let results = join_all(scan_futures).await;
        let mut all_pools = Vec::new();

        for (i, result) in results.into_iter().enumerate() {
            let protocol = self.scanners[i].protocol();
            match result {
                Ok(mut pools) => {
                    // DEVNET –û–ì–†–ê–ù–ò–ß–ï–ù–ò–Ø
                    if is_devnet && pools.len() > 100 {
                        info!("  üß™ Devnet —Ä–µ–∂–∏–º: –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º {} –ø—É–ª–æ–≤ –¥–æ 100", pools.len());
                        pools.truncate(100);
                    }

                    info!("  {:?}: –Ω–∞–π–¥–µ–Ω–æ {} –ø—É–ª–æ–≤", protocol, pools.len());
                    all_pools.extend(pools);
                }
                Err(e) => {
                    tracing::warn!("  {:?}: –æ—à–∏–±–∫–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è - {}", protocol, e);
                }
            }
        }

        // –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–û–ï –û–ì–†–ê–ù–ò–ß–ï–ù–ò–ï –î–õ–Ø DEVNET
        if is_devnet && all_pools.len() > 500 {
            info!("üß™ Devnet —Ä–µ–∂–∏–º: –∏—Ç–æ–≥–æ–≤–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Å {} –¥–æ 500 –ø—É–ª–æ–≤", all_pools.len());
            all_pools.truncate(500);
        }

        info!("‚úÖ –í—Å–µ–≥–æ –ø—É–ª–æ–≤ –Ω–∞–π–¥–µ–Ω–æ: {}", all_pools.len());
        Ok(all_pools)
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/scanner/mod.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/scanner/meteora_dlmm.rs ---
// bot/src/scanner/meteora_dlmm.rs
use anyhow::Result;
use serde::Deserialize;
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;
use tracing::{info, warn};
use std::sync::Arc;

use crate::config::BotConfig;
use crate::types::{PoolState, DexProtocol};
use super::DexScanner;

#[derive(Clone)]
pub struct MeteoraDlmmScanner {
    config: Arc<BotConfig>,
}

#[derive(Deserialize)]
struct MeteoraPair {
    address: String,
    mint_x: String,
    mint_y: String,
    reserve_x_amount: u64,
    reserve_y_amount: u64,
    base_fee_percentage: String,
}

impl MeteoraDlmmScanner {
    pub fn new(config: Arc<BotConfig>) -> Self {
        Self { config }
    }

    fn convert_api_pool_to_pool_state(&self, api_pool: MeteoraPair) -> Result<PoolState> {
        let id = Pubkey::from_str(&api_pool.address)?;
        let token_a = Pubkey::from_str(&api_pool.mint_x)?;
        let token_b = Pubkey::from_str(&api_pool.mint_y)?;

        let fee_pct: f64 = api_pool.base_fee_percentage.parse()?;
        let fee_bps = (fee_pct * 100.0) as u16;

        Ok(PoolState {
            id,
            protocol: DexProtocol::MeteoraDlmm,
            token_a,
            token_b,
            reserve_a: api_pool.reserve_x_amount,
            reserve_b: api_pool.reserve_y_amount,
            fee_bps,
            last_updated: chrono::Utc::now().timestamp(),
            full_state_data: Vec::new(),
            decimals_a: 9,
            decimals_b: 9,
        })
    }
}

#[async_trait::async_trait]
impl DexScanner for MeteoraDlmmScanner {
    fn protocol(&self) -> DexProtocol {
        DexProtocol::MeteoraDlmm
    }

    async fn scan_pools(&self) -> Result<Vec<PoolState>> {
        info!("üì° –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ Meteora DLMM –ø—É–ª–æ–≤ —á–µ—Ä–µ–∑ API...");

        // –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –¥–æ–±–∞–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä –∫–ª–∞—Å—Ç–µ—Ä–∞ –¥–ª—è devnet
        let api_url = "https://dlmm-api.meteora.ag/pair/all?cluster=devnet";

        let response = reqwest::get(api_url).await?;

        if !response.status().is_success() {
            anyhow::bail!("API Meteora –≤–µ—Ä–Ω—É–ª–æ –æ—à–∏–±–∫—É: {}", response.status());
        }

        let api_pools: Vec<MeteoraPair> = response.json().await?;

        info!("   üìä –ü–æ–ª—É—á–µ–Ω–æ {} –ø—É–ª–æ–≤ –æ—Ç API Meteora (devnet)", api_pools.len());

        let mut pools = Vec::new();
        for api_pool in api_pools {
            match self.convert_api_pool_to_pool_state(api_pool) {
                Ok(pool) => pools.push(pool),
                Err(e) => warn!("‚ö†Ô∏è –û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –ø—É–ª–∞ Meteora: {}", e),
            }
        }

        info!("‚úÖ Meteora DLMM: –Ω–∞–π–¥–µ–Ω–æ {} –≤–∞–ª–∏–¥–Ω—ã—Ö –ø—É–ª–æ–≤", pools.len());
        Ok(pools)
    }

    fn clone_box(&self) -> Box<dyn DexScanner> {
        Box::new(self.clone())
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/scanner/meteora_dlmm.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/scanner/raydium_cpmm.rs ---
// bot/src/scanner/raydium_cpmm.rs
use anyhow::{Result, Context};
use rayon::prelude::*;
use solana_client::rpc_client::RpcClient;
use solana_client::rpc_config::{RpcAccountInfoConfig, RpcProgramAccountsConfig};
use solana_client::rpc_filter::RpcFilterType;
use solana_sdk::commitment_config::CommitmentConfig;
use solana_sdk::pubkey::Pubkey;
use std::sync::Arc;
use tracing::{info, warn};

use crate::config::BotConfig;
use crate::types::{PoolState, DexProtocol};
use super::DexScanner;

#[derive(Clone)]
pub struct RaydiumCpmmScanner {
    rpc_client: Arc<RpcClient>,
    config: Arc<BotConfig>,
    program_id: Pubkey,
}

// –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è CPMM —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
#[derive(Debug)]
struct CpmmPoolInfo {
    token_0_mint: Pubkey,
    token_1_mint: Pubkey,
    token_0_vault: Pubkey,
    token_1_vault: Pubkey,
    lp_supply: u64,
}

impl CpmmPoolInfo {
    fn try_from_slice(data: &[u8]) -> Result<Self> {
        if data.len() < 320 {
            return Err(anyhow::anyhow!("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è CPMM pool"));
        }

        // –£–ø—Ä–æ—â–µ–Ω–Ω—ã–µ –æ—Ñ—Å–µ—Ç—ã –¥–ª—è CPMM (–Ω—É–∂–Ω–æ —É—Ç–æ—á–Ω–∏—Ç—å)
        let token_0_mint = crate::dex_structs::read_pubkey(data, 8)?;
        let token_1_mint = crate::dex_structs::read_pubkey(data, 40)?;
        let token_0_vault = crate::dex_structs::read_pubkey(data, 72)?;
        let token_1_vault = crate::dex_structs::read_pubkey(data, 104)?;
        let lp_supply = crate::dex_structs::read_u64(data, 200)?;

        Ok(Self {
            token_0_mint,
            token_1_mint,
            token_0_vault,
            token_1_vault,
            lp_supply,
        })
    }
}

impl RaydiumCpmmScanner {
    pub fn new(config: Arc<BotConfig>, rpc_client: Arc<RpcClient>) -> Result<Self> {
        let program_id = config.dex.raydium_cpmm.to_pubkey()
            .context("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π Raydium CPMM program ID")?;

        info!("üîÑ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Raydium CPMM —Å–∫–∞–Ω–µ—Ä–∞ —Å program_id: {}", program_id);

        Ok(Self {
            rpc_client,
            config,
            program_id,
        })
    }

    fn parse_cpmm_pool(&self, pool_id: Pubkey, data: &[u8]) -> Result<PoolState> {
        let pool_info = CpmmPoolInfo::try_from_slice(data)?;

        Ok(PoolState {
            id: pool_id,
            protocol: DexProtocol::RaydiumCpmm,
            token_a: pool_info.token_0_mint,
            token_b: pool_info.token_1_mint,
            reserve_a: 0,
            reserve_b: 0,
            fee_bps: 25, // –¢–∏–ø–∏—á–Ω–∞—è –∫–æ–º–∏—Å—Å–∏—è CPMM (0.25%)
            last_updated: chrono::Utc::now().timestamp(),
            full_state_data: data.to_vec(),
            decimals_a: 9,
            decimals_b: 9,
        })
    }
}

#[async_trait::async_trait]
impl DexScanner for RaydiumCpmmScanner {
    fn protocol(&self) -> DexProtocol {
        DexProtocol::RaydiumCpmm
    }

    async fn scan_pools(&self) -> Result<Vec<PoolState>> {
        info!("üì° –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ Raydium CPMM –ø—É–ª–æ–≤...");

        let config = RpcProgramAccountsConfig {
            filters: Some(vec![
                RpcFilterType::DataSize(324), // –†–∞–∑–º–µ—Ä CPMM pool account
            ]),
            account_config: RpcAccountInfoConfig {
                encoding: Some(solana_account_decoder::UiAccountEncoding::Base64),
                commitment: Some(CommitmentConfig::confirmed()),
                data_slice: None,
                min_context_slot: None,
            },
            with_context: None,
            sort_results: None,
        };

        let accounts = self.rpc_client
            .get_program_accounts_with_config(&self.program_id, config)
            .context("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è CPMM –∞–∫–∫–∞—É–Ω—Ç–æ–≤")?;

        info!("   üìä –ù–∞–π–¥–µ–Ω–æ {} –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö CPMM –ø—É–ª–æ–≤", accounts.len());

        let pools: Vec<PoolState> = accounts
            .par_iter()
            .filter_map(|(pubkey, account)| {
                match self.parse_cpmm_pool(*pubkey, &account.data) {
                    Ok(pool) => Some(pool),
                    Err(e) => {
                        warn!("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å CPMM –ø—É–ª {}: {}", pubkey, e);
                        None
                    }
                }
            })
            .collect();

        info!("‚úÖ Raydium CPMM: –Ω–∞–π–¥–µ–Ω–æ {} –ø—É–ª–æ–≤", pools.len());
        Ok(pools)
    }

    fn clone_box(&self) -> Box<dyn DexScanner> {
        Box::new(self.clone())
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/scanner/raydium_cpmm.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/main.rs ---
// bot/src/main.rs
// –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω–æ–≥–æ –±–æ—Ç–∞

mod config;
mod types;
mod scanner;
mod arbitrage;
mod executor;
mod utils;
mod test_setup;
pub mod dex_structs;

use solana_sdk::signature::Signer;
use anyhow::Result;
use solana_client::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;
use std::sync::Arc;
use tokio::time::{interval, Duration};
use tracing::{info, error, warn};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

use config::BotConfig;
use scanner::{MultiDexScanner, pool_monitor::PoolMonitor};
use arbitrage::ArbitrageFinder;
use executor::TransactionExecutor;
use utils::load_keypair_from_file;
use test_setup::TestEnvironmentSetup;

#[tokio::main]
async fn main() -> Result<()> {
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
    init_logging();

    println!("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
    println!("‚ïë    SOLANA ARBITRAGE BOT - RUST EDITION (DEVNET)               ‚ïë");
    println!("‚ïë    –í—ã—Å–æ–∫–æ–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ –∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –∞—Ä–±–∏—Ç—Ä–∞–∂–∞        ‚ïë");
    println!("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");

    // –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
    info!("üìã –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏...");
    let config = Arc::new(BotConfig::load()?);
    info!("‚úÖ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω–∞");

    // –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ—à–µ–ª—å–∫–∞
    info!("üîë –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ—à–µ–ª—å–∫–∞...");
    let wallet_path = config.wallet.path.to_str()
        .ok_or_else(|| anyhow::anyhow!("–ù–µ–≤–µ—Ä–Ω—ã–π –ø—É—Ç—å –∫ –∫–æ—à–µ–ª—å–∫—É"))?;
    let keypair = Arc::new(load_keypair_from_file(wallet_path)?);
    info!("   –ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á: {}", keypair.pubkey());

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è RPC –∫–ª–∏–µ–Ω—Ç–∞
    info!("üåê –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Solana RPC...");
    let rpc_client = Arc::new(RpcClient::new_with_commitment(
        config.rpc.url.clone(),
        CommitmentConfig::confirmed(),
    ));

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
    let cluster_version = rpc_client.get_version()?;
    info!("   –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ –∫–ª–∞—Å—Ç–µ—Ä—É: {} (Solana {})",
          config.rpc.url, cluster_version.solana_core);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞
    let balance = rpc_client.get_balance(&keypair.pubkey())?;
    let balance_sol = balance as f64 / 1_000_000_000.0;
    info!("üí∞ –ë–∞–ª–∞–Ω—Å –∫–æ—à–µ–ª—å–∫–∞: {:.9} SOL", balance_sol);

    if balance_sol < 0.1 {
        warn!("‚ö†Ô∏è  –ù–ò–ó–ö–ò–ô –ë–ê–õ–ê–ù–°! –ü–æ–ø–æ–ª–Ω–∏—Ç–µ —á–µ—Ä–µ–∑ —Ñ–æ—Å—Å–µ—Ç: https://faucet.solana.com/");
        warn!("   –ê–¥—Ä–µ—Å: {}", keypair.pubkey());
    }

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
    info!("üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ –±–æ—Ç–∞...");

    let pool_monitor = Arc::new(PoolMonitor::new(5000)); // 5 —Å–µ–∫—É–Ω–¥ TTL
    let dex_scanner = MultiDexScanner::new(config.clone(), rpc_client.clone());
    let arbitrage_finder = ArbitrageFinder::new(config.clone());
    let executor = TransactionExecutor::new(
        rpc_client.clone(),
        keypair.clone(),
        config.clone(),
    )?;

    info!("‚úÖ –í—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã\n");

    // –°–û–ó–î–ê–ù–ò–ï –¢–ï–°–¢–û–í–û–ô –°–†–ï–î–´ –¥–ª—è devnet (TS-—Å–∫—Ä–∏–ø—Ç—ã –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–∑–∂–µ,
    // –∑–¥–µ—Å—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è fallback –Ω–∞ Rust –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ —Å–æ–∑–¥–∞—Å—Ç 3 —Ç–æ–∫–µ–Ω–∞ –∏ 3 –ø—É–ª–∞)
    if config.rpc.url.contains("devnet") {
        info!("üß™ –†–µ–∂–∏–º devnet: —Å–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤–æ–π —Å—Ä–µ–¥—ã");

        let test_setup = TestEnvironmentSetup::new(
            rpc_client.clone(),
            config.clone(),
            keypair.clone(),
        );

        match test_setup.create_test_environment().await {
            Ok(test_env) => {
                info!("‚úÖ –¢–µ—Å—Ç–æ–≤–∞—è —Å—Ä–µ–¥–∞ –≥–æ—Ç–æ–≤–∞!");
                info!("   üìä –ü—É–ª–æ–≤ —Å–æ–∑–¥–∞–Ω–æ: {}", test_env.pools.len());
                info!("   ü™ô Token A: {} ({})", test_env.token_a.symbol, test_env.token_a.mint);
                info!("   ü™ô Token B: {} ({})", test_env.token_b.symbol, test_env.token_b.mint);
                info!("   ü™ô Token C: {} ({})", test_env.token_c.symbol, test_env.token_c.mint);
                info!("   üìà Market ID: {}", test_env.market_id);

                // –ü—É–ª—ã –≤ —Å–∫–∞–Ω–µ—Ä –∏ –∫—ç—à
                dex_scanner.set_test_pools(test_env.pools.clone());
                for pool in &test_env.pools {
                    pool_monitor.update_pool(pool.clone());
                }
                info!("   üí° –¢–µ—Å—Ç–æ–≤—ã–µ –ø—É–ª—ã —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤ —Å–∫–∞–Ω–µ—Ä –∏ –∫—ç—à");
            }
            Err(e) => {
                warn!("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Ç–µ—Å—Ç–æ–≤—É—é —Å—Ä–µ–¥—É: {}", e);
                info!("   –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å –æ–±—ã—á–Ω—ã–º —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ–º...");
            }
        }
    }

    // –ó–∞–ø—É—Å–∫ —Ñ–æ–Ω–æ–≤–æ–π –æ—á–∏—Å—Ç–∫–∏ –∫—ç—à–∞
    let monitor_clone = pool_monitor.clone();
    tokio::spawn(async move {
        scanner::pool_monitor::start_cache_cleanup_task(monitor_clone).await;
    });

    // –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª –±–æ—Ç–∞
    info!("üöÄ –ó–∞–ø—É—Å–∫ –≥–ª–∞–≤–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ –±–æ—Ç–∞...");
    info!("{}", "‚ïê".repeat(80));

    let mut scan_interval = interval(Duration::from_millis(config.rpc.timeout_seconds * 1000));
    let mut iteration = 0u64;

    loop {
        scan_interval.tick().await;
        iteration += 1;

        info!("\n‚è∞ –ò—Ç–µ—Ä–∞—Ü–∏—è #{} - {}", iteration, chrono::Local::now().format("%H:%M:%S"));

        // –®–∞–≥ 1: –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—É–ª–æ–≤
        match dex_scanner.scan_all_dex().await {
            Ok(pools) => {
                if pools.is_empty() {
                    warn!("   ‚ö†Ô∏è  –ü—É–ª—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ —Ç–µ—Å—Ç–æ–≤—ã–µ –ø—É–ª—ã —Å–æ–∑–¥–∞–Ω—ã –Ω–∞ devnet.");
                    continue;
                }

                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞
                for pool in &pools {
                    pool_monitor.update_pool(pool.clone());
                }

                info!("   üìä –ê–∫—Ç–∏–≤–Ω—ã—Ö –ø—É–ª–æ–≤: {}", pools.len());

                // –®–∞–≥ 2: –ü–æ–∏—Å–∫ –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π
                match arbitrage_finder.find_opportunities(&pools) {
                    Ok(opportunities) => {
                        if opportunities.is_empty() {
                            info!("   ‚è≥ –ü—Ä–∏–±—ã–ª—å–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ");
                            continue;
                        }

                        info!("   üî• –ù–∞–π–¥–µ–Ω–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π: {}", opportunities.len());

                        // –ë–µ—Ä—ë–º –ª—É—á—à—É—é –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å
                        let best = &opportunities[0];
                        info!("   üíé –õ—É—á—à–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å:");
                        info!("      –ü—Ä–∏–±—ã–ª—å: {:.9} SOL ({:.4}%)",
                              best.net_profit as f64 / 1_000_000_000.0,
                              best.profit_percentage);
                        info!("      –®–∞–≥–æ–≤: {}", best.legs.len());

                        // –®–∞–≥ 3: –ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –∞—Ä–±–∏—Ç—Ä–∞–∂–∞
                        info!("   üîß –ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –∞—Ä–±–∏—Ç—Ä–∞–∂–∞...");
                        match executor.execute(best).await {
                            Ok(signature) => {
                                info!("   ‚úÖ –ê–†–ë–ò–¢–†–ê–ñ –£–°–ü–ï–®–ï–ù!");
                                info!("      –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è: {}", signature);
                                info!("      Explorer: https://explorer.solana.com/tx/{}?cluster=devnet",
                                      signature);
                            }
                            Err(e) => {
                                error!("   ‚ùå –û—à–∏–±–∫–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è: {}", e);
                            }
                        }
                    }
                    Err(e) => {
                        error!("   ‚ùå –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π: {}", e);
                    }
                }
            }
            Err(e) => {
                error!("   ‚ùå –û—à–∏–±–∫–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –ø—É–ª–æ–≤: {}", e);
            }
        }
    }
}

/// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
fn init_logging() {
    let log_level = std::env::var("LOG_LEVEL").unwrap_or_else(|_| "info".to_string());

    let filter = tracing_subscriber::EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new(log_level));

    tracing_subscriber::registry()
        .with(filter)
        .with(tracing_subscriber::fmt::layer()
            .with_target(false)
            .with_thread_ids(false)
            .with_line_number(false))
        .init();
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/main.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/executor/jito_client.rs ---
// bot/src/executor/jito_client.rs
// –ö–ª–∏–µ–Ω—Ç –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å Jito Block Engine (MEV –∑–∞—â–∏—Ç–∞)

// bot/src/executor/jito_client.rs

use anyhow::{Result, Context};
use solana_sdk::{
    pubkey::Pubkey,
    transaction::Transaction,
    // –£–î–ê–õ–ò–¢–ï —ç—Ç—É —Å—Ç—Ä–æ–∫—É: signature::Signature,
};
use reqwest::Client;
use serde::{Deserialize, Serialize};
use std::str::FromStr;
use tracing::{info, warn, debug};

// –£–î–ê–õ–ò–¢–ï —ç—Ç—É —Å—Ç—Ä–æ–∫—É - –æ–Ω–∞ –¥—É–±–ª–∏—Ä—É–µ—Ç –∏–º–ø–æ—Ä—Ç:
// use solana_sdk::pubkey::Pubkey;

/// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Jito
pub struct JitoConfig {
    pub block_engine_url: String,
    pub tip_account: Pubkey,
    pub tip_lamports: u64,
}

impl Default for JitoConfig {
    fn default() -> Self {
        Self {
            block_engine_url: "https://mainnet.block-engine.jito.wtf".to_string(),
            tip_account: Pubkey::from_str("96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5")
                .expect("Invalid Jito tip account"),
            tip_lamports: 300_000, // 0.0003 SOL –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π tip
        }
    }
}

/// –ö–ª–∏–µ–Ω—Ç Jito Block Engine
pub struct JitoClient {
    config: JitoConfig,
    http_client: Client,
}

impl JitoClient {
    pub fn new(config: JitoConfig) -> Self {
        Self {
            config,
            http_client: Client::new(),
        }
    }

    /// –û—Ç–ø—Ä–∞–≤–∫–∞ bundle —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –≤ Jito
    ///
    /// –í–ê–ñ–ù–û: Jito Block Engine –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –Ω–∞ devnet!
    /// –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –Ω–∞ mainnet.
    pub async fn send_bundle(&self, transactions: Vec<Transaction>) -> Result<String> {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ devnet
        if self.config.block_engine_url.contains("devnet") {
            warn!("‚ö†Ô∏è  Jito Block Engine –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –Ω–∞ devnet. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –æ–±—ã—á–Ω—É—é –æ—Ç–ø—Ä–∞–≤–∫—É.");
            anyhow::bail!("Jito –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –Ω–∞ devnet");
        }

        info!("üì¶ –û—Ç–ø—Ä–∞–≤–∫–∞ bundle –∏–∑ {} —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –≤ Jito...", transactions.len());

        // –°–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –≤ base64
        let encoded_txs: Vec<String> = transactions
            .iter()
            .map(|tx| {
                let serialized = bincode::serialize(tx).expect("Failed to serialize tx");
                bs58::encode(serialized).into_string()
            })
            .collect();

        debug!("   –°–µ—Ä–∏–∞–ª–∏–∑–æ–≤–∞–Ω–æ {} —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π", encoded_txs.len());

        // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ JSON-RPC –∑–∞–ø—Ä–æ—Å–∞
        let request = SendBundleRequest {
            jsonrpc: "2.0".to_string(),
            id: 1,
            method: "sendBundle".to_string(),
            params: vec![encoded_txs],
        };

        // –û—Ç–ø—Ä–∞–≤–∫–∞ POST –∑–∞–ø—Ä–æ—Å–∞ –∫ Jito API
        let endpoint = format!("{}/api/v1/bundles", self.config.block_engine_url);
        debug!("   Endpoint: {}", endpoint);

        let response = self.http_client
            .post(&endpoint)
            .json(&request)
            .send()
            .await
            .context("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å bundle –≤ Jito")?;

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ –æ—Ç–≤–µ—Ç–∞
        let status = response.status();
        if !status.is_success() {
            let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
            anyhow::bail!("Jito –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É {}: {}", status, error_text);
        }

        // –ü–∞—Ä—Å–∏–Ω–≥ –æ—Ç–≤–µ—Ç–∞
        let bundle_response: SendBundleResponse = response
            .json()
            .await
            .context("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –æ—Ç–≤–µ—Ç Jito")?;

        if let Some(error) = bundle_response.error {
            anyhow::bail!("Jito RPC –æ—à–∏–±–∫–∞: {:?}", error);
        }

        let bundle_id = bundle_response.result
            .ok_or_else(|| anyhow::anyhow!("–ù–µ—Ç bundle_id –≤ –æ—Ç–≤–µ—Ç–µ Jito"))?;

        info!("   ‚úÖ Bundle –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω, ID: {}", bundle_id);

        Ok(bundle_id)
    }

    /// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ bundle
    pub async fn get_bundle_status(&self, bundle_id: &str) -> Result<BundleStatus> {
        let request = GetBundleStatusRequest {
            jsonrpc: "2.0".to_string(),
            id: 1,
            method: "getBundleStatuses".to_string(),
            params: vec![vec![bundle_id.to_string()]],
        };

        let endpoint = format!("{}/api/v1/bundles", self.config.block_engine_url);

        let response = self.http_client
            .post(&endpoint)
            .json(&request)
            .send()
            .await
            .context("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å bundle")?;

        let status_response: GetBundleStatusResponse = response
            .json()
            .await
            .context("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å —Å—Ç–∞—Ç—É—Å bundle")?;

        let statuses = status_response.result.value
            .ok_or_else(|| anyhow::anyhow!("–ù–µ—Ç —Å—Ç–∞—Ç—É—Å–æ–≤ –≤ –æ—Ç–≤–µ—Ç–µ"))?;

        let status = statuses.first()
            .ok_or_else(|| anyhow::anyhow!("–ü—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ —Å—Ç–∞—Ç—É—Å–æ–≤"))?;

        Ok(status.clone())
    }

    /// –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è bundle (—Å —Ç–∞–π–º–∞—É—Ç–æ–º)
    pub async fn wait_for_confirmation(
        &self,
        bundle_id: &str,
        timeout_seconds: u64,
    ) -> Result<BundleStatus> {
        use tokio::time::{sleep, Duration};

        let start = std::time::Instant::now();
        let timeout = Duration::from_secs(timeout_seconds);

        loop {
            if start.elapsed() > timeout {
                anyhow::bail!("–¢–∞–π–º–∞—É—Ç –æ–∂–∏–¥–∞–Ω–∏—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è bundle");
            }

            let status = self.get_bundle_status(bundle_id).await?;

            match status.confirmation_status.as_str() {
                "confirmed" | "finalized" => {
                    info!("   ‚úÖ Bundle –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω: {}", status.confirmation_status);
                    return Ok(status);
                }
                "failed" => {
                    anyhow::bail!("Bundle –ø—Ä–æ–≤–∞–ª–∏–ª—Å—è: {:?}", status.err);
                }
                "pending" => {
                    debug!("   Bundle –≤ –æ–∂–∏–¥–∞–Ω–∏–∏... ({}s)", start.elapsed().as_secs());
                    sleep(Duration::from_millis(500)).await;
                }
                _ => {
                    debug!("   –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å—Ç–∞—Ç—É—Å: {}", status.confirmation_status);
                    sleep(Duration::from_millis(500)).await;
                }
            }
        }
    }
}

// ============================================================================
// JSON-RPC –°–¢–†–£–ö–¢–£–†–´
// ============================================================================

#[derive(Serialize)]
struct SendBundleRequest {
    jsonrpc: String,
    id: u64,
    method: String,
    params: Vec<Vec<String>>,
}

#[derive(Deserialize)]
struct SendBundleResponse {
    result: Option<String>,
    error: Option<JsonRpcError>,
}

#[derive(Serialize)]
struct GetBundleStatusRequest {
    jsonrpc: String,
    id: u64,
    method: String,
    params: Vec<Vec<String>>,
}

#[derive(Deserialize)]
struct GetBundleStatusResponse {
    result: BundleStatusResult,
}

#[derive(Deserialize)]
struct BundleStatusResult {
    value: Option<Vec<BundleStatus>>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct BundleStatus {
    pub bundle_id: String,
    pub confirmation_status: String,
    pub err: Option<String>,
    pub slot: Option<u64>,
}

#[derive(Debug, Deserialize)]
struct JsonRpcError {
    code: i32,
    message: String,
}

// ============================================================================
// –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò
// ============================================================================

/// –°–æ–∑–¥–∞–Ω–∏–µ tip —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –¥–ª—è Jito
pub fn create_tip_instruction(
    from: &Pubkey,
    tip_account: &Pubkey,
    lamports: u64,
) -> solana_sdk::instruction::Instruction {
    solana_sdk::system_instruction::transfer(from, tip_account, lamports)
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/executor/jito_client.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/executor/transaction_builder.rs ---
use anchor_lang::prelude::*;
use anchor_spl::{associated_token, token};
use anyhow::{Context, Result};
use solana_client::rpc_client::RpcClient;
use solana_sdk::{
    compute_budget::ComputeBudgetInstruction,
    hash::Hash,
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use std::sync::Arc;
use tracing::{debug, info, warn};

use crate::{
    config::BotConfig,
    dex_structs::AmmInfo,
    types::{ArbitrageOpportunity, DexProtocol, SwapLeg},
};

pub struct TransactionBuilder {
    rpc_client: Arc<RpcClient>,
    keypair:    Arc<Keypair>,
    config:     Arc<BotConfig>,
    program_id: Pubkey,
}

/* ---------------- —Å–µ—Ä–∏–∞–ª–∏–∑—É–µ–º—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã ---------------- */
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
struct ProgramSwapLeg {
    protocol:           u8,
    pool_id:            Pubkey,
    input_mint:         Pubkey,
    output_mint:        Pubkey,
    amount_in:          u64,
    minimum_amount_out: u64,
    accounts_len:       u8,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
struct ExecuteArbitrageParams {
    swap_legs:           Vec<ProgramSwapLeg>,
    min_profit_lamports: u64,
}

/* ---------------- impl ---------------- */
impl TransactionBuilder {
    pub fn new(
        rpc_client: Arc<RpcClient>,
        keypair: Arc<Keypair>,
        config:  Arc<BotConfig>,
    ) -> Result<Self> {
        Ok(Self {
            program_id: config.trading.executor_program_id.to_pubkey()?,
            rpc_client,
            keypair,
            config,
        })
    }

    /* ---------- –ø—É–±–ª–∏—á–Ω—ã–π API ---------- */
    pub async fn build_arbitrage_transaction(
        &self,
        opp: &ArbitrageOpportunity,
    ) -> Result<Transaction> {
        info!("üî® –°—Ç—Ä–æ–∏–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é: {} —Å–≤–æ–ø–æ–≤", opp.legs.len());

        /* ---------- mock-—Ä–µ–∂–∏–º –¥–ª—è devnet-fallback ---------- */
        let is_test_environment = self.config.rpc.url.contains("devnet")
            && opp
            .legs
            .iter()
            .any(|leg| self.rpc_client.get_account(&leg.pool_id).is_err());

        if is_test_environment {
            info!("üß™ –¢–ï–°–¢–û–í–ê–Ø –°–†–ï–î–ê: –≤–æ–∑–≤—Ä–∞—â–∞–µ–º mock-—Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é");

            let mock_tx = Transaction::new_signed_with_payer(
                &[ComputeBudgetInstruction::set_compute_unit_limit(
                    self.config.trading.compute_unit_limit,
                )],
                Some(&self.keypair.pubkey()),
                &[self.keypair.as_ref()],
                self.latest_blockhash()?,
            );

            warn!("‚ö†Ô∏è  –ü—É–ª—ã —Ñ–∏–∫—Ç–∏–≤–Ω—ã–µ ‚Äì —Ä–µ–∞–ª—å–Ω—ã–π RPC –Ω–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è");
            return Ok(mock_tx);
        }
        /* ----------------------------------------------------- */

        self.validate_pools_exist(opp).await?;

        /* ----- compute budget ----- */
        let mut instructions = vec![
            ComputeBudgetInstruction::set_compute_unit_limit(
                self.config.trading.compute_unit_limit,
            ),
            ComputeBudgetInstruction::set_compute_unit_price(
                self.config.trading.priority_fee_micro_lamports,
            ),
        ];

        /* ----- —Ñ–æ—Ä–º–∏—Ä—É–µ–º legs ----- */
        let mut rem_accs = Vec::<AccountMeta>::new();
        let mut prog_legs = Vec::<ProgramSwapLeg>::new();

        for (idx, leg) in opp.legs.iter().enumerate() {
            debug!("‚öôÔ∏è  leg #{} {:?}", idx + 1, leg.protocol);

            let (accs, pl) = self.accounts_for_leg(leg).await?;
            rem_accs.extend(accs);
            prog_legs.push(pl);
        }

        instructions.push(self.make_execute_ix(prog_legs, opp.net_profit, rem_accs)?);

        /* ----- —Ñ–∏–Ω–∞–ª—å–Ω—ã–π tx ----- */
        let mut tx = Transaction::new_with_payer(&instructions, Some(&self.keypair.pubkey()));
        tx.sign(&[self.keypair.as_ref()], self.latest_blockhash()?);

        Ok(tx)
    }

    /* ---------- helpers ---------- */
    fn latest_blockhash(&self) -> Result<Hash> {
        Ok(self.rpc_client.get_latest_blockhash()?)
    }

    async fn validate_pools_exist(&self, opp: &ArbitrageOpportunity) -> Result<()> {
        for (i, leg) in opp.legs.iter().enumerate() {
            let acc = self
                .rpc_client
                .get_account(&leg.pool_id)
                .with_context(|| format!("RPC get_account {}", leg.pool_id))?;
            if acc.data.is_empty() {
                anyhow::bail!("–ü—É–ª {} (leg #{}) –ø—É—Å—Ç–æ–π", leg.pool_id, i + 1);
            }
        }
        Ok(())
    }

    /* ---------- accounts per leg ---------- */
    async fn accounts_for_leg(
        &self,
        leg: &SwapLeg,
    ) -> Result<(Vec<AccountMeta>, ProgramSwapLeg)> {
        match leg.protocol {
            DexProtocol::RaydiumAmmV4 => self.raydium_amm_v4_accounts(leg).await,
            _ => unimplemented!("DEX {:?} –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω", leg.protocol),
        }
    }

    async fn raydium_amm_v4_accounts(
        &self,
        leg: &SwapLeg,
    ) -> Result<(Vec<AccountMeta>, ProgramSwapLeg)> {
        let data = self.rpc_client.get_account(&leg.pool_id)?.data;
        let amm  = AmmInfo::try_from_slice(&data).context("decode AmmInfo")?;

        let user_src = associated_token::get_associated_token_address(&self.keypair.pubkey(), &leg.input_mint);
        let user_dst = associated_token::get_associated_token_address(&self.keypair.pubkey(), &leg.output_mint);

        let accts = vec![
            AccountMeta::new(leg.pool_id, false),
            AccountMeta::new_readonly(amm.market_id, false),
            AccountMeta::new(amm.base_vault, false),
            AccountMeta::new(amm.quote_vault, false),
            AccountMeta::new(user_src, false),
            AccountMeta::new(user_dst, false),
            AccountMeta::new_readonly(self.keypair.pubkey(), true),
            AccountMeta::new_readonly(token::ID, false),
        ];

        let pl = ProgramSwapLeg {
            protocol:           leg.protocol as u8,
            pool_id:            leg.pool_id,
            input_mint:         leg.input_mint,
            output_mint:        leg.output_mint,
            amount_in:          leg.amount_in,
            minimum_amount_out: leg.minimum_amount_out,
            accounts_len:       accts.len() as u8,
        };

        Ok((accts, pl))
    }

    /* ---------- execute-ix ---------- */
    fn make_execute_ix(
        &self,
        legs: Vec<ProgramSwapLeg>,
        min_profit: u64,
        mut rem: Vec<AccountMeta>,
    ) -> Result<Instruction> {
        let first_mint = legs.first().context("legs empty")?.input_mint;
        let user_ata =
            associated_token::get_associated_token_address(&self.keypair.pubkey(), &first_mint);

        let mut accs = vec![
            AccountMeta::new(self.keypair.pubkey(), true),
            AccountMeta::new(user_ata, false),
            AccountMeta::new_readonly(first_mint, false),
            AccountMeta::new_readonly(token::ID, false),
            AccountMeta::new_readonly(solana_sdk::system_program::ID, false),
        ];
        accs.append(&mut rem);

        Ok(Instruction {
            program_id: self.program_id,
            accounts:   accs,
            data:       self.build_ix_data(legs, min_profit)?,
        })
    }

    fn build_ix_data(&self, legs: Vec<ProgramSwapLeg>, min_profit: u64) -> Result<Vec<u8>> {
        const DISC: [u8; 8] = [0x3f, 0x39, 0x4c, 0x8f, 0x29, 0x34, 0x70, 0xd0];
        let params = ExecuteArbitrageParams { swap_legs: legs, min_profit_lamports: min_profit };
        let mut data = DISC.to_vec();
        data.extend_from_slice(&params.try_to_vec()?);
        Ok(data)
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/executor/transaction_builder.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/executor/mod.rs ---
// bot/src/executor/mod.rs

pub mod transaction_builder;
pub mod jito_client;
pub mod simulator;

use anyhow::Result;
use solana_sdk::signature::{Keypair, Signature};
use solana_client::rpc_client::RpcClient;
use std::sync::Arc;
use tracing::info;

use crate::config::BotConfig;
use crate::types::ArbitrageOpportunity;
use transaction_builder::TransactionBuilder;
use simulator::TransactionSimulator;

pub struct TransactionExecutor {
    rpc_client: Arc<RpcClient>,
    builder: TransactionBuilder,
    simulator: TransactionSimulator,
}

impl TransactionExecutor {
    pub fn new(
        rpc_client: Arc<RpcClient>,
        keypair: Arc<Keypair>,
        config: Arc<BotConfig>,
    ) -> Result<Self> {
        Ok(Self {
            builder: TransactionBuilder::new(
                rpc_client.clone(),
                keypair.clone(),
                config.clone(),
            )?,
            simulator: TransactionSimulator::new(rpc_client.clone()),
            rpc_client,
        })
    }

    pub async fn execute(&self, opportunity: &ArbitrageOpportunity) -> Result<Signature> {
        let transaction = self.builder.build_arbitrage_transaction(opportunity).await?;

        info!("üß™ –°–∏–º—É–ª—è—Ü–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏...");
        let simulation = self.simulator.simulate(&transaction).await?;
        if let Some(err) = simulation.err {
            anyhow::bail!("–°–∏–º—É–ª—è—Ü–∏—è –ø—Ä–æ–≤–∞–ª–∏–ª–∞—Å—å: {}\n–õ–æ–≥–∏:\n{:#?}", err, simulation.logs);
        }

        info!("‚úÖ –°–∏–º—É–ª—è—Ü–∏—è —É—Å–ø–µ—à–Ω–∞ (CU: {})", simulation.units_consumed.unwrap_or(0));

        info!("üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏...");
        let signature = self.rpc_client.send_and_confirm_transaction(&transaction)?;
        Ok(signature)
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/executor/mod.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/executor/simulator.rs ---
// bot/src/executor/simulator.rs (–∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ)
use tracing::debug;
use solana_sdk::transaction::Transaction;
use crate::types::SimulationResult;
use anyhow::Result;
use solana_client::rpc_client::RpcClient;
use std::sync::Arc;
pub struct TransactionSimulator {
    rpc_client: Arc<RpcClient>,
}
/// –°–∏–º—É–ª—è—Ü–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
impl TransactionSimulator {
    pub fn new(rpc_client: Arc<RpcClient>) -> Self {
        Self { rpc_client }
    }

    pub async fn simulate(&self, transaction: &Transaction) -> Result<SimulationResult> {
        let simulation = self.rpc_client
            .simulate_transaction(transaction)
            .map_err(|e| anyhow::anyhow!("–û—à–∏–±–∫–∞ —Å–∏–º—É–ª—è—Ü–∏–∏: {}", e))?;

        let result = SimulationResult {
            err: simulation.value.err.map(|e| format!("{:?}", e)),
            logs: simulation.value.logs.clone().unwrap_or_default(),
            units_consumed: simulation.value.units_consumed,
        };

        if let Some(ref err) = result.err {
            debug!("–°–∏–º—É–ª—è—Ü–∏—è –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –æ—à–∏–±–∫–æ–π: {}", err);
            if let Some(logs) = &simulation.value.logs {
                for log in logs {
                    debug!("  Log: {}", log);
                }
            }
        }

        Ok(result)
    }

    /// –û—Ü–µ–Ω–∫–∞ compute units –¥–ª—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    pub async fn estimate_compute_units(&self, transaction: &Transaction) -> Result<u64> {
        let simulation = self.simulate(transaction).await?;

        simulation.units_consumed
            .ok_or_else(|| anyhow::anyhow!("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å compute units"))
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/executor/simulator.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/config.rs ---
// bot/src/config.rs
use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use std::str::FromStr;
use solana_sdk::pubkey::Pubkey;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BotConfig {
    pub rpc: RpcConfig,
    pub wallet: WalletConfig,
    pub trading: TradingConfig,
    pub dex: DexConfig,
    pub jito: Option<JitoConfig>,
    pub monitoring: MonitoringConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RpcConfig {
    pub url: String,
    pub ws_url: String,
    pub commitment: String,
    pub timeout_seconds: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WalletConfig {
    pub path: PathBuf,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradingConfig {
    pub executor_program_id: PubkeyString,
    pub min_profit_lamports: u64,
    pub min_profit_bps: u16,
    pub max_slippage_bps: u16,
    pub initial_amount_sol: f64,
    pub max_legs: u8,
    pub compute_unit_limit: u32,
    pub priority_fee_micro_lamports: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DexConfig {
    pub raydium_amm_v4: PubkeyString,
    pub raydium_cpmm: PubkeyString,
    pub raydium_clmm: PubkeyString,
    pub meteora_dlmm: PubkeyString,
    pub openbook_id: PubkeyString,  // –ù–û–í–û–ï –ü–û–õ–ï
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JitoConfig {
    pub block_engine_url: String,
    pub tip_account: PubkeyString,
    pub tip_lamports: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MonitoringConfig {
    pub log_level: String,
    pub telemetry_enabled: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PubkeyString(pub String);

impl PubkeyString {
    pub fn to_pubkey(&self) -> Result<Pubkey> {
        Pubkey::from_str(&self.0).context("Invalid pubkey")
    }
}

impl BotConfig {
    pub fn load() -> Result<Self> {
        dotenv::dotenv().ok();

        // –ü–û–î–î–ï–†–ñ–ö–ê –ö–õ–ê–°–¢–ï–†–û–í
        let cluster = std::env::var("SOLANA_CLUSTER").unwrap_or_else(|_| "mainnet".to_string());
        let is_devnet = cluster.eq_ignore_ascii_case("devnet");

        let (rpc_url, ws_url) = if is_devnet {
            (
                "https://api.devnet.solana.com".to_string(),
                "wss://api.devnet.solana.com".to_string(),
            )
        } else {
            (
                std::env::var("SOLANA_RPC_URL")
                    .unwrap_or_else(|_| "https://api.mainnet-beta.solana.com".to_string()),
                std::env::var("SOLANA_WS_URL")
                    .unwrap_or_else(|_| "wss://api.mainnet-beta.solana.com".to_string()),
            )
        };

        // –ü–†–ê–í–ò–õ–¨–ù–´–ï PROGRAM IDs –î–õ–Ø DEVNET/MAINNET
        let dex = if is_devnet {
            DexConfig {
                raydium_amm_v4: PubkeyString("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav".to_string()),
                raydium_cpmm: PubkeyString("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb".to_string()),
                raydium_clmm: PubkeyString("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH".to_string()),
                meteora_dlmm: PubkeyString("LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo".to_string()),
                openbook_id: PubkeyString("opnb2LAfJYbRMAHHvqjCwQxanZn7ReEHp1k81EohpZb".to_string()),
            }
        } else {
            DexConfig {
                raydium_amm_v4: PubkeyString("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8".to_string()),
                raydium_cpmm: PubkeyString("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C".to_string()),
                raydium_clmm: PubkeyString("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK".to_string()),
                meteora_dlmm: PubkeyString("LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo".to_string()),
                openbook_id: PubkeyString("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX".to_string()),
            }
        };

        Ok(Self {
            rpc: RpcConfig {
                url: rpc_url,
                ws_url,
                commitment: "confirmed".to_string(),
                timeout_seconds: 30,
            },
            wallet: WalletConfig {
                path: std::env::var("WALLET_PATH")
                    .unwrap_or_else(|_| "~/.config/solana/id.json".to_string())
                    .into(),
            },
            trading: TradingConfig {
                executor_program_id: PubkeyString(
                    std::env::var("ARBITRAGE_EXECUTOR_PROGRAM_ID")
                        .context("ARBITRAGE_EXECUTOR_PROGRAM_ID –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ .env")?,
                ),
                min_profit_lamports: std::env::var("MIN_PROFIT_LAMPORTS")
                    .unwrap_or_else(|_| "1000".to_string())
                    .parse()
                    .context("Invalid MIN_PROFIT_LAMPORTS")?,
                min_profit_bps: std::env::var("MIN_PROFIT_BPS")
                    .unwrap_or_else(|_| "10".to_string())
                    .parse()
                    .context("Invalid MIN_PROFIT_BPS")?,
                max_slippage_bps: std::env::var("MAX_SLIPPAGE_BPS")
                    .unwrap_or_else(|_| "500".to_string())
                    .parse()
                    .context("Invalid MAX_SLIPPAGE_BPS")?,
                initial_amount_sol: std::env::var("INITIAL_AMOUNT_SOL")
                    .unwrap_or_else(|_| "0.01".to_string())
                    .parse()
                    .context("Invalid INITIAL_AMOUNT_SOL")?,
                max_legs: 5,
                compute_unit_limit: 400_000,
                priority_fee_micro_lamports: 100_000,
            },
            dex,
            jito: None, // –û—Ç–∫–ª—é—á–∞–µ–º Jito –Ω–∞ devnet
            monitoring: MonitoringConfig {
                log_level: std::env::var("LOG_LEVEL").unwrap_or_else(|_| "info".to_string()),
                telemetry_enabled: std::env::var("TELEMETRY_ENABLED")
                    .unwrap_or_else(|_| "false".to_string())
                    .parse()
                    .unwrap_or(false),
            },
        })
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/config.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/arbitrage/pool_math.rs ---
// bot/src/arbitrage/pool_math.rs

use anyhow::Result;

/// –†–∞—Å—á–µ—Ç –≤—ã—Ö–æ–¥–∞ –¥–ª—è –ø—É–ª–∞ CPMM (Constant Product Market Maker)
pub fn calculate_cpmm_output(
    reserve_in: u64,
    reserve_out: u64,
    amount_in: u64,
    fee_bps: u16,
) -> Result<u64> {
    if reserve_in == 0 || reserve_out == 0 {
        anyhow::bail!("–ù—É–ª–µ–≤—ã–µ —Ä–µ–∑–µ—Ä–≤—ã –≤ CPMM –ø—É–ª–µ");
    }

    let fee_multiplier = 1.0 - (fee_bps as f64 / 10000.0);
    let amount_in_with_fee = (amount_in as f64) * fee_multiplier;

    let numerator = (reserve_out as f64) * amount_in_with_fee;
    let denominator = (reserve_in as f64) + amount_in_with_fee;

    let amount_out = numerator / denominator;
    Ok(amount_out as u64)
}

/// –†–∞—Å—á–µ—Ç –≤—ã—Ö–æ–¥–∞ –¥–ª—è –ø—É–ª–∞ CLMM (Concentrated Liquidity)
pub fn calculate_clmm_output(
    liquidity: u128,
    sqrt_price_current: u128,
    sqrt_price_next: u128,
    amount_in: u64,
    fee_bps: u16,
) -> Result<u64> {
    if liquidity == 0 {
        anyhow::bail!("–ù—É–ª–µ–≤–∞—è –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å –≤ CLMM –ø—É–ª–µ");
    }

    let fee_multiplier = 1.0 - (fee_bps as f64 / 10000.0);
    let _amount_in_with_fee = (amount_in as f64) * fee_multiplier;

    let l_f64 = liquidity as f64;
    let sqrt_p_current = sqrt_price_current as f64;
    let sqrt_p_next = sqrt_price_next as f64;

    let delta_y = l_f64 * (sqrt_p_next - sqrt_p_current) / (sqrt_p_current * sqrt_p_next);
    let amount_out = delta_y * fee_multiplier;

    Ok(amount_out as u64)
}

/// –†–∞—Å—á–µ—Ç –≤—ã—Ö–æ–¥–∞ –¥–ª—è –ø—É–ª–∞ DLMM (Dynamic Liquidity Market Maker)
pub fn calculate_dlmm_output(
    bin_liquidity: u64,
    bin_price: f64,
    composition: f64,
    amount_in: u64,
    base_fee_bps: u16,
    variable_fee_bps: u16,
) -> Result<u64> {
    if bin_liquidity == 0 {
        anyhow::bail!("–ù—É–ª–µ–≤–∞—è –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å –≤ DLMM –±–∏–Ω–µ");
    }

    let total_fee_bps = base_fee_bps + variable_fee_bps;
    let fee_multiplier = 1.0 - (total_fee_bps as f64 / 10000.0);

    let l_f64 = bin_liquidity as f64;
    let reserve_y = composition * l_f64;
    let reserve_x = l_f64 / (bin_price * (1.0 - composition));

    let amount_in_with_fee = (amount_in as f64) * fee_multiplier;
    let numerator = reserve_y * amount_in_with_fee;
    let denominator = reserve_x + amount_in_with_fee;

    let amount_out = numerator / denominator;
    Ok(amount_out as u64)
}

/// –†–∞—Å—á–µ—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –≤—ã—Ö–æ–¥–∞ —Å —É—á–µ—Ç–æ–º slippage
pub fn calculate_minimum_amount_out(
    expected_amount: u64,
    slippage_bps: u16,
) -> u64 {
    let slippage_multiplier = 1.0 - (slippage_bps as f64 / 10000.0);
    ((expected_amount as f64) * slippage_multiplier) as u64
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cpmm_calculation() {
        let output = calculate_cpmm_output(
            1_000_000_000,
            1_000_000_000,
            100_000_000,
            25,
        ).unwrap();

        assert!(output > 90_000_000 && output < 100_000_000);
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/arbitrage/pool_math.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/arbitrage/opportunity.rs ---
// bot/src/arbitrage/opportunity.rs
// –û—Ü–µ–Ω–∫–∞ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π

use anyhow::Result;
use std::collections::HashMap;
use std::sync::Arc;
use tracing::info;

use solana_sdk::pubkey::Pubkey;

use super::bellman_ford::ArbitrageCycle;
use super::profit_calculator::ProfitCalculator;
use crate::config::BotConfig;
use crate::types::{ArbitrageOpportunity, DexProtocol, PoolState, SwapLeg};

pub struct OpportunityEvaluator {
    config: Arc<BotConfig>,
    profit_calc: ProfitCalculator,
}

impl OpportunityEvaluator {
    pub fn new(config: Arc<BotConfig>) -> Self {
        Self {
            profit_calc: ProfitCalculator::new(config.clone()),
            config,
        }
    }

    /// –°—Ç—Ä–æ–∏–º —Ç–∞–±–ª–∏—Ü—É decimals –ø–æ mint-–∞–¥—Ä–µ—Å–∞–º –∏–∑ —Å–ø–∏—Å–∫–∞ –ø—É–ª–æ–≤.
    fn build_decimals_map(&self, pools: &[PoolState]) -> HashMap<Pubkey, u8> {
        let mut m = HashMap::new();
        for p in pools {
            // –ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –±—ã–ª–æ –∑–Ω–∞—á–µ–Ω–∏–π —Ä–∞–Ω–µ–µ
            m.entry(p.token_a).or_insert(p.decimals_a);
            m.entry(p.token_b).or_insert(p.decimals_b);
        }
        m
    }

    /// –û—Ü–µ–Ω–∫–∞ —Ü–∏–∫–ª–∞ –∏ —Å–æ–∑–¥–∞–Ω–∏–µ ArbitrageOpportunity
    pub fn evaluate_cycle(
        &self,
        cycle: &ArbitrageCycle,
        pools: &[PoolState],
    ) -> Result<Option<ArbitrageOpportunity>> {
        // –ú–∏–Ω–∏–º—É–º —Ç—Ä–∏ —Ç–æ–∫–µ–Ω–∞ (A -> B -> C -> A)
        if cycle.tokens.len() < 3 {
            return Ok(None);
        }

        info!("üîç === –î–ï–¢–ê–õ–¨–ù–ê–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –¶–ò–ö–õ–ê ===");
        info!("–¢–æ–∫–µ–Ω–æ–≤ –≤ —Ü–∏–∫–ª–µ: {}", cycle.tokens.len());

        // –ü–æ—Å—Ç—Ä–æ–∏–º –∫–∞—Ä—Ç—É decimals –∏–∑ –ø—É–ª–æ–≤
        let decimals_map = self.build_decimals_map(pools);

        // –ù–∞—á–∞–ª—å–Ω–∞—è —Å—É–º–º–∞: –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É–µ–º initial_amount_sol –∫–∞–∫ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤ UI-–µ–¥–∏–Ω–∏—Ü–∞—Ö
        // —Å—Ç–∞—Ä—Ç–æ–≤–æ–≥–æ —Ç–æ–∫–µ–Ω–∞ –∏ –ø–µ—Ä–µ–≤–æ–¥–∏–º –≤ –∞—Ç–æ–º—ã —Å—Ç–∞—Ä—Ç–æ–≤–æ–≥–æ —Ç–æ–∫–µ–Ω–∞.
        let start_mint = cycle.tokens[0];
        let start_decimals = *decimals_map
            .get(&start_mint)
            .ok_or_else(|| anyhow::anyhow!("–ù–µ –Ω–∞–π–¥–µ–Ω—ã decimals –¥–ª—è —Å—Ç–∞—Ä—Ç–æ–≤–æ–≥–æ —Ç–æ–∫–µ–Ω–∞"))?;
        let ui_amount = self.config.trading.initial_amount_sol; // –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–∫ UI –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
        let mut current_amount: u64 =
            (ui_amount * 10f64.powi(start_decimals as i32)) as u64;

        info!(
            "üí∞ –ù–∞—á–∞–ª—å–Ω–∞—è —Å—É–º–º–∞: {} atoms (mint: {}, decimals: {})",
            current_amount, start_mint, start_decimals
        );

        // –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ swap legs —Å –¥–µ—Ç–∞–ª—å–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º
        let mut legs: Vec<SwapLeg> = Vec::new();

        for i in 0..cycle.tokens.len() - 1 {
            let input_mint = cycle.tokens[i];
            let output_mint = cycle.tokens[i + 1];

            info!("üîÑ === –°–í–û–ü #{} ===", i + 1);
            info!("–û—Ç: {}", input_mint);
            info!("–ö:  {}", output_mint);

            // –ù–∞—Ö–æ–¥–∏–º –ø—É–ª –¥–ª—è —ç—Ç–æ–π –ø–∞—Ä—ã
            let pool = pools
                .iter()
                .find(|p| {
                    (p.token_a == input_mint && p.token_b == output_mint)
                        || (p.token_a == output_mint && p.token_b == input_mint)
                })
                .ok_or_else(|| anyhow::anyhow!("–ü—É–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è –ø–∞—Ä—ã —Ç–æ–∫–µ–Ω–æ–≤"))?;

            info!("üìä –ù–∞–π–¥–µ–Ω –ø—É–ª: {}", pool.id);
            info!(
                "   Token A: {} (—Ä–µ–∑–µ—Ä–≤: {} atoms, decimals: {}), Token B: {} (—Ä–µ–∑–µ—Ä–≤: {} atoms, decimals: {})",
                pool.token_a, pool.reserve_a, pool.decimals_a, pool.token_b, pool.reserve_b, pool.decimals_b
            );

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–≤–æ–ø–∞
            let a_to_b = input_mint == pool.token_a;
            info!("üîÄ –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: {}", if a_to_b { "A‚ÜíB" } else { "B‚ÜíA" });

            // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–∂–∏–¥–∞–µ–º—ã–π –≤—ã—Ö–æ–¥
            let (estimated_out, min_out) =
                self.calculate_swap_amounts(pool, current_amount, a_to_b)?;

            info!("üí∏ –í—Ö–æ–¥–Ω–∞—è —Å—É–º–º–∞: {} atoms", current_amount);
            info!("üí∞ –û–∂–∏–¥–∞–µ–º—ã–π –≤—ã—Ö–æ–¥: {} atoms", estimated_out);
            info!("üìâ –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –≤—ã—Ö–æ–¥: {} atoms", min_out);

            let exchange_rate = if current_amount > 0 {
                estimated_out as f64 / current_amount as f64
            } else {
                0.0
            };
            info!("üíπ –û–±–º–µ–Ω–Ω—ã–π –∫—É—Ä—Å: {:.6}", exchange_rate);

            if estimated_out > current_amount {
                info!(
                    "‚úÖ –ü—Ä–∏–±—ã–ª—å–Ω—ã–π —Å–≤–æ–ø (+{} atoms)",
                    estimated_out - current_amount
                );
            } else {
                info!(
                    "‚ùå –£–±—ã—Ç–æ—á–Ω—ã–π —Å–≤–æ–ø (-{} atoms)",
                    current_amount - estimated_out
                );
            }

            let leg = SwapLeg {
                protocol: pool.protocol,
                pool_id: pool.id,
                input_mint,
                output_mint,
                amount_in: current_amount,
                minimum_amount_out: min_out,
                estimated_amount_out: estimated_out,
                fee_bps: pool.fee_bps,
                pool_state_data: pool.full_state_data.clone(),
            };

            legs.push(leg);
            current_amount = estimated_out; // –î–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–≤–æ–ø–∞
        }

        // –†–∞—Å—á—ë—Ç —á–∏—Å—Ç–æ–π –ø—Ä–∏–±—ã–ª–∏ ‚Äî —Ä–∞–±–æ—Ç–∞–µ–º –≤ –∞—Ç–æ–º–∞—Ö —Å—Ç–∞—Ä—Ç–æ–≤–æ–≥–æ —Ç–æ–∫–µ–Ω–∞
        let initial_amount = legs[0].amount_in;
        let final_amount = legs.last().unwrap().estimated_amount_out;

        info!("üìä === –ò–¢–û–ì–û–í–´–ô –†–ê–°–ß–ï–¢ ===");
        info!(
            "üèÅ –ù–∞—á–∞–ª—å–Ω–∞—è —Å—É–º–º–∞: {} atoms (mint: {}, decimals: {})",
            initial_amount, start_mint, start_decimals
        );
        info!(
            "üéØ –§–∏–Ω–∞–ª—å–Ω–∞—è —Å—É–º–º–∞: {} atoms (mint: {}, decimals: {})",
            final_amount, start_mint, start_decimals
        );

        // ProfitCalculator –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å ‚Äî –æ–Ω —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ u64.
        // –í devnet –Ω–µ —É—á–∏—Ç—ã–≤–∞–µ–º SOL –∫–æ–º–∏—Å—Å–∏–∏ (–æ–Ω–∏ –≤ –¥—Ä—É–≥–æ–π –µ–¥–∏–Ω–∏—Ü–µ).
        let (gross_profit, net_profit) =
            self.profit_calc
                .calculate_net_profit(initial_amount, final_amount, &legs)?;

        info!("üíé –í–∞–ª–æ–≤–∞—è –ø—Ä–∏–±—ã–ª—å: {} atoms", gross_profit);
        info!("üè¶ –ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å: {} atoms", net_profit);
        info!(
            "üìä –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø–æ—Ä–æ–≥: {} atoms",
            self.config.trading.min_profit_lamports
        );

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∏–±—ã–ª—å–Ω–æ—Å—Ç–∏
        if net_profit < self.config.trading.min_profit_lamports {
            info!(
                "‚ùå –û–¢–ö–õ–û–ù–ï–ù–û: –ü—Ä–∏–±—ã–ª—å {} < {} (–ø–æ—Ä–æ–≥)",
                net_profit, self.config.trading.min_profit_lamports
            );
            info!("üí° –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–Ω–∏–∑–∏—Ç—å MIN_PROFIT_LAMPORTS –≤ .env —Ñ–∞–π–ª–µ");
            return Ok(None);
        }

        let profit_percentage = if initial_amount > 0 {
            (net_profit as f64 / initial_amount as f64) * 100.0
        } else {
            0.0
        };

        info!("‚úÖ –ü–†–ò–ù–Ø–¢–û: –ê—Ä–±–∏—Ç—Ä–∞–∂–Ω–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ–¥–æ–±—Ä–µ–Ω–∞!");
        info!("üìà –ü—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–∏–±—ã–ª–∏: {:.4}%", profit_percentage);

        let opportunity = ArbitrageOpportunity {
            legs,
            initial_amount,
            expected_final_amount: final_amount,
            gross_profit,
            net_profit,
            profit_percentage,
            discovered_at: chrono::Utc::now().timestamp(),
        };

        Ok(Some(opportunity))
    }

    /// –†–∞—Å—á—ë—Ç –æ–∂–∏–¥–∞–µ–º–æ–≥–æ –∏ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –≤—ã—Ö–æ–¥–∞ —Å–≤–æ–ø–∞ –≤ –∞—Ç–æ–º–∞—Ä–Ω—ã—Ö –µ–¥–∏–Ω–∏—Ü–∞—Ö —Ç–æ–∫–µ–Ω–∞
    fn calculate_swap_amounts(
        &self,
        pool: &PoolState,
        amount_in: u64,
        a_to_b: bool,
    ) -> Result<(u64, u64)> {
        let (reserve_in, reserve_out) = if a_to_b {
            (pool.reserve_a, pool.reserve_b)
        } else {
            (pool.reserve_b, pool.reserve_a)
        };

        // –î–ª—è –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤—ã—Ö –ø—É–ª–æ–≤ (AMM/CPMM/DLMM) –∏—Å–ø–æ–ª—å–∑—É–µ–º CPMM-—Ñ–æ—Ä–º—É–ª—É
        let estimated_out = {
            use crate::arbitrage::pool_math::calculate_cpmm_output;
            calculate_cpmm_output(reserve_in, reserve_out, amount_in, pool.fee_bps)?
        };

        // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –≤—ã—Ö–æ–¥ —Å —É—á—ë—Ç–æ–º slippage
        use crate::arbitrage::pool_math::calculate_minimum_amount_out;
        let min_out =
            calculate_minimum_amount_out(estimated_out, self.config.trading.max_slippage_bps);

        Ok((estimated_out, min_out))
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/arbitrage/opportunity.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/arbitrage/profit_calculator.rs ---
// bot/src/arbitrage/profit_calculator.rs
// –†–∞—Å—á—ë—Ç —á–∏—Å—Ç–æ–π –ø—Ä–∏–±—ã–ª–∏ —Å —É—á—ë—Ç–æ–º –≤—Å–µ—Ö –∫–æ–º–∏—Å—Å–∏–π

use anyhow::Result;
use std::sync::Arc;

use crate::config::BotConfig;
use crate::types::SwapLeg;

pub struct ProfitCalculator {
    config: Arc<BotConfig>,
}

impl ProfitCalculator {
    pub fn new(config: Arc<BotConfig>) -> Self {
        Self { config }
    }

    /// –†–∞—Å—á—ë—Ç —á–∏—Å—Ç–æ–π –ø—Ä–∏–±—ã–ª–∏ —Å —É—á—ë—Ç–æ–º –∫–æ–º–∏—Å—Å–∏–π
    /// –í devnet –ù–ï –≤—ã—á–∏—Ç–∞–µ–º SOL-–∫–æ–º–∏—Å—Å–∏–∏ (–¥—Ä—É–≥–∞—è –µ–¥–∏–Ω–∏—Ü–∞) ‚Äî —Ä–∞–±–æ—Ç–∞–µ–º –≤ –∞—Ç–æ–º–∞—Ö —Å—Ç–∞—Ä—Ç–æ–≤–æ–≥–æ —Ç–æ–∫–µ–Ω–∞
    pub fn calculate_net_profit(
        &self,
        initial_amount: u64,
        final_amount: u64,
        _legs: &[SwapLeg],
    ) -> Result<(u64, u64)> {
        // –í–∞–ª–æ–≤–∞—è –ø—Ä–∏–±—ã–ª—å –≤ –∞—Ç–æ–º–∞—Ö —Ç–æ–∫–µ–Ω–∞
        let gross_profit = if final_amount >= initial_amount {
            final_amount - initial_amount
        } else {
            initial_amount - final_amount
        };

        // Devnet: –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–æ–º–∏—Å—Å–∏–∏ –≤ SOL (lamports), —Ç.–∫. —Å—á–∏—Ç–∞–µ–º –≤ –∞—Ç–æ–º–∞—Ö —Ç–æ–∫–µ–Ω–∞
        let is_devnet = self.config.rpc.url.contains("devnet");

        let net_profit = if is_devnet {
            gross_profit
        } else {
            // –î–ª—è mainnet –∑–¥–µ—Å—å —Å–ª–µ–¥–æ–≤–∞–ª–æ –±—ã:
            // 1) —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å SOL-–∫–æ–º–∏—Å—Å–∏–∏ (tx_base_fee, priority_fee, jito_tip)
            // 2) —Å–∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∏—Ö –≤ –∞—Ç–æ–º—ã —Ç–æ–∫–µ–Ω–∞ A —á–µ—Ä–µ–∑ –ø—Ä–∞–π—Å-–æ—Ä–∞–∫—É–ª
            // 3) –≤—ã—á–µ—Å—Ç—å –∏–∑ gross_profit
            gross_profit
        };

        Ok((gross_profit, net_profit))
    }

    /// –û—Ü–µ–Ω–∫–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ slippage (–æ—Å—Ç–∞–≤–ª–µ–Ω–æ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
    pub fn calculate_max_slippage(
        &self,
        initial_amount: u64,
        expected_profit: u64,
    ) -> f64 {
        let max_loss = expected_profit.saturating_sub(self.config.trading.min_profit_lamports);
        if expected_profit == 0 { return 0.0; }
        (max_loss as f64 / expected_profit as f64) * 100.0
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/arbitrage/profit_calculator.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/arbitrage/graph.rs ---
// bot/src/arbitrage/graph.rs
// –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∞ —Ü–µ–Ω –¥–ª—è –ø–æ–∏—Å–∫–∞ –∞—Ä–±–∏—Ç—Ä–∞–∂–∞

use anyhow::Result;
use solana_sdk::pubkey::Pubkey;
use std::collections::HashMap;
use tracing::debug;

use crate::types::{PoolState, PriceEdge};

/// –ì—Ä–∞—Ñ —Ü–µ–Ω –º–µ–∂–¥—É —Ç–æ–∫–µ–Ω–∞–º–∏
pub struct PriceGraph {
    /// –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ç–æ–∫–µ–Ω -> –∏–Ω–¥–µ–∫—Å –≤ –≥—Ä–∞—Ñ–µ
    token_to_index: HashMap<Pubkey, usize>,
    /// –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –∏–Ω–¥–µ–∫—Å -> —Ç–æ–∫–µ–Ω
    index_to_token: Vec<Pubkey>,
    /// –ú–∞—Ç—Ä–∏—Ü–∞ —Å–º–µ–∂–Ω–æ—Å—Ç–∏: adjacency[from][to] = vec![PriceEdge]
    adjacency: Vec<Vec<Vec<PriceEdge>>>,
}

impl PriceGraph {
    pub fn new() -> Self {
        Self {
            token_to_index: HashMap::new(),
            index_to_token: Vec::new(),
            adjacency: Vec::new(),
        }
    }

    /// –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∞ –∏–∑ —Å–ø–∏—Å–∫–∞ –ø—É–ª–æ–≤
    pub fn build_from_pools(&self, pools: &[PoolState]) -> Result<PriceGraph> {
        let mut graph = PriceGraph::new();

        // –®–∞–≥ 1: –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã
        for pool in pools {
            graph.add_token_if_new(pool.token_a);
            graph.add_token_if_new(pool.token_b);
        }
        let max_pools = 2000;
        let pools = if pools.len() > max_pools {
            tracing::warn!("‚ö†Ô∏è –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø—É–ª–æ–≤ —Å {} –¥–æ {}", pools.len(), max_pools);
            &pools[..max_pools]
        } else {
            pools
        };

        // –°–æ–±–∏—Ä–∞–µ–º —Ç–æ–∫–µ–Ω—ã –∏ —Å—á–∏—Ç–∞–µ–º, —Å–∫–æ–ª—å–∫–æ –±—É–¥–µ—Ç —É–∑–ª–æ–≤
        // ...
        let n = graph.token_count();

        // –ï—Å–ª–∏ —Ç–æ–∫–µ–Ω–æ–≤ —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ ‚Äî –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º—Å—è –∑–∞—Ä–∞–Ω–µ–µ
        let max_tokens = if pools.len() < 100 { 1000 } else { 100 }; // –î–ò–ù–ê–ú–ò–ß–ï–°–ö–ò–ô –õ–ò–ú–ò–¢
        if n > max_tokens {
            anyhow::bail!("–°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π –≥—Ä–∞—Ñ: {} —Ç–æ–∫–µ–Ω–æ–≤ (> {})", n, max_tokens);
        }
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–∞—Ç—Ä–∏—Ü—ã —Å–º–µ–∂–Ω–æ—Å—Ç–∏
        let n = graph.token_count();
        graph.adjacency = vec![vec![Vec::new(); n]; n];

        // –®–∞–≥ 2: –î–æ–±–∞–≤–ª—è–µ–º —Ä—ë–±—Ä–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø—É–ª–∞
        for pool in pools {
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ A -> B
            let edge_ab = PriceEdge {
                from_token: pool.token_a,
                to_token: pool.token_b,
                pool_id: pool.id,
                protocol: pool.protocol,
                weight: Self::calculate_edge_weight(pool, true)?,
                fee_bps: pool.fee_bps,
            };

            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ B -> A
            let edge_ba = PriceEdge {
                from_token: pool.token_b,
                to_token: pool.token_a,
                pool_id: pool.id,
                protocol: pool.protocol,
                weight: Self::calculate_edge_weight(pool, false)?,
                fee_bps: pool.fee_bps,
            };

            graph.add_edge(edge_ab)?;
            graph.add_edge(edge_ba)?;
        }

        debug!("–ì—Ä–∞—Ñ –ø–æ—Å—Ç—Ä–æ–µ–Ω: {} —Ç–æ–∫–µ–Ω–æ–≤, {} —Ä—ë–±–µ—Ä", n, graph.edge_count());
        Ok(graph)
    }

    /// –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –≤–µ—Å–∞ —Ä–µ–±—Ä–∞ (–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π –ª–æ–≥–∞—Ä–∏—Ñ–º –æ–±–º–µ–Ω–Ω–æ–≥–æ –∫—É—Ä—Å–∞)
    /// Bellman-Ford –Ω–∞—Ö–æ–¥–∏—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –ø—É—Ç–∏, –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π —Ü–∏–∫–ª = –ø—Ä–∏–±—ã–ª—å
    fn calculate_edge_weight(pool: &PoolState, a_to_b: bool) -> Result<f64> {
        let (reserve_in, reserve_out) = if a_to_b {
            (pool.reserve_a as f64, pool.reserve_b as f64)
        } else {
            (pool.reserve_b as f64, pool.reserve_a as f64)
        };

        if reserve_in <= 0.0 || reserve_out <= 0.0 {
            anyhow::bail!("–ù—É–ª–µ–≤—ã–µ —Ä–µ–∑–µ—Ä–≤—ã –≤ –ø—É–ª–µ");
        }

        // –£—á—ë—Ç –∫–æ–º–∏—Å—Å–∏–∏ (fee_bps / 10000)
        let fee_multiplier = 1.0 - (pool.fee_bps as f64 / 10000.0);

        // –û–±–º–µ–Ω–Ω—ã–π –∫—É—Ä—Å —Å —É—á—ë—Ç–æ–º –∫–æ–º–∏—Å—Å–∏–∏
        let exchange_rate = (reserve_out / reserve_in) * fee_multiplier;

        // –í–µ—Å = -log(exchange_rate)
        // –û—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π —Ü–∏–∫–ª –æ–∑–Ω–∞—á–∞–µ—Ç –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∫—É—Ä—Å–æ–≤ > 1 (–ø—Ä–∏–±—ã–ª—å)
        let weight = -(exchange_rate.ln());

        Ok(weight)
    }

    /// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞ –µ—Å–ª–∏ –µ—â—ë –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    fn add_token_if_new(&mut self, token: Pubkey) {
        if !self.token_to_index.contains_key(&token) {
            let index = self.index_to_token.len();
            self.token_to_index.insert(token, index);
            self.index_to_token.push(token);
        }
    }

    /// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ä–µ–±—Ä–∞ –≤ –≥—Ä–∞—Ñ
    fn add_edge(&mut self, edge: PriceEdge) -> Result<()> {
        let from_idx = self.token_to_index.get(&edge.from_token)
            .ok_or_else(|| anyhow::anyhow!("–¢–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –≥—Ä–∞—Ñ–µ"))?;
        let to_idx = self.token_to_index.get(&edge.to_token)
            .ok_or_else(|| anyhow::anyhow!("–¢–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –≥—Ä–∞—Ñ–µ"))?;

        self.adjacency[*from_idx][*to_idx].push(edge);
        Ok(())
    }

    /// –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞ –ø–æ –∏–Ω–¥–µ–∫—Å—É
    pub fn get_token(&self, index: usize) -> Option<&Pubkey> {
        self.index_to_token.get(index)
    }

    /// –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–∞ —Ç–æ–∫–µ–Ω–∞
    pub fn get_index(&self, token: &Pubkey) -> Option<usize> {
        self.token_to_index.get(token).copied()
    }

    /// –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —Ä—ë–±–µ—Ä –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ–∫–µ–Ω–∞–º–∏
    pub fn get_edges(&self, from: usize, to: usize) -> &[PriceEdge] {
        &self.adjacency[from][to]
    }

    /// –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –≤ –≥—Ä–∞—Ñ–µ
    pub fn token_count(&self) -> usize {
        self.index_to_token.len()
    }

    /// –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä—ë–±–µ—Ä –≤ –≥—Ä–∞—Ñ–µ
    pub fn edge_count(&self) -> usize {
        self.adjacency.iter()
            .flat_map(|row| row.iter())
            .map(|edges| edges.len())
            .sum()
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/arbitrage/graph.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/arbitrage/mod.rs ---
// bot/src/arbitrage/mod.rs
// –û—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä –ø–æ–∏—Å–∫–∞ –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π

pub mod graph;
pub mod bellman_ford;
pub mod opportunity;
pub mod profit_calculator;
pub mod pool_math;

use anyhow::Result;
use std::sync::Arc;
use tracing::{info, debug};

use crate::config::BotConfig;
use crate::types::{PoolState, ArbitrageOpportunity};
use graph::PriceGraph;
use bellman_ford::BellmanFordSolver;
use opportunity::OpportunityEvaluator;

pub struct ArbitrageFinder {
    config: Arc<BotConfig>,
    graph_builder: PriceGraph,
    solver: BellmanFordSolver,
    evaluator: OpportunityEvaluator,
}

impl ArbitrageFinder {
    pub fn new(config: Arc<BotConfig>) -> Self {
        Self {
            config: config.clone(),
            graph_builder: PriceGraph::new(),
            solver: BellmanFordSolver::new(),
            evaluator: OpportunityEvaluator::new(config),
        }
    }

    /// –ü–æ–∏—Å–∫ –≤—Å–µ—Ö –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π –≤ –∑–∞–¥–∞–Ω–Ω—ã—Ö –ø—É–ª–∞—Ö
    pub fn find_opportunities(&self, pools: &[PoolState]) -> Result<Vec<ArbitrageOpportunity>> {
        if pools.is_empty() {
            return Ok(vec![]);
        }

        info!("üîç –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∞ —Ü–µ–Ω –∏–∑ {} –ø—É–ª–æ–≤...", pools.len());

        // –®–∞–≥ 1: –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∞ —Ü–µ–Ω
        let graph = self.graph_builder.build_from_pools(pools)?;
        debug!("   –ì—Ä–∞—Ñ —Å–æ–¥–µ—Ä–∂–∏—Ç {} —Ç–æ–∫–µ–Ω–æ–≤, {} —Ä—ë–±–µ—Ä",
           graph.token_count(),
           graph.edge_count());

        // –®–∞–≥ 2: –ü–æ–∏—Å–∫ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö —Ü–∏–∫–ª–æ–≤ —á–µ—Ä–µ–∑ Bellman-Ford
        info!("üßÆ –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ Bellman-Ford –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ü–∏–∫–ª–æ–≤...");
        let cycles = self.solver.find_negative_cycles(&graph, self.config.trading.max_legs as usize)?;

        if cycles.is_empty() {
            debug!("   –û—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö —Ü–∏–∫–ª–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ");
            return Ok(vec![]);
        }

        info!("   –ù–∞–π–¥–µ–Ω–æ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö —Ü–∏–∫–ª–æ–≤: {}", cycles.len());

        // –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê: –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–∞–∂–¥–æ–º —Ü–∏–∫–ª–µ
        for (i, cycle) in cycles.iter().enumerate() {
            info!("üîÑ –¶–∏–∫–ª #{}: {} —Ç–æ–∫–µ–Ω–æ–≤, –≤–µ—Å {:.6}",
             i + 1, cycle.tokens.len(), cycle.total_weight);
            info!("   –¢–æ–∫–µ–Ω—ã: {:?}", cycle.tokens.iter()
             .map(|t| format!("{}...", &t.to_string()[..8]))
             .collect::<Vec<_>>());
        }

        // –®–∞–≥ 3: –û—Ü–µ–Ω–∫–∞ –ø—Ä–∏–±—ã–ª—å–Ω–æ—Å—Ç–∏ –∫–∞–∂–¥–æ–≥–æ —Ü–∏–∫–ª–∞
        let mut opportunities = Vec::new();

        for (i, cycle) in cycles.iter().enumerate() {
            info!("üßÆ === –ê–ù–ê–õ–ò–ó –¶–ò–ö–õ–ê #{} ===", i + 1);

            match self.evaluator.evaluate_cycle(cycle, pools) {
                Ok(Some(opp)) => {
                    info!("‚úÖ –¶–∏–∫–ª #{} –ü–†–ò–ë–´–õ–ï–ù!", i + 1);
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –ø—Ä–∏–±—ã–ª–∏
                    if opp.net_profit >= self.config.trading.min_profit_lamports {
                        opportunities.push(opp);
                    }
                }
                Ok(None) => {
                    info!("‚ùå –¶–∏–∫–ª #{} –æ—Ç–∫–ª–æ–Ω–µ–Ω", i + 1);
                }
                Err(e) => {
                    info!("‚ö†Ô∏è –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ —Ü–∏–∫–ª–∞ #{}: {}", i + 1, e);
                }
            }
        }

        // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —É–±—ã–≤–∞–Ω–∏—é –ø—Ä–∏–±—ã–ª–∏
        opportunities.sort_by(|a, b| b.net_profit.cmp(&a.net_profit));

        info!("‚úÖ –ù–∞–π–¥–µ–Ω–æ –ø—Ä–∏–±—ã–ª—å–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π: {}", opportunities.len());

        Ok(opportunities)
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/arbitrage/mod.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/arbitrage/bellman_ford.rs ---
// bot/src/arbitrage/bellman_ford.rs

use anyhow::Result;
use solana_sdk::pubkey::Pubkey;
// –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –£–¥–∞–ª—è–µ–º –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π HashMap
use std::collections::HashSet;
use tracing::{info, debug};

use super::graph::PriceGraph;

#[derive(Debug, Clone)]
pub struct ArbitrageCycle {
    pub tokens: Vec<Pubkey>,
    pub total_weight: f64,
}

pub struct BellmanFordSolver;

impl BellmanFordSolver {
    pub fn new() -> Self {
        Self
    }

    /// –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ø–æ–∏—Å–∫ –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã—Ö —Ü–∏–∫–ª–æ–≤
    pub fn find_negative_cycles(
        &self,
        graph: &PriceGraph,
        _max_legs: usize, // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –î–æ–±–∞–≤–∏–ª–∏ –ø—Ä–µ—Ñ–∏–∫—Å _
    ) -> Result<Vec<ArbitrageCycle>> {
        let n = graph.token_count();

        info!("üîç === –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –ì–†–ê–§–ê ===");
        info!("–¢–æ–∫–µ–Ω–æ–≤ –≤ –≥—Ä–∞—Ñ–µ: {}", n);

        // –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞: –ø–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ —Ä—ë–±—Ä–∞ –≥—Ä–∞—Ñ–∞
        let mut total_edges = 0;
        for from in 0..n {
            for to in 0..n {
                let edges = graph.get_edges(from, to);
                if !edges.is_empty() {
                    total_edges += edges.len();
                    if let (Some(from_token), Some(to_token)) = (graph.get_token(from), graph.get_token(to)) {
                        info!("   –†–µ–±—Ä–æ: {}... -> {}... ({} –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤)",
                             &from_token.to_string()[..8],
                             &to_token.to_string()[..8],
                             edges.len());
                    }
                }
            }
        }

        info!("–í—Å–µ–≥–æ —Ä—ë–±–µ—Ä: {}", total_edges);

        if total_edges == 0 {
            info!("‚ùå –ì–†–ê–§ –ü–£–°–¢–û–ô! –ù–µ—Ç —Ä—ë–±–µ—Ä –º–µ–∂–¥—É —Ç–æ–∫–µ–Ω–∞–º–∏!");
            return Ok(vec![]);
        }

        // –ò—â–µ–º —Ü–∏–∫–ª—ã –º–µ—Ç–æ–¥–æ–º –ø—Ä—è–º–æ–≥–æ –ø–æ–∏—Å–∫–∞
        let mut cycles = Vec::new();
        let mut found_cycles = HashSet::new();

        info!("üîÑ === –ü–û–ò–°–ö –¢–†–ï–£–ì–û–õ–¨–ù–´–• –ê–†–ë–ò–¢–†–ê–ñ–ï–ô ===");

        // –ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∏
        for start_idx in 0..n {
            for mid_idx in 0..n {
                if mid_idx == start_idx { continue; }

                for end_idx in 0..n {
                    if end_idx == start_idx || end_idx == mid_idx { continue; }

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—É—Ç—å: start ‚Üí mid ‚Üí end ‚Üí start
                    if let Some(cycle) = self.check_triangle_arbitrage(
                        graph, start_idx, mid_idx, end_idx
                    )? {
                        let cycle_signature = self.get_cycle_signature(&cycle);

                        if !found_cycles.contains(&cycle_signature) {
                            found_cycles.insert(cycle_signature);

                            info!("üéØ –ù–ê–ô–î–ï–ù –¢–†–ï–£–ì–û–õ–¨–ù–´–ô –ê–†–ë–ò–¢–†–ê–ñ!");
                            info!("   –ü—É—Ç—å: {} ‚Üí {} ‚Üí {} ‚Üí {}",
                                 &cycle.tokens[0].to_string()[..8],
                                 &cycle.tokens[1].to_string()[..8],
                                 &cycle.tokens[2].to_string()[..8],
                                 &cycle.tokens[3].to_string()[..8]);
                            info!("   –û–±—â–∏–π –≤–µ—Å: {:.6}", cycle.total_weight);

                            if cycle.total_weight < -0.001 { // –ü—Ä–∏–±—ã–ª—å–Ω—ã–π
                                info!("   ‚úÖ –ü–†–ò–ë–´–õ–¨–ù–´–ô!");
                                cycles.push(cycle);
                            } else {
                                info!("   ‚ùå –ù–µ –ø—Ä–∏–±—ã–ª—å–Ω—ã–π");
                            }
                        }
                    }
                }
            }
        }

        info!("üèÅ –ù–∞–π–¥–µ–Ω–æ –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã—Ö —Ü–∏–∫–ª–æ–≤: {}", cycles.len());
        Ok(cycles)
    }

    /// –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç—Ä–µ—É–≥–æ–ª—å–Ω—ã–π –∞—Ä–±–∏—Ç—Ä–∞–∂ A‚ÜíB‚ÜíC‚ÜíA
    fn check_triangle_arbitrage(
        &self,
        graph: &PriceGraph,
        a_idx: usize,
        b_idx: usize,
        c_idx: usize,
    ) -> Result<Option<ArbitrageCycle>> {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö —Ç—Ä—ë—Ö —Ä—ë–±–µ—Ä
        let edges_ab = graph.get_edges(a_idx, b_idx);
        let edges_bc = graph.get_edges(b_idx, c_idx);
        let edges_ca = graph.get_edges(c_idx, a_idx);

        if edges_ab.is_empty() || edges_bc.is_empty() || edges_ca.is_empty() {
            return Ok(None); // –ù–µ—Ç –ø–æ–ª–Ω–æ–≥–æ –ø—É—Ç–∏
        }

        // –ë–µ—Ä—ë–º –ø–µ—Ä–≤–æ–µ –¥–æ—Å—Ç—É–ø–Ω–æ–µ —Ä–µ–±—Ä–æ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–µ—Ä–µ—Ö–æ–¥–∞
        let edge_ab = &edges_ab[0];
        let edge_bc = &edges_bc[0];
        let edge_ca = &edges_ca[0];

        // –í—ã—á–∏—Å–ª—è–µ–º –æ–±—â–∏–π –≤–µ—Å —Ü–∏–∫–ª–∞
        let total_weight = edge_ab.weight + edge_bc.weight + edge_ca.weight;

        debug!("   –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–∏–∫–ª–∞ {}->{}->{} = {:.6}",
               a_idx, b_idx, c_idx, total_weight);

        let tokens = vec![
            edge_ab.from_token,
            edge_ab.to_token,
            edge_bc.to_token,
            edge_ca.to_token, // –í–æ–∑–≤—Ä–∞—Ç –∫ –Ω–∞—á–∞–ª—É
        ];

        Ok(Some(ArbitrageCycle {
            tokens,
            total_weight,
        }))
    }

    /// –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∏ —Ü–∏–∫–ª–∞ –¥–ª—è –¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏–∏
    fn get_cycle_signature(&self, cycle: &ArbitrageCycle) -> String {
        let mut tokens_str: Vec<String> = cycle.tokens[..cycle.tokens.len()-1]
            .iter()
            .map(|t| t.to_string())
            .collect();

        tokens_str.sort(); // –°–æ—Ä—Ç–∏—Ä—É–µ–º –¥–ª—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏
        tokens_str.join("-")
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/arbitrage/bellman_ford.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/dex_structs.rs ---
// bot/src/dex_structs.rs
use solana_sdk::pubkey::Pubkey;
use std::convert::TryInto;
use anyhow::{Result, anyhow};

/// –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è Raydium AMM V4 AmmInfo
const MIN_AMM_INFO_LEN: usize = 752;

// –ü–†–ê–í–ò–õ–¨–ù–´–ï –û–§–°–ï–¢–´ –î–õ–Ø RAYDIUM AMM V4
const MARKET_ID_OFFSET: usize = 224;
const MARKET_PROGRAM_ID_OFFSET: usize = 256;
const BASE_VAULT_OFFSET: usize = 384;
const QUOTE_VAULT_OFFSET: usize = 416;
const BASE_MINT_OFFSET: usize = 632;
const QUOTE_MINT_OFFSET: usize = 664;

// –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –≤–∞–∂–Ω—ã–µ –ø–æ–ª—è
const STATUS_OFFSET: usize = 0;
const NONCE_OFFSET: usize = 8;
const OPEN_ORDERS_OFFSET: usize = 168;
const TARGET_ORDERS_OFFSET: usize = 200;

#[derive(Debug, Clone, PartialEq)]
pub struct AmmInfo {
    pub status: u64,
    pub nonce: u64,
    pub market_id: Pubkey,
    pub market_program_id: Pubkey,
    pub base_mint: Pubkey,
    pub quote_mint: Pubkey,
    pub base_vault: Pubkey,
    pub quote_vault: Pubkey,
    pub open_orders: Pubkey,
    pub target_orders: Pubkey,
    pub fees: Fees,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Fees {
    pub swap_fee_numerator: u64,
    pub swap_fee_denominator: u64,
}

impl AmmInfo {
    /// –ü–∞—Ä—Å–∏–Ω–≥ AmmInfo –∏–∑ —Å—ã—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–∞ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –æ—Ñ—Å–µ—Ç–∞–º–∏
    pub fn try_from_slice(data: &[u8]) -> Result<Self> {
        if data.len() < MIN_AMM_INFO_LEN {
            return Err(anyhow!(
                "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è AmmInfo: {} –±–∞–π—Ç, —Ç—Ä–µ–±—É–µ—Ç—Å—è –º–∏–Ω–∏–º—É–º {}",
                data.len(),
                MIN_AMM_INFO_LEN
            ));
        }

        let status = read_u64(data, STATUS_OFFSET)?;
        let nonce = read_u64(data, NONCE_OFFSET)?;
        let market_id = read_pubkey(data, MARKET_ID_OFFSET)?;
        let market_program_id = read_pubkey(data, MARKET_PROGRAM_ID_OFFSET)?;
        let base_mint = read_pubkey(data, BASE_MINT_OFFSET)?;
        let quote_mint = read_pubkey(data, QUOTE_MINT_OFFSET)?;
        let base_vault = read_pubkey(data, BASE_VAULT_OFFSET)?;
        let quote_vault = read_pubkey(data, QUOTE_VAULT_OFFSET)?;
        let open_orders = read_pubkey(data, OPEN_ORDERS_OFFSET)?;
        let target_orders = read_pubkey(data, TARGET_ORDERS_OFFSET)?;

        // –£–ø—Ä–æ—â–µ–Ω–Ω—ã–µ –∫–æ–º–∏—Å—Å–∏–∏ (—Ä–µ–∞–ª—å–Ω—ã–µ –æ—Ñ—Å–µ—Ç—ã –∑–∞–≤–∏—Å—è—Ç –æ—Ç –≤–µ—Ä—Å–∏–∏)
        let fees = Fees {
            swap_fee_numerator: 25,     // 0.25% = 25 bps
            swap_fee_denominator: 10_000,
        };

        Ok(Self {
            status,
            nonce,
            market_id,
            market_program_id,
            base_mint,
            quote_mint,
            base_vault,
            quote_vault,
            open_orders,
            target_orders,
            fees,
        })
    }
}

/// –ß—Ç–µ–Ω–∏–µ Pubkey –∏–∑ –¥–∞–Ω–Ω—ã—Ö –ø–æ –æ—Ñ—Å–µ—Ç—É —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –≥—Ä–∞–Ω–∏—Ü
pub fn read_pubkey(data: &[u8], offset: usize) -> Result<Pubkey> {
    if offset + 32 > data.len() {
        return Err(anyhow!(
            "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è Pubkey –ø–æ –æ—Ñ—Å–µ—Ç—É {}: –Ω—É–∂–Ω–æ –µ—â–µ {} –±–∞–π—Ç, –µ—Å—Ç—å {}",
            offset,
            32,
            data.len().saturating_sub(offset)
        ));
    }

    let slice = &data[offset..offset + 32];
    let mut bytes = [0u8; 32];
    bytes.copy_from_slice(slice);

    Ok(Pubkey::new_from_array(bytes))
}

/// –ß—Ç–µ–Ω–∏–µ u64 (little-endian) –∏–∑ –¥–∞–Ω–Ω—ã—Ö –ø–æ –æ—Ñ—Å–µ—Ç—É
pub fn read_u64(data: &[u8], offset: usize) -> Result<u64> {
    if offset + 8 > data.len() {
        return Err(anyhow!(
            "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è u64 –ø–æ –æ—Ñ—Å–µ—Ç—É {}: –Ω—É–∂–Ω–æ –µ—â–µ {} –±–∞–π—Ç, –µ—Å—Ç—å {}",
            offset,
            8,
            data.len().saturating_sub(offset)
        ));
    }

    let slice = &data[offset..offset + 8];
    let bytes: [u8; 8] = slice.try_into()?;
    Ok(u64::from_le_bytes(bytes))
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/dex_structs.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/test_setup.rs ---
// bot/src/test_setup.rs

use anyhow::Result;
use solana_client::rpc_client::RpcClient;
use solana_sdk::{signature::Keypair, pubkey::Pubkey};
use std::str::FromStr;
use std::sync::Arc;
use tracing::info;

use crate::config::BotConfig;
use crate::types::{PoolState, DexProtocol};

pub struct TestEnvironmentSetup {
    rpc_client: Arc,
    config: Arc,
    keypair: Arc,
}

#[derive(Debug)]
pub struct TestEnvironment {
    pub pools: Vec,
    pub token_a: TestToken,
    pub token_b: TestToken,
    pub token_c: TestToken,
    pub market_id: Pubkey,
}

#[derive(Debug)]
pub struct TestToken {
    pub mint: Pubkey,
    pub symbol: String,
    pub decimals: u8,
}

impl TestEnvironmentSetup {
    pub fn new(
        rpc_client: Arc,
        config: Arc,
        keypair: Arc
    ) -> Self {
        Self {
            rpc_client,
            config,
            keypair,
        }
    }

    pub async fn create_test_environment(&self) -> Result {
        info!("üß™ –°–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤–æ–π —Å—Ä–µ–¥—ã —Å –ø—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–º–∏ devnet –∞–¥—Ä–µ—Å–∞–º–∏...");

        // –í–ê–®–ò –¢–û–ö–ï–ù–´
        let token_a = TestToken {
            mint: Pubkey::from_str("7oa4krfxjocDH47RymzbPW4QHVV4Ec4vuAQj1gYAn3SQ")?,
            symbol: "TOKEN_A".to_string(),
            decimals: 9,
        };

        let token_b = TestToken {
            mint: Pubkey::from_str("4PvUes3azNmTSohsrSBBDTFZqVQqM5oCkdF1vZDpPoZS")?,
            symbol: "TOKEN_B".to_string(),
            decimals: 9,
        };

        let token_c = TestToken {
            mint: Pubkey::from_str("ExAMh7G7BRG5qVLFJySeedkCPh39ywpVBNFMAM5rmpdc")?,
            symbol: "TOKEN_C".to_string(),
            decimals: 9,
        };

        // SOL (wrapped)
        let sol_mint = Pubkey::from_str("So11111111111111111111111111111111111111112")?;

        // –°–û–ó–î–ê–ù–ò–ï –í–ê–®–ò–• –ü–£–õ–û–í
        let mut pools = Vec::new();

        // 1. TOKEN_A - TOKEN_B (CPMM)
        pools.push(PoolState {
            id: Pubkey::from_str("7BPcfDdii2UibJTMibrtdnnSwzSAVKat4nQob4BfJgAX")?,
            protocol: DexProtocol::RaydiumCpmm,
            token_a: token_a.mint,
            token_b: token_b.mint,
            reserve_a: 1_000_000_000_000, // 1000 TOKEN_A
            reserve_b: 1_000_000_000_000, // 1000 TOKEN_B
            fee_bps: 25, // 0.25%
            last_updated: chrono::Utc::now().timestamp(),
            full_state_data: Vec::new(),
            decimals_a: token_a.decimals,
            decimals_b: token_b.decimals,
        });

        // 2. TOKEN_A - TOKEN_B (CLMM)
        pools.push(PoolState {
            id: Pubkey::from_str("DWqCNoxn1xN1tiaXK1LQwZaWtnozijW7rdkdHc55qjuL")?,
            protocol: DexProtocol::RaydiumClmm,
            token_a: token_a.mint,
            token_b: token_b.mint,
            reserve_a: 2_000_000_000_000, // 2000 TOKEN_A
            reserve_b: 1_500_000_000_000, // 1500 TOKEN_B (–Ω–µ–±–æ–ª—å—à–∞—è —Ä–∞–∑–Ω–∏—Ü–∞ –≤ —Ü–µ–Ω–µ)
            fee_bps: 30, // 0.30%
            last_updated: chrono::Utc::now().timestamp(),
            full_state_data: Vec::new(),
            decimals_a: token_a.decimals,
            decimals_b: token_b.decimals,
        });

        // 3. TOKEN_B - TOKEN_C (CLMM)
        pools.push(PoolState {
            id: Pubkey::from_str("EEkKpz3avsGAptVyrxjHxFHPHc8zmoGcGyWJG6b1B2Pp")?,
            protocol: DexProtocol::RaydiumClmm,
            token_a: token_b.mint,
            token_b: token_c.mint,
            reserve_a: 1_200_000_000_000, // 1200 TOKEN_B
            reserve_b: 800_000_000_000,   // 800 TOKEN_C
            fee_bps: 30,
            last_updated: chrono::Utc::now().timestamp(),
            full_state_data: Vec::new(),
            decimals_a: token_b.decimals,
            decimals_b: token_c.decimals,
        });

        // 4. TOKEN_A - TOKEN_C (CPMM)
        pools.push(PoolState {
            id: Pubkey::from_str("uF1h7WsKs5XRCUjLmSK7jd3i5TQcr4HCAG1zqNweioz")?,
            protocol: DexProtocol::RaydiumCpmm,
            token_a: token_a.mint,
            token_b: token_c.mint,
            reserve_a: 900_000_000_000,  // 900 TOKEN_A
            reserve_b: 1_100_000_000_000, // 1100 TOKEN_C (—Å–æ–∑–¥–∞–µ–º –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—É—é –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å)
            fee_bps: 25,
            last_updated: chrono::Utc::now().timestamp(),
            full_state_data: Vec::new(),
            decimals_a: token_a.decimals,
            decimals_b: token_c.decimals,
        });

        // 5. SOL - TOKEN_A (CLMM)
        pools.push(PoolState {
            id: Pubkey::from_str("8Zy45DRxTxMt4qGJDJ3g6gTQZTyxJcsJBUHfWag5aGek")?,
            protocol: DexProtocol::RaydiumClmm,
            token_a: sol_mint,
            token_b: token_a.mint,
            reserve_a: 100_000_000_000, // 100 SOL
            reserve_b: 10_000_000_000_000, // 10000 TOKEN_A
            fee_bps: 30,
            last_updated: chrono::Utc::now().timestamp(),
            full_state_data: Vec::new(),
            decimals_a: 9, // SOL decimals
            decimals_b: token_a.decimals,
        });

        info!("‚úÖ –°–æ–∑–¥–∞–Ω–æ {} —Ç–µ—Å—Ç–æ–≤—ã—Ö –ø—É–ª–æ–≤ —Å –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã–º–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏", pools.len());

        // –§–∏–∫—Ç–∏–≤–Ω—ã–π market ID –¥–ª—è OpenBook
        let market_id = Pubkey::from_str("58oQGaA6hKq9Y2V8m5g5m1Y4k1vNHX5wWvLQ9RhGh9Z")?;

        Ok(TestEnvironment {
            pools,
            token_a,
            token_b,
            token_c,
            market_id,
        })
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/test_setup.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/utils/rpc.rs ---
// bot/src/utils/rpc.rs
// –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å RPC –∫–ª–∏–µ–Ω—Ç–∞–º–∏ Solana

use anyhow::Result;
use solana_client::{
    rpc_client::RpcClient,
    rpc_config::RpcSendTransactionConfig,
    // –£–î–ê–õ–ò–¢–ï –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –∏–º–ø–æ—Ä—Ç—ã:
    // rpc_config::{RpcSendTransactionConfig, RpcSimulateTransactionConfig},
    // client_error::ClientError,
};
use solana_sdk::{
    commitment_config::CommitmentConfig,
    transaction::Transaction,
    signature::Signature,
};
use std::time::Duration;
use tokio::time::sleep;
use tracing::{warn, debug};

/// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Ä–µ—Ç—Ä–∞–µ–≤ –¥–ª—è RPC –∑–∞–ø—Ä–æ—Å–æ–≤
pub struct RetryConfig {
    pub max_retries: usize,
    pub base_delay_ms: u64,
    pub exponential_backoff: bool,
}

impl Default for RetryConfig {
    fn default() -> Self {
        Self {
            max_retries: 3,
            base_delay_ms: 500,
            exponential_backoff: true,
        }
    }
}

/// RPC –∫–ª–∏–µ–Ω—Ç —Å –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ endpoints –∏ —Ä–µ—Ç—Ä–∞—è–º–∏
pub struct MultiRpcClient {
    primary: RpcClient,
    fallbacks: Vec<RpcClient>,
    retry_config: RetryConfig,
}

impl MultiRpcClient {
    pub fn new(primary_url: String, fallback_urls: Vec<String>) -> Self {
        let primary = RpcClient::new_with_commitment(
            primary_url,
            CommitmentConfig::confirmed(),
        );

        let fallbacks: Vec<RpcClient> = fallback_urls
            .into_iter()
            .map(|url| RpcClient::new_with_commitment(url, CommitmentConfig::confirmed()))
            .collect();

        Self {
            primary,
            fallbacks,
            retry_config: RetryConfig::default(),
        }
    }

    /// –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ —Å —Ä–µ—Ç—Ä–∞—è–º–∏
    pub async fn send_transaction_with_retry(
        &self,
        transaction: &Transaction,
    ) -> Result<Signature> {
        let config = RpcSendTransactionConfig {
            skip_preflight: false,
            preflight_commitment: Some(CommitmentConfig::confirmed().commitment),
            ..Default::default()
        };

        let mut last_error = None;

        // –ü–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ primary RPC
        for attempt in 0..self.retry_config.max_retries {
            match self.primary.send_transaction_with_config(transaction, config) {
                Ok(signature) => {
                    debug!("–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞: {} (–ø–æ–ø—ã—Ç–∫–∞ {})", signature, attempt + 1);
                    return Ok(signature);
                }
                Err(e) => {
                    warn!("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ (–ø–æ–ø—ã—Ç–∫–∞ {}): {}", attempt + 1, e);
                    last_error = Some(e);

                    if attempt < self.retry_config.max_retries - 1 {
                        let delay = self.calculate_delay(attempt);
                        sleep(Duration::from_millis(delay)).await;
                    }
                }
            }
        }

        // –ü–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ fallback RPCs
        for (idx, fallback) in self.fallbacks.iter().enumerate() {
            match fallback.send_transaction_with_config(transaction, config) {
                Ok(signature) => {
                    debug!("–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ —á–µ—Ä–µ–∑ fallback #{}: {}", idx + 1, signature);
                    return Ok(signature);
                }
                Err(e) => {
                    warn!("Fallback #{} –ø—Ä–æ–≤–∞–ª–∏–ª—Å—è: {}", idx + 1, e);
                    last_error = Some(e);
                }
            }
        }

        Err(anyhow::anyhow!(
            "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –ø–æ—Å–ª–µ {} –ø–æ–ø—ã—Ç–æ–∫: {:?}",
            self.retry_config.max_retries,
            last_error
        ))
    }

    /// –°–∏–º—É–ª—è—Ü–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ —Å —Ä–µ—Ç—Ä–∞—è–º–∏
    pub async fn simulate_transaction_with_retry(
        &self,
        transaction: &Transaction,
    ) -> Result<solana_client::rpc_response::RpcSimulateTransactionResult> {
        let mut last_error = None;

        for attempt in 0..self.retry_config.max_retries {
            match self.primary.simulate_transaction(transaction) {
                Ok(result) => return Ok(result.value),
                Err(e) => {
                    warn!("–°–∏–º—É–ª—è—Ü–∏—è –ø—Ä–æ–≤–∞–ª–∏–ª–∞—Å—å (–ø–æ–ø—ã—Ç–∫–∞ {}): {}", attempt + 1, e);
                    last_error = Some(e);

                    if attempt < self.retry_config.max_retries - 1 {
                        let delay = self.calculate_delay(attempt);
                        sleep(Duration::from_millis(delay)).await;
                    }
                }
            }
        }

        Err(anyhow::anyhow!(
            "–°–∏–º—É–ª—è—Ü–∏—è –ø—Ä–æ–≤–∞–ª–∏–ª–∞—Å—å –ø–æ—Å–ª–µ {} –ø–æ–ø—ã—Ç–æ–∫: {:?}",
            self.retry_config.max_retries,
            last_error
        ))
    }

    /// –†–∞—Å—á—ë—Ç –∑–∞–¥–µ—Ä–∂–∫–∏ —Å exponential backoff
    fn calculate_delay(&self, attempt: usize) -> u64 {
        if self.retry_config.exponential_backoff {
            self.retry_config.base_delay_ms * (2_u64.pow(attempt as u32))
        } else {
            self.retry_config.base_delay_ms
        }
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/utils/rpc.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/utils/mod.rs ---
// bot/src/utils/mod.rs
pub mod math;
pub mod rpc;

use anyhow::{Context, Result};
use solana_sdk::signature::Keypair;
use std::fs;
use std::str::FromStr;
use solana_sdk::pubkey::Pubkey;

/// –ó–∞–≥—Ä—É–∑–∫–∞ keypair –∏–∑ —Ñ–∞–π–ª–∞
pub fn load_keypair_from_file(path: &str) -> Result<Keypair> {
    let expanded_path = shellexpand::tilde(path).into_owned();

    let keypair_bytes = fs::read(&expanded_path)
        .context(format!("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª –∫–æ—à–µ–ª—å–∫–∞: {}", expanded_path))?;

    let keypair_data: Vec<u8> = serde_json::from_slice(&keypair_bytes)
        .context("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞ –∫–æ—à–µ–ª—å–∫–∞ (–æ–∂–∏–¥–∞–µ—Ç—Å—è JSON –º–∞—Å—Å–∏–≤ –±–∞–π—Ç)")?;

    // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –∏—Å–ø–æ–ª—å–∑—É–µ–º try_from –≤–º–µ—Å—Ç–æ —É—Å—Ç–∞—Ä–µ–≤—à–µ–≥–æ from_bytes
    let keypair = Keypair::try_from(&keypair_data[..])
        .map_err(|e| anyhow::anyhow!("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å keypair –∏–∑ –±–∞–π—Ç–æ–≤: {}. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–∞–π–ª —Å–æ–¥–µ—Ä–∂–∏—Ç 64 –±–∞–π—Ç–∞.", e))?;

    Ok(keypair)
}

/// –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ lamports –≤ SOL —Å –∑–∞–¥–∞–Ω–Ω–æ–π —Ç–æ—á–Ω–æ—Å—Ç—å—é
pub fn lamports_to_sol(lamports: u64, decimals: usize) -> String {
    let sol = lamports as f64 / 1_000_000_000.0;
    format!("{:.decimals$}", sol, decimals = decimals)
}

/// –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è SOL –≤ lamports
pub fn sol_to_lamports(sol: f64) -> u64 {
    (sol * 1_000_000_000.0) as u64
}

/// –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏ Pubkey
pub fn is_valid_pubkey(address: &str) -> bool {
    Pubkey::from_str(address).is_ok()
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/utils/mod.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/utils/math.rs ---
// bot/src/utils/math.rs
// –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —É—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ä–∞—Å—á—ë—Ç–æ–≤ –∞—Ä–±–∏—Ç—Ä–∞–∂–∞

use anyhow::Result;

/// –†–∞—Å—á—ë—Ç –≤—ã—Ö–æ–¥–∞ —Å–≤–æ–ø–∞ –ø–æ —Ñ–æ—Ä–º—É–ª–µ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–≥–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è (AMM)
///
/// # –§–æ—Ä–º—É–ª–∞
/// amount_out = (reserve_out * amount_in) / (reserve_in + amount_in)
///
/// # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
/// - reserve_in: –†–µ–∑–µ—Ä–≤ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ç–æ–∫–µ–Ω–∞
/// - reserve_out: –†–µ–∑–µ—Ä–≤ –≤—ã—Ö–æ–¥–Ω–æ–≥–æ —Ç–æ–∫–µ–Ω–∞
/// - amount_in: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ç–æ–∫–µ–Ω–∞
/// - fee_bps: –ö–æ–º–∏—Å—Å–∏—è –≤ –±–∞–∑–∏—Å–Ω—ã—Ö –ø—É–Ω–∫—Ç–∞—Ö (25 = 0.25%)
pub fn calculate_amm_swap_output(
    reserve_in: u64,
    reserve_out: u64,
    amount_in: u64,
    fee_bps: u16,
) -> Result<u64> {
    if reserve_in == 0 || reserve_out == 0 {
        anyhow::bail!("–ù—É–ª–µ–≤—ã–µ —Ä–µ–∑–µ—Ä–≤—ã –≤ –ø—É–ª–µ");
    }

    // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –∫–æ–º–∏—Å—Å–∏–∏ –∫ –≤—Ö–æ–¥–Ω–æ–π —Å—É–º–º–µ
    let fee_multiplier = 1.0 - (fee_bps as f64 / 10000.0);
    let amount_in_with_fee = (amount_in as f64) * fee_multiplier;

    // –§–æ—Ä–º—É–ª–∞ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–≥–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
    let numerator = (reserve_out as f64) * amount_in_with_fee;
    let denominator = (reserve_in as f64) + amount_in_with_fee;

    let amount_out = numerator / denominator;

    Ok(amount_out as u64)
}

/// –†–∞—Å—á—ë—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –≤—ã—Ö–æ–¥–∞ —Å —É—á—ë—Ç–æ–º slippage
///
/// # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
/// - expected_amount: –û–∂–∏–¥–∞–µ–º–∞—è —Å—É–º–º–∞
/// - slippage_bps: –î–æ–ø—É—Å—Ç–∏–º—ã–π slippage –≤ –±–∞–∑–∏—Å–Ω—ã—Ö –ø—É–Ω–∫—Ç–∞—Ö (100 = 1%)
pub fn calculate_minimum_amount_out(
    expected_amount: u64,
    slippage_bps: u16,
) -> u64 {
    let slippage_multiplier = 1.0 - (slippage_bps as f64 / 10000.0);
    ((expected_amount as f64) * slippage_multiplier) as u64
}

/// –†–∞—Å—á—ë—Ç —Ü–µ–Ω—ã —Ç–æ–∫–µ–Ω–∞ A –≤ —Ç–µ—Ä–º–∏–Ω–∞—Ö —Ç–æ–∫–µ–Ω–∞ B
pub fn calculate_price_a_to_b(reserve_a: u64, reserve_b: u64) -> f64 {
    if reserve_b == 0 {
        return 0.0;
    }
    reserve_a as f64 / reserve_b as f64
}

/// –†–∞—Å—á—ë—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ü–µ–Ω—ã –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö
pub fn calculate_price_change_percent(old_price: f64, new_price: f64) -> f64 {
    if old_price == 0.0 {
        return 0.0;
    }
    ((new_price - old_price) / old_price) * 100.0
}

/// –†–∞—Å—á—ë—Ç –ø—Ä–∏–±—ã–ª–∏ –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö
pub fn calculate_profit_percentage(initial: u64, final_amount: u64) -> f64 {
    if initial == 0 {
        return 0.0;
    }
    ((final_amount as f64 - initial as f64) / initial as f64) * 100.0
}

/// –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∏–±—ã–ª—å–Ω–æ—Å—Ç–∏ —Å —É—á—ë—Ç–æ–º –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –ø–æ—Ä–æ–≥–∞
pub fn is_profitable(
    initial_amount: u64,
    final_amount: u64,
    min_profit_lamports: u64,
) -> bool {
    final_amount >= initial_amount + min_profit_lamports
}

/// –†–∞—Å—á—ë—Ç –æ–±—â–∏—Ö –∫–æ–º–∏—Å—Å–∏–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
pub fn calculate_total_transaction_fees(
    base_fee: u64,
    priority_fee: u64,
    jito_tip: u64,
) -> u64 {
    base_fee + priority_fee + jito_tip
}

/// –†–∞—Å—á—ë—Ç —Ç–æ—á–∫–∏ –±–µ–∑—É–±—ã—Ç–æ—á–Ω–æ—Å—Ç–∏ (breakeven) –¥–ª—è –∞—Ä–±–∏—Ç—Ä–∞–∂–∞
///
/// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —Ñ–∏–Ω–∞–ª—å–Ω—É—é —Å—É–º–º—É –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –Ω—É–ª–µ–≤–æ–π –ø—Ä–∏–±—ã–ª–∏
pub fn calculate_breakeven_amount(
    initial_amount: u64,
    transaction_fees: u64,
) -> u64 {
    initial_amount + transaction_fees
}

/// –†–∞—Å—á—ë—Ç —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–π APY –¥–ª—è –∞—Ä–±–∏—Ç—Ä–∞–∂–∞
///
/// # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
/// - profit_lamports: –ü—Ä–∏–±—ã–ª—å –∑–∞ –æ–¥–Ω—É —Å–¥–µ–ª–∫—É
/// - capital_lamports: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–π –∫–∞–ø–∏—Ç–∞–ª
/// - trades_per_day: –°—Ä–µ–¥–Ω–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–¥–µ–ª–æ–∫ –≤ –¥–µ–Ω—å
pub fn calculate_effective_apy(
    profit_lamports: u64,
    capital_lamports: u64,
    trades_per_day: f64,
) -> f64 {
    if capital_lamports == 0 {
        return 0.0;
    }

    let daily_return = (profit_lamports as f64 / capital_lamports as f64) * trades_per_day;
    let annual_return = daily_return * 365.0;

    annual_return * 100.0 // –í –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö
}

/// –†–∞—Å—á—ë—Ç impact –Ω–∞ –ø—É–ª (price impact –æ—Ç —Å–≤–æ–ø–∞)
pub fn calculate_price_impact(
    reserve_in: u64,
    reserve_out: u64,
    amount_in: u64,
) -> f64 {
    let price_before = reserve_out as f64 / reserve_in as f64;
    let new_reserve_in = reserve_in + amount_in;
    let price_after = reserve_out as f64 / new_reserve_in as f64;

    ((price_after - price_before) / price_before).abs() * 100.0
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_amm_swap_output() {
        // –ü—É–ª: 1000 USDC, 1000 SOL, –∫–æ–º–∏—Å—Å–∏—è 0.25%
        let output = calculate_amm_swap_output(
            1_000_000_000, // 1000 USDC
            1_000_000_000, // 1000 SOL
            100_000_000,   // 100 USDC in
            25,            // 0.25% fee
        ).unwrap();

        // –û–∂–∏–¥–∞–µ–º ~90.7 SOL (—Å —É—á—ë—Ç–æ–º –∫–æ–º–∏—Å—Å–∏–∏ –∏ slippage)
        assert!(output > 90_000_000 && output < 100_000_000);
    }

    #[test]
    fn test_minimum_amount_out() {
        let expected = 1_000_000_000; // 1 SOL
        let min_out = calculate_minimum_amount_out(expected, 100); // 1% slippage

        assert_eq!(min_out, 990_000_000); // 0.99 SOL
    }

    #[test]
    fn test_price_change() {
        let change = calculate_price_change_percent(100.0, 110.0);
        assert!((change - 10.0).abs() < 0.01);

        let change_down = calculate_price_change_percent(100.0, 90.0);
        assert!((change_down + 10.0).abs() < 0.01);
    }

    #[test]
    fn test_profitability_check() {
        assert!(is_profitable(1_000_000, 1_100_000, 50_000)); // –ü—Ä–∏–±—ã–ª—å–Ω–æ
        assert!(!is_profitable(1_000_000, 1_040_000, 50_000)); // –ù–µ –ø—Ä–∏–±—ã–ª—å–Ω–æ
    }

    #[test]
    fn test_apy_calculation() {
        // –ü—Ä–∏–±—ã–ª—å 0.01 SOL —Å –∫–∞–ø–∏—Ç–∞–ª–∞ 1 SOL, 10 —Å–¥–µ–ª–æ–∫ –≤ –¥–µ–Ω—å
        let apy = calculate_effective_apy(
            10_000_000,   // 0.01 SOL profit
            1_000_000_000, // 1 SOL capital
            10.0,         // 10 trades/day
        );

        // –û–∂–∏–¥–∞–µ–º ~36.5% –≥–æ–¥–æ–≤—ã—Ö
        assert!((apy - 36.5).abs() < 1.0);
    }

    #[test]
    fn test_price_impact() {
        let impact = calculate_price_impact(
            1_000_000_000, // 1000 tokens in reserve
            1_000_000_000, // 1000 tokens out reserve
            100_000_000,   // 100 tokens swap
        );

        // Impact –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å ~9.09%
        assert!(impact > 9.0 && impact < 10.0);
    }
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/utils/math.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/check-ata.js ---
// check-ata.js

const { Connection, PublicKey } = require('@solana/web3.js');
const { getAccount, TOKEN_PROGRAM_ID } = require('@solana/spl-token');

const connection = new Connection('[https://api.devnet.solana.com](https://api.devnet.solana.com)', 'confirmed');

const ATA_ADDRESSES = [
    'ASkpsRKwGKbUmmMrdknqnHVrmxsU8Ws6qeX5iE6AUERK',
    '73weDmPbP1pjZyshM47xiUV6pSadjoZPEtHeczAmNE7P',
    'HkuaPeSMog2jbGMYm7vjPFSaheM69PS1VXoioTp25sxS'
];

async function checkATA() {
    console.log('üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ Associated Token Accounts...');

    for (let i = 0; i < ATA_ADDRESSES.length; i++) {
        const ata = new PublicKey(ATA_ADDRESSES[i]);

        try {
            const accountInfo = await connection.getAccountInfo(ata);

            if (accountInfo) {
                const tokenAccount = await getAccount(connection, ata);
                console.log(`‚úÖ ATA ${i + 1}: ${ata.toString()}`);
                console.log(`   Mint: ${tokenAccount.mint.toString()}`);
                console.log(`   Balance: ${tokenAccount.amount.toString()}`);
                console.log(`   Owner: ${tokenAccount.owner.toString()}`);
            } else {
                console.log(`‚ùå ATA ${i + 1}: ${ata.toString()} - –Ω–µ –Ω–∞–π–¥–µ–Ω`);
            }
        } catch (error) {
            console.log(`‚ö†Ô∏è ATA ${i + 1}: ${ata.toString()} - –æ—à–∏–±–∫–∞: ${error.message}`);
        }

        console.log('');
    }
}

checkATA().catch(console.error);
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/check-ata.js ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/src/types.rs ---
// bot/src/types.rs
// Shared types and structures

use serde::{Deserialize, Serialize};
use solana_sdk::pubkey::Pubkey;
use std::fmt;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum DexProtocol {
    RaydiumAmmV4,
    RaydiumCpmm,
    RaydiumClmm,
    MeteoraDlmm,
}

impl fmt::Display for DexProtocol {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DexProtocol::RaydiumAmmV4 => write!(f, "Raydium AMM V4"),
            DexProtocol::RaydiumCpmm => write!(f, "Raydium CPMM"),
            DexProtocol::RaydiumClmm => write!(f, "Raydium CLMM"),
            DexProtocol::MeteoraDlmm => write!(f, "Meteora DLMM"),
        }
    }
}

/// Pool state data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PoolState {
    pub id: Pubkey,
    pub protocol: DexProtocol,
    pub token_a: Pubkey,
    pub token_b: Pubkey,
    pub reserve_a: u64,
    pub reserve_b: u64,
    pub fee_bps: u16,
    pub last_updated: i64,
    pub full_state_data: Vec<u8>,
    pub decimals_a: u8,
    pub decimals_b: u8,
}

impl PoolState {
    pub fn price_a_to_b(&self) -> f64 {
        if self.reserve_b == 0 {
            return 0.0;
        }
        self.reserve_a as f64 / self.reserve_b as f64
    }

    pub fn price_b_to_a(&self) -> f64 {
        if self.reserve_a == 0 {
            return 0.0;
        }
        self.reserve_b as f64 / self.reserve_a as f64
    }
}

/// Single swap leg in arbitrage route
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SwapLeg {
    pub protocol: DexProtocol,
    pub pool_id: Pubkey,
    pub input_mint: Pubkey,
    pub output_mint: Pubkey,
    pub amount_in: u64,
    pub minimum_amount_out: u64,
    pub estimated_amount_out: u64,
    pub fee_bps: u16,
    pub pool_state_data: Vec<u8>,
}

/// Complete arbitrage opportunity
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ArbitrageOpportunity {
    pub legs: Vec<SwapLeg>,
    pub initial_amount: u64,
    pub expected_final_amount: u64,
    pub gross_profit: u64,
    pub net_profit: u64,
    pub profit_percentage: f64,
    pub discovered_at: i64,
}

impl ArbitrageOpportunity {
    pub fn is_profitable(&self, min_profit: u64) -> bool {
        self.net_profit >= min_profit
    }
}

/// Price edge in graph
#[derive(Debug, Clone, Copy)]
pub struct PriceEdge {
    pub from_token: Pubkey,
    pub to_token: Pubkey,
    pub pool_id: Pubkey,
    pub protocol: DexProtocol,
    pub weight: f64, // -log(exchange_rate) for Bellman-Ford
    pub fee_bps: u16,
}

pub struct SimulationResult {
    pub err: Option<String>,
    pub logs: Vec<String>,
    pub units_consumed: Option<u64>,
}
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/src/types.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/bot/Cargo.toml ---
# bot/Cargo.toml
[package]
name = "arbitrage-bot"
version = "0.1.0"
edition = "2021"

[dependencies]
arbitrage-executor = { path = "../programs/arbitrage-executor" }

solana-program = { workspace = true }
solana-sdk = { workspace = true }
solana-client = { workspace = true }
solana-account-decoder = { workspace = true }
solana-transaction-status = { workspace = true }
solana-program-pack = { workspace = true }

anchor-client = { workspace = true }
anchor-spl = { workspace = true }
borsh = { workspace = true }
anchor-lang = { workspace = true }
solana-system-interface = { version = "2.0.0" }

tokio = { workspace = true }
futures = "0.3"
async-trait = "0.1"

serde = { workspace = true }
serde_json = { workspace = true }
bincode = { workspace = true }

tracing = { workspace = true }
tracing-subscriber = { workspace = true }
anyhow = { workspace = true }

reqwest = { workspace = true }
dotenv = "0.15"


bs58 = { workspace = true }
rayon = { workspace = true }
dashmap = { workspace = true }
chrono = { workspace = true }
shellexpand = { workspace = true }
once_cell = { workspace = true }
lru = { workspace = true }


spl-token = { workspace = true }
spl-associated-token-account = { workspace = true }
bytemuck = { version = "1.14", features = ["derive"] }
--- End File: /home/newvovi5/arbitrage-bot-rust/bot/Cargo.toml ---

--- File: /home/newvovi5/arbitrage-bot-rust/Cargo.toml ---
[workspace]
members = [
    "programs/arbitrage-executor",
    "bot",
    "pools",
]
resolver = "2"

[workspace.dependencies]
# –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –≤–µ—Ä—Å–∏–∏ –¥–ª—è nightly Rust
solana-sdk = "2.3.0"
solana-client = "2.3.0"
solana-program = "2.3.0"
solana-account-decoder = "2.3.0"
solana-transaction-status = "2.3.0"
solana-system-interface = "2.0.0"
solana-program-pack = "2.2.1"

anchor-lang = "0.31.0"
anchor-spl = "0.31.0"
anchor-client = "0.31.0"

# --- –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –í–ï–†–°–ò–ò ---
borsh = "1.5.1"
spl-token = "6.0.0"
spl-associated-token-account = "6.0.0"

# --- –†–ê–°–ö–û–ú–ú–ï–ù–¢–ò–†–û–í–ê–ù–ù–´–ï –ó–ê–í–ò–°–ò–ú–û–°–¢–ò –ë–û–¢–ê ---
tokio = { version = "1.38", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
bincode = "1.3"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
anyhow = "1.0"
reqwest = { version = "0.11", features = ["json", "rustls-tls"] }
bs58 = "0.5"
rayon = "1.10"
dashmap = "5.5"
chrono = "0.4"
shellexpand = "3.1"
once_cell = "1.21.3"
lru = "0.12"
futures = "0.3"
async-trait = "0.1"
bytemuck = { version = "1.14", features = ["derive"] }



[profile.release]
overflow-checks = true
--- End File: /home/newvovi5/arbitrage-bot-rust/Cargo.toml ---

--- File: /home/newvovi5/arbitrage-bot-rust/config.toml ---
# config.toml

devnet = true
rpc_url = "[https://api.devnet.solana.com](https://api.devnet.solana.com)"
private_key = "YOUR_WALLET_PRIVATE_KEY_BASE58"  # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –≤–∞—à –∫–ª—é—á
min_profit_threshold = 0.001  # 0.1% –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–∏–±—ã–ª—å
max_slippage = 0.05          # 5% –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Å–ª–∏–ø–ø–∞–¥–∂

# –í–ê–®–ò –°–£–©–ï–°–¢–í–£–Æ–©–ò–ï –ü–£–õ–´
[[pools]]
address = "7BPcfDdii2UibJTMibrtdnnSwzSAVKat4nQob4BfJgAX"
token_a = "7oa4krfxjocDH47RymzbPW4QHVV4Ec4vuAQj1gYAn3SQ"  # TOKEN_A
token_b = "4PvUes3azNmTSohsrSBBDTFZqVQqM5oCkdF1vZDpPoZS"  # TOKEN_B
pool_type = "CPMM"

[[pools]]
address = "DWqCNoxn1xN1tiaXK1LQwZaWtnozijW7rdkdHc55qjuL"
token_a = "7oa4krfxjocDH47RymzbPW4QHVV4Ec4vuAQj1gYAn3SQ"  # TOKEN_A
token_b = "4PvUes3azNmTSohsrSBBDTFZqVQqM5oCkdF1vZDpPoZS"  # TOKEN_B
pool_type = "CLMM"

[[pools]]
address = "EEkKpz3avsGAptVyrxjHxFHPHc8zmoGcGyWJG6b1B2Pp"
token_a = "4PvUes3azNmTSohsrSBBDTFZqVQqM5oCkdF1vZDpPoZS"  # TOKEN_B
token_b = "ExAMh7G7BRG5qVLFJySeedkCPh39ywpVBNFMAM5rmpdc"  # TOKEN_C
pool_type = "CLMM"

[[pools]]
address = "uF1h7WsKs5XRCUjLmSK7jd3i5TQcr4HCAG1zqNweioz"
token_a = "7oa4krfxjocDH47RymzbPW4QHVV4Ec4vuAQj1gYAn3SQ"  # TOKEN_A
token_b = "ExAMh7G7BRG5qVLFJySeedkCPh39ywpVBNFMAM5rmpdc"  # TOKEN_C
pool_type = "CPMM"

[[pools]]
address = "8Zy45DRxTxMt4qGJDJ3g6gTQZTyxJcsJBUHfWag5aGek"
token_a = "So11111111111111111111111111111111111111112"    # SOL (wrapped)
token_b = "7oa4krfxjocDH47RymzbPW4QHVV4Ec4vuAQj1gYAn3SQ"  # TOKEN_A
pool_type = "CLMM"

# –ú–ï–¢–ê–î–ê–ù–ù–´–ï –¢–û–ö–ï–ù–û–í
[[tokens]]
mint = "7oa4krfxjocDH47RymzbPW4QHVV4Ec4vuAQj1gYAn3SQ"
symbol = "TOKEN_A"
decimals = 9

[[tokens]]
mint = "4PvUes3azNmTSohsrSBBDTFZqVQqM5oCkdF1vZDpPoZS"
symbol = "TOKEN_B"
decimals = 9

[[tokens]]
mint = "ExAMh7G7BRG5qVLFJySeedkCPh39ywpVBNFMAM5rmpdc"
symbol = "TOKEN_C"
decimals = 9

[[tokens]]
mint = "So11111111111111111111111111111111111111112"
symbol = "SOL"
decimals = 9
--- End File: /home/newvovi5/arbitrage-bot-rust/config.toml ---

--- File: /home/newvovi5/arbitrage-bot-rust/Anchor.toml ---
# arbitrage-bot-rust/Anchor.toml
[toolchain]
anchor_version = "0.31.0"
solana_version = "2.3.0"

[features]
seeds = false
skip-lint = false
resolution = true

[programs.localnet]
arbitrage_executor = "HXccYBQu47LExrec1CAUBybYsXQL2pkEEdTaSD9emRY9"

[programs.devnet]
arbitrage_executor = "HXccYBQu47LExrec1CAUBybYsXQL2pkEEdTaSD9emRY9"

[programs.mainnet]
arbitrage_executor = "HXccYBQu47LExrec1CAUBybYsXQL2pkEEdTaSD9emRY9"

[registry]
url = "https://api.apr.dev"

[provider]
cluster = "devnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "cargo test-sbf"
build = "anchor build"
deploy-devnet = "anchor deploy --provider.cluster devnet"
deploy-mainnet = "anchor deploy --provider.cluster mainnet-beta"

[test]
startup_wait = 10000

[[test.genesis]]
address = "44SMYSDatw9DU6amM4d3Yv9SkxzBRphtoftLP6ep5M7T"
program = "./target/deploy/arbitrage_executor.so"

[test.validator]
bind_address = "0.0.0.0"
url = "https://api.devnet.solana.com"
--- End File: /home/newvovi5/arbitrage-bot-rust/Anchor.toml ---

--- File: /home/newvovi5/arbitrage-bot-rust/programs/arbitrage-executor/src/lib.rs ---
// programs/arbitrage-executor/src/lib.rs
// Smart Contract "Executor" for Atomic Multi-Hop Swaps via CPI
#![allow(deprecated)]

use anchor_lang::prelude::*;
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{
    instruction::{AccountMeta, Instruction},
    program::invoke,
};
use anchor_spl::token::{Token, TokenAccount, Mint};
use anchor_lang::solana_program::pubkey;

declare_id!("HXccYBQu47LExrec1CAUBybYsXQL2pkEEdTaSD9emRY9");

// ============================================================================
// DEX PROGRAM IDS (MAINNET)
// ============================================================================

pub const RAYDIUM_AMM_V4: Pubkey = pubkey!("DRaya7Kj3aMWQSy19kSjvmuwq9docCHofyP9kanQGaav");
pub const RAYDIUM_CPMM: Pubkey = pubkey!("DRaycpLY18LhpbydsBWbVJtxpNv9oXPgjRSfpF2bWpYb");
pub const RAYDIUM_CLMM: Pubkey = pubkey!("DRayAUgENGQBKVaX8owNhgzkEDyoHTGVEGHVJT1E9pfH");
pub const METEORA_DLMM: Pubkey = pubkey!("LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo");

// ============================================================================
// TYPES & ENUMS
// ============================================================================

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq, Debug)]
pub enum DexProtocol {
    RaydiumAmmV4,
    RaydiumCpmm,
    RaydiumClmm,
    MeteoraDlmm,
}

impl DexProtocol {
    pub fn program_id(&self) -> Pubkey {
        match self {
            DexProtocol::RaydiumAmmV4 => RAYDIUM_AMM_V4,
            DexProtocol::RaydiumCpmm => RAYDIUM_CPMM,
            DexProtocol::RaydiumClmm => RAYDIUM_CLMM,
            DexProtocol::MeteoraDlmm => METEORA_DLMM,
        }
    }
}

/// Single swap leg in multi-hop route
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct SwapLeg {
    pub protocol: DexProtocol,
    pub pool_id: Pubkey,
    pub input_mint: Pubkey,
    pub output_mint: Pubkey,
    pub amount_in: u64,
    pub minimum_amount_out: u64,
    /// Number of accounts needed for CPI (extracted from remaining_accounts)
    pub accounts_len: u8,
}

// ============================================================================
// ERRORS
// ============================================================================

#[error_code]
pub enum ArbitrageError {
    #[msg("Insufficient profit - arbitrage not profitable")]
    InsufficientProfit,
    #[msg("Slippage tolerance exceeded")]
    SlippageExceeded,
    #[msg("Invalid number of accounts provided")]
    InvalidAccountsCount,
    #[msg("Invalid DEX protocol specified")]
    InvalidDexProtocol,
    #[msg("Math overflow during calculation")]
    MathOverflow,
    #[msg("Unauthorized user")]
    Unauthorized,
    #[msg("Too many swap legs (max 5)")]
    TooManyLegs,
    #[msg("Insufficient balance")]
    InsufficientBalance,
    #[msg("CPI call failed")]
    CpiCallFailed,
    #[msg("Invalid token account")]
    InvalidTokenAccount,
}

// ============================================================================
// PROGRAM MODULE
// ============================================================================

#[program]
pub mod arbitrage_executor {
    use super::*;

    /// Execute atomic multi-hop arbitrage swap
    ///
    /// # Parameters
    /// - `swap_legs`: Sequence of swaps to execute
    /// - `min_profit_lamports`: Minimum required profit in lamports
    ///
    /// # Logic
    /// 1. Record initial balance
    /// 2. Execute each swap via CPI to respective DEX
    /// 3. Verify final balance >= initial + min_profit
    /// 4. If profit insufficient - transaction reverts
    pub fn execute_arbitrage<'a, 'b, 'c, 'info>(
        ctx: Context<'a, 'b, 'c, 'info, ExecuteArbitrage<'info>>,
        swap_legs: Vec<SwapLeg>,
        min_profit_lamports: u64,
    ) -> Result<()>
    where
        'c: 'info,
    {
        // Validate swap legs count (max 5 to limit compute units)
        require!(
            !swap_legs.is_empty() && swap_legs.len() <= 5,
            ArbitrageError::TooManyLegs
        );

        msg!(
            "üöÄ Starting arbitrage: {} legs, min profit {} lamports",
            swap_legs.len(),
            min_profit_lamports
        );

        // Record initial balance
        let initial_balance = ctx.accounts.user_token_account.amount;
        msg!("üí∞ Initial balance: {} lamports", initial_balance);

        // Validate sufficient balance
        require!(
            initial_balance >= swap_legs[0].amount_in,
            ArbitrageError::InsufficientBalance
        );

        // Execute each swap leg
        let mut account_cursor = 0_usize;

        for (idx, leg) in swap_legs.iter().enumerate() {
            msg!(
                "üìä Leg {}/{}: {:?} on pool {}",
                idx + 1,
                swap_legs.len(),
                leg.protocol,
                leg.pool_id
            );

            // Extract accounts for current leg from remaining_accounts
            let accounts_end = account_cursor
                .checked_add(leg.accounts_len as usize)
                .ok_or(ArbitrageError::MathOverflow)?;
            require!(
            accounts_end <= ctx.remaining_accounts.len(),
            ArbitrageError::InvalidAccountsCount
        );

            let leg_accounts = &ctx.remaining_accounts[account_cursor..accounts_end];

            // Execute swap via CPI
            execute_swap_cpi(leg, leg_accounts, &ctx.accounts.user)?;

            account_cursor = accounts_end;

            // Reload balance after intermediate step
            if idx < swap_legs.len() - 1 {
                ctx.accounts.user_token_account.reload()?;
                msg!("   Intermediate balance: {}", ctx.accounts.user_token_account.amount);
            }
        }

        // Final profitability check
        ctx.accounts.user_token_account.reload()?;
        let final_balance = ctx.accounts.user_token_account.amount;

        msg!("üíé Final balance: {} lamports", final_balance);

        // Calculate net profit
        let profit = final_balance
            .checked_sub(initial_balance)
            .ok_or(ArbitrageError::MathOverflow)?;

        msg!(
            "üìà Profit: {} lamports ({:.4}%)",
            profit,
            (profit as f64 / initial_balance as f64) * 100.0
        );

        // Verify minimum profit (CRITICAL: reverts if insufficient)
        require!(
            profit >= min_profit_lamports,
            ArbitrageError::InsufficientProfit
        );

        msg!("‚úÖ ARBITRAGE SUCCESSFUL");

        // Emit event for monitoring
        emit!(ArbitrageExecutedEvent {
            user: ctx.accounts.user.key(),
            initial_balance,
            final_balance,
            profit,
            legs_count: swap_legs.len() as u8,
            timestamp: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }
}

// ============================================================================
// ACCOUNT STRUCTURES
// ============================================================================

#[derive(Accounts)]
pub struct ExecuteArbitrage<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        mut,
        constraint = user_token_account.owner == user.key() @ ArbitrageError::Unauthorized
    )]
    pub user_token_account: Account<'info, TokenAccount>,

    #[account(
        constraint = user_token_account.mint == token_mint.key() @ ArbitrageError::InvalidTokenAccount
    )]
    pub token_mint: Account<'info, Mint>,

    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
}

// ============================================================================
// EVENTS
// ============================================================================

#[event]
pub struct ArbitrageExecutedEvent {
    pub user: Pubkey,
    pub initial_balance: u64,
    pub final_balance: u64,
    pub profit: u64,
    pub legs_count: u8,
    pub timestamp: i64,
}

// ============================================================================
// CPI HELPER FUNCTIONS
// ============================================================================

/// Execute swap via CPI to DEX
fn execute_swap_cpi<'info>(
    leg: &SwapLeg,
    accounts: &'info [AccountInfo<'info>],
    user: &Signer<'info>,
) -> Result<()> {
    match leg.protocol {
        DexProtocol::RaydiumAmmV4 => raydium_amm_swap(leg, accounts, user),
        DexProtocol::RaydiumCpmm => raydium_cpmm_swap(leg, accounts, user),
        DexProtocol::RaydiumClmm => raydium_clmm_swap(leg, accounts, user),
        DexProtocol::MeteoraDlmm => meteora_dlmm_swap(leg, accounts, user),
    }
}

/// Raydium AMM V4 swap_base_in CPI
fn raydium_amm_swap<'info>(
    leg: &SwapLeg,
    accounts: &'info [AccountInfo<'info>],
    _user: &Signer<'info>,
) -> Result<()> {
    require!(accounts.len() == 18, ArbitrageError::InvalidAccountsCount);

    // Raydium AMM V4 swap_base_in discriminator: 0x09
    let mut data = vec![0x09];
    data.extend_from_slice(&leg.amount_in.to_le_bytes());
    data.extend_from_slice(&leg.minimum_amount_out.to_le_bytes());

    let account_metas: Vec<AccountMeta> = accounts
        .iter()
        .map(|acc| AccountMeta {
            pubkey: *acc.key,
            is_signer: acc.is_signer,
            is_writable: acc.is_writable,
        })
        .collect();

    let ix = Instruction {
        program_id: RAYDIUM_AMM_V4,
        accounts: account_metas,
        data,
    };

    invoke(&ix, accounts).map_err(|_| error!(ArbitrageError::CpiCallFailed))?;

    msg!("   ‚úÖ Raydium AMM swap executed");
    Ok(())
}

/// Raydium CPMM swap CPI
fn raydium_cpmm_swap<'info>(
    leg: &SwapLeg,
    accounts: &'info [AccountInfo<'info>],
    _user: &Signer<'info>,
) -> Result<()> {
    require!(accounts.len() >= 10, ArbitrageError::InvalidAccountsCount);

    // CPMM swap discriminator (verify from SDK documentation)
    let mut data = vec![0xf8, 0xc6, 0x9e, 0x91, 0xe1, 0x75, 0x87, 0xc8];
    data.extend_from_slice(&leg.amount_in.to_le_bytes());
    data.extend_from_slice(&leg.minimum_amount_out.to_le_bytes());

    let account_metas: Vec<AccountMeta> = accounts
        .iter()
        .map(|acc| AccountMeta {
            pubkey: *acc.key,
            is_signer: acc.is_signer,
            is_writable: acc.is_writable,
        })
        .collect();

    let ix = Instruction {
        program_id: RAYDIUM_CPMM,
        accounts: account_metas,
        data,
    };

    invoke(&ix, accounts).map_err(|_| error!(ArbitrageError::CpiCallFailed))?;

    msg!("   ‚úÖ Raydium CPMM swap executed");
    Ok(())
}

/// Raydium CLMM swap CPI
fn raydium_clmm_swap<'info>(
    leg: &SwapLeg,
    accounts: &'info [AccountInfo<'info>],
    _user: &Signer<'info>,
) -> Result<()> {
    require!(accounts.len() >= 12, ArbitrageError::InvalidAccountsCount);

    // CLMM swap discriminator
    let mut data = vec![0x7c, 0x1c, 0x97, 0xce, 0x3b, 0x8f, 0x8d, 0x6e];
    data.extend_from_slice(&leg.amount_in.to_le_bytes());
    data.extend_from_slice(&leg.minimum_amount_out.to_le_bytes());
    data.extend_from_slice(&(160 as u128).to_le_bytes()); // sqrt_price_limit

    let account_metas: Vec<AccountMeta> = accounts
        .iter()
        .map(|acc| AccountMeta {
            pubkey: *acc.key,
            is_signer: acc.is_signer,
            is_writable: acc.is_writable,
        })
        .collect();

    let ix = Instruction {
        program_id: RAYDIUM_CLMM,
        accounts: account_metas,
        data,
    };

    invoke(&ix, accounts).map_err(|_| error!(ArbitrageError::CpiCallFailed))?;

    msg!("   ‚úÖ Raydium CLMM swap executed");
    Ok(())
}

/// Meteora DLMM swap CPI
fn meteora_dlmm_swap<'info>(
    leg: &SwapLeg,
    accounts: &'info [AccountInfo<'info>],
    _user: &Signer<'info>,
) -> Result<()> {
    require!(accounts.len() >= 10, ArbitrageError::InvalidAccountsCount);

    // Meteora DLMM swap discriminator
    let mut data = vec![0x13, 0x98, 0xa2, 0x5f, 0x5e, 0x8f, 0x2d, 0x7c];
    data.extend_from_slice(&leg.amount_in.to_le_bytes());
    data.extend_from_slice(&leg.minimum_amount_out.to_le_bytes());

    let account_metas: Vec<AccountMeta> = accounts
        .iter()
        .map(|acc| AccountMeta {
            pubkey: *acc.key,
            is_signer: acc.is_signer,
            is_writable: acc.is_writable,
        })
        .collect();

    let ix = Instruction {
        program_id: METEORA_DLMM,
        accounts: account_metas,
        data,
    };

    invoke(&ix, accounts).map_err(|_| error!(ArbitrageError::CpiCallFailed))?;

    msg!("   ‚úÖ Meteora DLMM swap executed");
    Ok(())
}
--- End File: /home/newvovi5/arbitrage-bot-rust/programs/arbitrage-executor/src/lib.rs ---

--- File: /home/newvovi5/arbitrage-bot-rust/programs/arbitrage-executor/Cargo.toml ---
# programs/arbitrage-executor/Cargo.toml
[package]
name = "arbitrage-executor"
version = "0.1.0"
description = "Solana Arbitrage Executor Smart Contract"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "arbitrage_executor"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
custom-heap = []
custom-panic = []
anchor-debug = []
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]

[dependencies]
anchor-lang = { workspace = true, features = ["init-if-needed"] }
anchor-spl = { workspace = true }


--- End File: /home/newvovi5/arbitrage-bot-rust/programs/arbitrage-executor/Cargo.toml ---

--- File: /home/newvovi5/arbitrage-bot-rust/programs/arbitrage-executor/Xargo.toml ---
# programs/arbitrage-executor/Xargo.toml
# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∫—Ä–æ—Å—Å-–∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –¥–ª—è BPF

[target.bpfel-unknown-unknown.dependencies.std]
features = []

[target.bpfel-unknown-unknown.dependencies.core]
features = []

[target.bpfel-unknown-unknown.dependencies.compiler_builtins]
features = []
--- End File: /home/newvovi5/arbitrage-bot-rust/programs/arbitrage-executor/Xargo.toml ---

--- File: /home/newvovi5/arbitrage-bot-rust/.env ---
# –°—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
SOLANA_RPC_URL=https://api.devnet.solana.com
SOLANA_WS_URL=wss://api.devnet.solana.com
WALLET_PATH=~/.config/solana/id.json
ARBITRAGE_EXECUTOR_PROGRAM_ID=HXccYBQu47LExrec1CAUBybYsXQL2pkEEdTaSD9emRY9
MIN_PROFIT_LAMPORTS=1000
MIN_PROFIT_BPS=10
MAX_SLIPPAGE_BPS=500
INITIAL_AMOUNT_SOL=0.01
LOG_LEVEL=info
TELEMETRY_ENABLED=false

# –ù–û–í–ê–Ø –ü–ï–†–ï–ú–ï–ù–ù–ê–Ø –î–õ–Ø –ü–û–î–î–ï–†–ñ–ö–ò –ö–õ–ê–°–¢–ï–†–û–í
SOLANA_CLUSTER=devnet

OPENBOOK_MARKET_ID=58oQGaA6hKq9Y2V8m5g5m1Y4k1vNHX5wWvLQ9RhGh9Z
BASE_MINT=So11111111111111111111111111111111111111112   # WSOL
QUOTE_MINT=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v # USDC
--- End File: /home/newvovi5/arbitrage-bot-rust/.env ---

